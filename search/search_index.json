{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Binding and Catalysis Networks (BCN) Docs","text":""},{"location":"#project-overview","title":"Project overview","text":""},{"location":"#bcn.binding_network.binding_network","title":"<code>binding_network</code>","text":"Source code in <code>src/bcn/binding_network.py</code> <pre><code>class binding_network:\n  def __init__(self,\n               n_mat,\n               l_mat=np.array([]),\n               is_atomic=False,\n               x_sym=np.array([]),\n               t_sym=np.array([]),\n               k_sym=np.array([])):\n    \"\"\"\n    Initiate a binding network.\n\n    Args:\n        n_mat (numpy array): The stoichiometry matrix defining the binding network.\n        is_atomic (bool, optional): Is the binding network atomic or not. Defaults to None.\n        l_mat (numpy array, optional): The conservation law matrix defining the conserved total quantities.\n            If not given, and is_atomic is True, then it will be computed from n_mat. Defaults to None.\n        x_sym (list of symbols, optional): An ordered list of symbols for the chemical species, denoting columns of the n_mat and l_mat. Defaults to None.\n        t_sym (list of symbols, optional): An ordered list of symbols for the total or conserved quantities, denoting rows of the l_mat. Defaults to None.\n        k_sym (list of symbols, optional): An ordered list of symbols for the binding constants in the dissociation direction, denoting rows of the n_mat. Defaults to None.\n    \"\"\"\n    self.is_atomic=is_atomic\n    self.n_mat=n_mat\n    self.n_mat_sym=sp.Matrix(n_mat)\n    self.dim_r,self.dim_n=self.n_mat.shape\n    self.dim_d = self.dim_n - self.dim_r\n    if not np.any(l_mat): #no input l_mat\n      l_mat=self.l_from_n(self.n_mat)\n      assert np.all(l_mat&gt;=0)\n    # if no input symbols for the x,t,k variables then give them default numerically ordered ones.\n    if not np.any(x_sym):\n      x_sym = sp.symbols(\"x:\"+str(self.dim_n))\n    if not np.any(t_sym):\n      t_sym = sp.symbols(\"t:\"+str(self.dim_d))\n    if not np.any(k_sym):\n      k_sym = sp.symbols(\"k:\"+str(self.dim_r))\n\n    self.l_mat=l_mat\n    self.l_mat_sym=sp.Matrix(l_mat)\n    self.x_sym=x_sym\n    self.t_sym=t_sym\n    self.k_sym=k_sym\n    self.tk_sym=t_sym+k_sym\n    self.opt_var=cp.Variable(self.dim_n)\n\n    self.m_mat=np.concatenate((self.l_mat,self.n_mat),axis=0)\n    self.orientation=np.sign(np.linalg.det(self.m_mat))\n\n    self.ld_sym_dict={}\n    self.activity_regime_dict={}\n    self.activity_ld_regime_dict={}\n    self.activity_regime_constrained_dict={}\n    self.activity_ld_regime_constrained_dict={}\n\n  def l_from_n(self,n_mat):\n    \"\"\"\n    If the network is atomic, compute the L matrix from the N matrix.\n\n    Args:\n        n_mat (numpy array): The stoichiometry matrix defining the binding network.\n            Assumes the columns are ordered so that the atomic species come first.\n\n    Returns:\n        numpy array: The conservation law or totals matrix.\n    \"\"\"\n    assert self.is_atomic\n    r=n_mat.shape[0]\n    d=n_mat.shape[1]-r\n    n1_mat=n_mat[:,:d]\n    n2_mat=n_mat[:,-r:]\n    l2_mat=-(n1_mat.T).dot(np.linalg.inv(n2_mat).T)\n    l_mat=np.concatenate((np.eye(d),l2_mat),axis=1)\n    return l_mat\n\n  def logder_num(self,logvar,chart='x',a_mat=np.array([])):\n    \"\"\"\n    Compute the numerical log derivative of the binding network at points specified by logvar in the specified chart and dominance a_mat.\n\n    Args:\n        logvar (ndarray): Array of the points to evaluate the log derivatives at, in base-10 log. Shape is (n_points, dim_n).\n            In chart 'x', for example, this is logx.\n        chart (str): Specifying the chart that logvar is specified in. Could be 'x', 'xak', or 'tk'.\n        a_mat (numpy array, optional): Matrix defining the variables log derivative is taken in terms of.\n            Assumes all entries are non-negative, and each row has at least one positive entry.\n            Optional, defaults to l_mat of the binding network.\n\n    Returns:\n        logder (ndarray): Array of n-by-n matrix of log derivative of x to (t, k), where t = a_mat @ x, and n is the number of species.\n            Shape is (n_points, dim_n, dim_n).\n        logx (ndarray): Array of logx that the logvar points correspond to. Shape is (n_points, dim_n).\n            This is returned since all input variables, regardless of chart, are mapped to the logx chart first.\n            Returned for convenience.\n    \"\"\"\n    # first check a_mat makes sense.\n    if not np.any(a_mat): # no a_mat argument is given\n      a_mat=self.l_mat\n    else:\n      assert a_mat.shape==(self.dim_d,self.dim_n), f\"the shape of L matrix should be {self.dim_d} by {self.dim_n}.\"\n      assert np.all(a_mat&gt;=0), \"all entries of A matrix should be non-negative.\"\n      assert np.all(a_mat.dot(np.ones(self.dim_n))&gt;0), \"each row of A matrix should have at least one positive entry.\"\n    # for different charts, use different functions to evaluate\n    npts=logvar.shape[0]\n    assert logvar.shape[1]==self.dim_n, 'shape of logvar should be num_points-by-dim_n'\n    logders=np.empty((logvar.shape[0],self.dim_n,self.dim_n))\n    if chart=='x':\n      for i in range(npts):\n        logders[i]=self.logder_x_num(logvar[i],a_mat)\n      logx=logvar\n    elif chart=='xak':\n      assert self.is_atomic, 'the binding network is not atomic, cannot use xak chart'\n      logx=np.empty(logvar.shape)\n      for i in range(npts):\n        logders[i],logx[i]=self.logder_xak_num(logvar[i],a_mat)\n    elif chart=='tk':\n      logx=np.empty(logvar.shape)\n      for i in range(npts):\n        logders[i],logx[i]=self.logder_tk_num(logvar[i],a_mat)\n    else: \n      raise Exception('chart that is not one of \"x,xak,tk\" is not implemented yet')\n    return logders,logx\n\n  def logder_x_num(self,logx,a_mat):\n    \"\"\"\n    Compute the numerical log derivative of the binding network at one point in chart x.\n\n    Args:\n        logx (numpy vector): Vector of concentrations for all the species in log, base-10.\n        a_mat (numpy array): Matrix defining the variables log derivative is taken in terms of.\n            Assumes all entries are non-negative, and each row has at least one positive entry.\n\n    Returns:\n        ndarray: Array of n-by-n matrix of log derivative of x to (t, k), where t = a_mat @ x, and n is the number of species.\n            Shape is (n_points, dim_n, dim_n).\n    \"\"\"\n    x=10**logx\n    t_inv = 1/(a_mat.dot(x))\n    temp=a_mat*x\n    upper=(temp.T*t_inv).T\n    logder_inv=np.concatenate((upper,self.n_mat),axis=0)\n    try:\n      np.linalg.inv(logder_inv)\n    except:\n      print(x)\n      print(t_inv)\n      print(logder_inv)\n\n    return np.linalg.inv(logder_inv)\n\n  def logder_xak_num(self,logxak,a_mat):\n    \"\"\"\n    Compute the numerical log derivative of dlog(x)/dlog(a_mat * x, k) at a point specified by log(xa, k), where xa is the concentration of atomic species, and k is the binding constants. log is base 10.\n        Assumes the network is atomic, and n_mat, a_mat have atomic species coming first.\n\n    Args:\n        logxak (numpy vector): Vector numerical value for atomic species concentration (first dim_d entries) and binding reaction constants (last dim_r entries). Shape is (dim_n,).\n            log is base 10.\n        a_mat (numpy array): Matrix defining the variables log derivative is taken in terms of.\n            Assumes all entries are non-negative, and each row has at least one positive entry.\n\n    Returns:\n        logder (ndarray): Array of n-by-n matrix of log derivative of x to (t, k), where t = a_mat @ x, and n is the number of species.\n            Shape is (n_points, dim_n, dim_n).\n        logx (ndarray): Array of logx that the logvar points correspond to. Shape is (n_points, dim_n).\n            This is returned since all input variables, regardless of chart, are mapped to the logx chart first.\n            Returned for convenience.\n    \"\"\"\n    ## commented out are old code that directly calculate logx, now we use stored map.\n    # d=self.dim_d\n    # logxa=logxak[:d]\n    # logk=logxak[d:]\n    # temp1=(a_mat.T).dot(logxa)\n    # n2_mat=self.n_mat[:,d:]\n    # temp2=np.linalg.inv(n2_mat).dot(logk)\n    # logx=temp1 + np.pad(temp2,(d,0),mode='constant',constant_values=(0,0))\n\n    logx=self.xak2x_num(logxak)\n    return self.logder_x_num(logx,a_mat),logx\n\n  def logder_tk_num(self,logtk,a_mat):\n    \"\"\"\n    Compute the numerical log derivative of dlog(x)/dlog(a_mat @ x, k) at a point specified by log(t, k), where t = a_mat @ x is the concentration of atomic species, and k is the binding constants. log is base 10.\n\n    Args:\n        logtk (numpy vector): Vector numerical value for total concentration (first dim_d entries) and binding reaction constants (last dim_r entries). Shape is (dim_n,).\n            log is base 10.\n        a_mat (numpy array): Matrix defining the variables log derivative is taken in terms of.\n            Assumes all entries are non-negative, and each row has at least one positive entry.\n\n    Returns:\n        logder (ndarray): Array of n-by-n matrix of log derivative of x to (t, k), where t = a_mat @ x, and n is the number of species.\n            Shape is (n_points, dim_n, dim_n).\n        logx (ndarray): Array of logx that the logvar points correspond to. Shape is (n_points, dim_n).\n            This is returned since all input variables, regardless of chart, are mapped to the logx chart first.\n            Returned for convenience.\n    \"\"\"\n    logx=self.tk2x_num(logtk,a_mat)\n    return self.logder_x_num(logx,a_mat),logx\n\n  def logder_activity_num(self,b_vec,logx_array,ld_mat_array):\n    \"\"\"\n    Given a logder matrix, compute the logder of b^T x.\n\n    Args:\n        b_vec (numpy vector): Vector indicating which species are included in the catalytic activity. Shape is (dim_n,).\n            All entries are non-negative, with at least one nonzero.\n        logx_array (ndarray): Array of logx-vector indicating the point at which the logder is evaluated. Shape is (n_points, dim_n).\n            log is base 10.\n        ld_mat_array (ndarray): Array of n x n matrix for dlogx/dlog(t, k) at point x on the manifold. Shape is (n_points, dim_n, dim_n).\n\n    Returns:\n        ndarray: Array of vectors for dlog(b^T x)/dlog(t, k). Shape is (n_points, dim_n).\n    \"\"\"\n    assert np.all(b_vec&gt;=0), \"all entries of b_vec should be non-negative.\"\n    assert np.sum(b_vec)&gt;0, \"there should be at least one nonzero entry in b_vec.\"\n    x_array=10**logx_array # shape (n_points,dim_n)\n    bx_array=x_array*b_vec # each row element-wise product with b_vec\n    # so bx_array has shape (n_points,dim_n)\n    coeff=(bx_array.T/np.sum(bx_array,axis=1)).T # shape (n_points,dim_n)\n    npts=logx_array.shape[0]\n\n    # One implementation is iterate and sum, this is slow (not really?).\n    ld_activity=np.empty((npts,self.dim_n))\n    for i in range(npts):\n      ld_activity[i]=coeff[i].dot(ld_mat_array[i])\n\n    # Another implementation is directly writing out the product\n    # coeff_temp=np.repeat(coeff[:,:,np.newaxis],self.dim_n,axis=2)\n    # ld_activity=(ld_mat_array*coeff_temp).sum(-1)\n\n    # Yet another way is to use einsum. Will do these if speed is a problem.\n\n    return ld_activity\n\n  def x2tk_num(self,logx):\n    \"\"\"\n    Compute the (logt, logk) value given logx.\n\n    Args:\n        logx (numpy vector): Vector numerical value for total variables that define the x point.\n\n    Returns:\n        tuple: A tuple containing two numpy vectors:\n            - logt: The numerical value of total concentration at this point. log is base 10.\n            - logk: The numerical value of binding constants at this point. log is base 10.\n    \"\"\"\n    logt=np.log10(self.l_mat.dot(10**logx))\n    logk=self.n_mat.dot(logx)\n    return logt,logk\n\n  def xak2x_num(self,logxak):\n    \"\"\"\n    Compute the logx value given logxak = (logxa, logk).\n\n    Args:\n        logxak (numpy vector): Vector numerical value for atomic species concentration (first dim_d entries) and binding reaction constants (last dim_r entries). Shape is (dim_n,).\n            log is base 10.\n\n    Returns:\n        numpy vector: The numerical value of logx at this point.\n    \"\"\"\n    try: xak2x_map=self.xak2x_map\n    except AttributeError:\n      self.calc_xak2x_map() # if doesn't exist, calculate it\n      xak2x_map=self.xak2x_map\n    return xak2x_map.dot(logxak)\n\n  def calc_xak2x_map(self):\n    # Defines the matrix (linear map) that takes log(xa,k) to log(x)\n    # and stores it in self.xak2x_map\n    d=self.dim_d\n    r=self.dim_r\n    l2_mat=self.l_mat[:,d:]\n    n2_mat=self.n_mat[:,d:]\n    upper=np.concatenate((np.eye(d),np.zeros((d,r))),axis=1)\n    lower=np.concatenate((l2_mat.T,np.linalg.inv(n2_mat)),axis=1)\n    temp=np.concatenate((upper,lower),axis=0)\n    self.xak2x_map=temp\n\n  def tk2x_num(self,logtk,a_mat):\n    \"\"\"\n    Compute the logx value by numerical integration along the equilibrium manifold using log derivatives. The point on the manifold defined by logtk = (logt, logk) is the same as that defined by logx.\n\n    Args:\n        logtk (numpy vector): Vector numerical value for total variables (in first dim_d entries) and the binding reaction constants (in last dim_r entries) that define the point. \n            p_(logx) = p_(logt, logk). Shape is (dim_n,). log is base 10.\n        a_mat (numpy array): The matrix defining the total variables t = a_mat @ x that the log derivatives are taken with respect to.\n            Default should be specified to be self.l_mat.\n\n    Returns:\n        numpy vector: The numerical value of x at this point. log is base 10.\n    \"\"\"\n\n    # the initial point is always x=1, (t,k) = (A*1, 1)\n    # or, in log, logx=0, (logt,logk) = (log(A*1),0)\n\n    logt0=np.log10(np.sum(a_mat,axis=1))\n    logk0=np.zeros(self.dim_r)\n    y0=np.concatenate((logt0,logk0),axis=0)\n    y1=logtk\n    logx0=np.zeros(self.dim_n)\n    # The time is pseudo time, parameterizing trajectory from y0 to y1,\n    # where y0=(logt0,logk0) = (log(A*1),0), and y1=(logt,logk) the input.\n    # So a point on the trajectory is gamma(tau) = tau*(y1-y0)+y0, 0&lt;=tau&lt;=1.\n    # The time derivative is therefore\n    # dlogx/dtau (x0) = dlogx/dlog(t,k) (x0) * dlog(t,k)/dtau (x0)\n    #                 = dlogx/dlog(t,k) (x0) * (y1-y0)\n    # dlogx/dlog(t,k) (x0) is log derivative matrix evaluated at x0.\n    time_derivative_func=lambda tau,logx: self.logder_x_num(logx,a_mat).dot(y1-y0)\n    sol=solve_ivp(time_derivative_func, [0, 1], logx0)\n    logx=sol.y[:,-1]\n    return logx\n\n  def logder_tk2x_num(self,logvar,chart='x',a_mat=np.array([])):\n    \"\"\"\n    Compute the numerical dlog(t, k)/dlog(x) log derivative of the binding network at points specified by logvar in the specified chart and dominance a_mat.\n\n    Args:\n        logvar (ndarray): Array of the points to evaluate the log derivatives at, in base-10 log. Shape is (n_points, dim_n).\n            In chart 'x', for example, this is logx.\n        chart (str): Specifying the chart that logvar is specified in. Could be 'x', 'xak', or 'tk'.\n        a_mat (numpy array, optional): Matrix defining the variables log derivative is taken in terms of.\n            Assumes all entries are non-negative, and each row has at least one positive entry.\n            Optional, defaults to l_mat of the binding network.\n\n    Returns:\n        logder (ndarray): Array of n-by-n matrix of log derivative of (t, k) to x, where t = a_mat @ x, and n is the number of species.\n            Shape is (n_points, dim_n, dim_n).\n        logx (ndarray): Array of logx that the logvar points correspond to. Shape is (n_points, dim_n).\n            This is returned since all input variables, regardless of chart, are mapped to the logx chart first.\n            Returned for convenience.\n    \"\"\"\n    # first check a_mat makes sense.\n    if not np.any(a_mat): # no a_mat argument is given\n      a_mat=self.l_mat\n    else:\n      assert a_mat.shape==(self.dim_d,self.dim_n), f\"the shape of L matrix should be {self.dim_d} by {self.dim_n}.\"\n      assert np.all(a_mat&gt;=0), \"all entries of A matrix should be non-negative.\"\n      assert np.all(a_mat.dot(np.ones(self.dim_n))&gt;0), \"each row of A matrix should have at least one positive entry.\"\n    # for different charts, use different functions to evaluate\n    npts=logvar.shape[0]\n    assert logvar.shape[1]==self.dim_n, 'shape of logvar should be num_points-by-dim_n'\n    logders=np.empty((logvar.shape[0],self.dim_n,self.dim_n))\n    if chart=='x':\n      for i in range(npts):\n        logders[i]=self.logder_tk2x_x_num(logvar[i],a_mat)\n      logx=logvar\n    elif chart=='xak':\n      assert self.is_atomic, 'the binding network is not atomic, cannot use xak chart'\n      logx=np.empty(logvar.shape)\n      for i in range(npts):\n        logx[i]=self.xak2x_num(logvar[i])\n        logders[i]=self.logder_tk2x_x_num(logx[i],a_mat)\n    elif chart=='tk':\n      logx=np.empty(logvar.shape)\n      for i in range(npts):\n        logx[i]=self.tk2x_num(logvar[i],a_mat)\n        logders[i]=self.logder_tk2x_x_num(logvar[i],a_mat)\n    else: \n      raise Exception('chart that is not one of \"x,xak,tk\" is not implemented yet')\n    return logders,logx\n\n  def logder_tk2x_x_num(self,logx,a_mat):\n    \"\"\"\n    Compute the numerical dlog(t, k)/dlog(x) log derivative of the binding network at one point in chart x.\n\n    Args:\n        logx (numpy vector): Vector of concentrations for all the species in log, base-10.\n        a_mat (numpy array): Matrix defining the variables log derivative is taken in terms of.\n            Assumes all entries are non-negative, and each row has at least one positive entry.\n\n    Returns:\n        ndarray: Array of n-by-n matrix of log derivative of (t, k) to x, where t = a_mat @ x, and n is the number of species.\n            Shape is (n_points, dim_n, dim_n).\n    \"\"\"\n    x=10**logx\n    t_inv = 1/(a_mat.dot(x))\n    temp=a_mat*x\n    upper=(temp.T*t_inv).T\n    logder=np.concatenate((upper,self.n_mat),axis=0)\n    return logder\n\n  def get_complex_ss(self, logk, logx):\n    n1 = self.n_mat[:, : len(logx)]\n    n2 = self.n_mat[:, len(logx): ]\n    n2_inv = np.linalg.inv(n2)\n    logx_complex = np.dot(n2_inv, (logk - np.dot(n1, logx)))\n\n    return 10 ** logx_complex\n\n\n\n# BELOW ARE VERTEX RELATED METHODS\n\n  def vertex_construct(self):\n    \"\"\"\n    Construct the rop_vertex objects that this binding network can have, compute their orientation and feasibility (without additional constraints), and store them in self.vertex_dict.\n    Then the vertices' neighbors, log derivative, and c_mat_xak are computed and stored in these objects.\n\n    Args:\n        None.\n\n    Returns:\n        None. The vertices are recorded in self.vertex_dict and by updating the vertex objects.\n\"\"\"\n    # Construct a dictionary of reachable vertices.\n    # because l_mat tends to be sparse, we iterate through its rows to get nonzero indices,\n    # then each vertex's dominance condition a_mat is choosen from the nonezro indices.\n\n    print('Constructing vertex objects and test for feasibility...')\n    d,n=self.l_mat.shape\n    orientation=self.orientation\n    nnz_list=[]\n    for i in range(d):\n      nnz_list=nnz_list+[np.nonzero(self.l_mat[i,:])[0]]\n    vertex_inf_dict={}\n    vertex_fin_dict={}\n    for perm in itertools.product(*nnz_list):\n      vertex=rop_vertex(perm,self)\n      if vertex.orientation==0:\n        # this is possibly an infinite vertex\n        # check for rank =1, meaning perm has exactly one repeat\n        perm_count=[perm.count(perm[i]) for i in range(d)]\n        if max(perm_count)==2:\n          if perm_count.count(2)==2: # because that same value shows up twice, each with count 2.\n            # after all that check, there still can be infinite vertices that are not reachable\n            # so we do feasibility test.\n            is_feasible=vertex.vertex_feasibility_test(chart='x',opt_constraints=[])\n            # and then add to vertex_inf_dict.\n            if is_feasible:\n              vertex_inf_dict[perm]=vertex\n      elif vertex.orientation==orientation:\n        # this is a finite vertex with the right orientation\n        # we test for feasibility\n        is_feasible=vertex.vertex_feasibility_test(chart='x',opt_constraints=[])\n        # and then add to vertex_fin_dict.\n        if is_feasible:\n          vertex_fin_dict[perm]=vertex\n    vertex_dict={**vertex_fin_dict,**vertex_inf_dict}\n    self.vertex_dict={'all':vertex_dict,'finite':vertex_fin_dict,'infinite':vertex_inf_dict}\n\n    print('Finished vertex construction, now computing neighbors of vertices...')\n    for perm,vv in vertex_dict.items():\n      vv.vertex_find_neighbors()\n\n    print('Finished neighbors, now computing log derivatives...')\n    # first compute log der for finite vertices, since infinite ones rely on\n    # finite neighbors to find orientation.\n    for perm,vv in vertex_dict.items():\n      vv.vertex_ld_calc()\n\n    print('Finished log derivatives, now computing c_mat_xak')\n    # compute c_mat_xak for each vertex in preparation for feasibility tests.\n    for perm,vv in vertex_dict.items():\n      vv.vertex_c_mat_xak_calc()\n    print('Done.')\n\n  def __get_dom_vec(self,a_mat,not_dominated_col_idx,dominated_row_vec_prev,dom_tuple_prev):\n    perm_dict_add={} # use dictionary to make sure repeated ones are combined.\n    for j in not_dominated_col_idx:\n      dominated_row_j = a_mat[:,j]&gt;0\n      dominated_row_vec_new = dominated_row_j - dominated_row_j * dominated_row_vec_prev\n      dominated_row_idx_new = np.where(dominated_row_vec_new)[0]\n      dom_vec = np.array(dom_tuple_prev)\n      dom_vec[dominated_row_idx_new] = j\n      dominated_row_vec_now = dominated_row_vec_prev + dominated_row_vec_new\n      if np.sum(dominated_row_vec_now)&lt;a_mat.shape[0]:\n        # there are rows not yet dominated\n        not_dominated_row_idx_next = np.where(1-dominated_row_vec_now)[0]\n        # then we combine all the rows not yet dominated to find the \n        #   columns not yet dominated. This could result in previously \n        #   already discovered dominance regimes to be counted again.\n        not_dominated_col_idx_next = np.where(np.sum(a_mat[not_dominated_row_idx_next,:],axis=0)&gt;0)[0]\n        perm_dict_add_next = self.__get_dom_vec(a_mat,not_dominated_col_idx_next,dominated_row_vec_now,tuple(dom_vec))\n        perm_dict_add.update(perm_dict_add_next)\n      else: # all rows are dominated\n        perm_dict_add[tuple(dom_vec)]=True\n    return perm_dict_add\n\n  def vertex_construct_direct(self):\n    \"\"\"\n    Construct the rop_vertex objects that this binding network can have, directly, without feasibility test.\n\n    Args:\n        None.\n\n    Returns:\n        None. The vertices are recorded in self.vertex_dict and by updating the vertex objects.\n    \"\"\"\n    # We construct the vertices by iteratively construct all the possible\n    # dominance vector (perm).\n    print('Constructing vertex objects DIRECTLY...')\n    a_mat=self.l_mat\n    d,n=a_mat.shape\n    not_dominated_col_idx=list(range(n))\n    dominated_row_vec_prev=np.zeros(d)\n    dom_tuple_prev=tuple(np.empty(d,dtype=int))\n    perm_dict=self.__get_dom_vec(a_mat,not_dominated_col_idx,dominated_row_vec_prev,dom_tuple_prev)\n    vertex_fin_dict={}\n    vertex_inf_dict={}\n    vertex_infHO_dict={}\n    for perm in perm_dict.keys():\n      vertex=rop_vertex(perm,self)\n      repeat_vec=np.sum(vertex.p_mat,axis=0)\n      if vertex.orientation!=0:\n        vertex_fin_dict[perm]=vertex\n      # elif np.max(repeat_vec)&gt;2 or np.sum(repeat_vec&gt;1) &gt;=2:\n        # there is an index repeated 3 or more times, OR there are more than two indices repeated twice or above;\n        # So this is an infinite vertex of higher order.\n      elif np.sum(repeat_vec[np.where(repeat_vec&gt;1)[0]])&gt;2:\n        # another way to test for higher order is the sum of repeated indices' total repeated times is &gt;2.\n        vertex_infHO_dict[perm]=vertex\n      else: #infinite vertex of order one\n        vertex_inf_dict[perm]=vertex\n    vertex_dict={**vertex_fin_dict,**vertex_inf_dict}\n    self.vertex_dict={'all':vertex_dict,'finite':vertex_fin_dict,'infinite':vertex_inf_dict,'infiniteHO':vertex_infHO_dict}\n\n    print('Finished vertex construction, now computing neighbors of vertices...')\n    for perm,vv in vertex_dict.items():\n      vv.vertex_find_neighbors()\n\n    print('Finished neighbors, now computing log derivatives...')\n    # first compute log der for finite vertices, since infinite ones rely on\n    # finite neighbors to find orientation.\n    for perm,vv in vertex_dict.items():\n      vv.vertex_ld_calc()\n\n    print('Finished log derivatives, now computing c_mat_xak')\n    # compute c_mat_xak for each vertex in preparation for feasibility tests.\n    for perm,vv in vertex_dict.items():\n      vv.vertex_c_mat_xak_calc()\n    print('Done.')\n\n  def vertex_constrained_construct(self,opt_constraints,chart='xak'):\n    \"\"\"\n    Assuming self.vertex_dict is already computed, for given opt_constraints, this function computes whether the vertices are feasible under these constraints, updates rop_vertex.is_feasible for each vertex, and updates each vertex's feasible neighbors (stored in vertex.neighbors_constrained_dict). It returns is_feasible_dict, a dictionary of {perm: is_feasible} pairs.\n    This function calls vertex_list_feasibility_test.\n\n    Args:\n        opt_constraints (list of cvxpy inequalities): List of constraints under which vertices are tested for feasibility.\n        chart (str, optional): A string with value from {'x', 'xak', 'tk'} that specifies the chart that the opt_constraints are described in. Defaults to None.\n\n    Returns:\n        dict: A dictionary of {perm: is_feasible} pairs indicating whether a vertex is feasible.\n    \"\"\"\n    # for the given opt_constraints, test for each vertex whether it is feasible\n    # under opt_constraints, and create a vertex dictionary for feasible vertices\n    # under opt_constraints, stored in self.vertex_constrained_dict.\n    # Also update each vertex's neighbors under constraints,\n    # stored in each vertex.neighbors_constrained_dict.\n\n    print('Compute feasible vertices...')\n    for perm,vv in self.vertex_dict['all'].items():\n      is_feasible=vv.vertex_feasibility_test(chart=chart,opt_constraints=opt_constraints)\n      vv.is_feasible=is_feasible\n    vertex_feasible_all={perm:vv for perm,vv in self.vertex_dict['all'].items() if vv.is_feasible}\n    vertex_feasible_fin={perm:vv for perm,vv in self.vertex_dict['finite'].items() if vv.is_feasible}\n    vertex_feasible_inf={perm:vv for perm,vv in self.vertex_dict['infinite'].items() if vv.is_feasible}\n    self.vertex_constrained_dict={'all':vertex_feasible_all,'finite':vertex_feasible_fin,'infinite':vertex_feasible_inf}\n\n    print('Compute neighbors under opt_constraints...')\n    for perm,vv in self.vertex_dict['all'].items():\n      if vv.is_feasible:\n        # if it is feasible, we want to look at its neighbors.\n        # if a neighbor is feasible, it is still a neighbor under constraint.\n        # if a neighbor is infeasible, we look at its neighbors to see whether\n        # they are feasible. This recurses.\n        vv.vertex_update_constrained_neighbors()\n    print('Done.')\n\n  def vertex_list_feasibility_test(self,opt_constraints,chart='xak'):\n    \"\"\"\n    Given opt_constraints, test all the vertices for their feasibility and return is_feasible_dict.\n    This function is called by vertex_constrained_construct.\n    It can also be directly called to test for feasibility without storing or finding feasible neighbors.\n\n    Args:\n        opt_constraints (list of cvxpy inequalities): List of constraints under which vertices are tested for feasibility.\n        chart (str, optional): A string with value from {'x', 'xak', 'tk'} that specifies the chart that the opt_constraints are described in. Defaults to None.\n\n    Returns:\n        dict: A dictionary of {perm: is_feasible} pairs indicating whether a vertex is feasible.\n    \"\"\"\n    # for the given opt_constraints, test each of the vertex whether it is feasible\n    is_feasible_fin={}\n    is_feasible_inf={}\n    for perm,vv in self.vertex_dict['finite'].items():\n      is_feasible=vv.vertex_feasibility_test(chart=chart,opt_constraints=opt_constraints)\n      is_feasible_fin[perm]=is_feasible\n    for perm,vv in self.vertex_dict['infinite'].items():\n      is_feasible=vv.vertex_feasibility_test(chart=chart,opt_constraints=opt_constraints)\n      is_feasible_inf[perm]=is_feasible\n\n    is_feasible_all={**is_feasible_fin,**is_feasible_inf}\n    is_feasible_dict={'all':is_feasible_all,'finite':is_feasible_fin,'infinite':is_feasible_inf}\n    return is_feasible_dict\n\n  def sampling_over_vertex_hull(self,nsample,vertex_perm_list=[],is_finite_only=False, chart='x',logmin=-6,logmax=6,margin=0,c_mat_extra=[],c0_vec_extra=[]):\n    \"\"\"\n    Randomly sample points in the log space of chart variables, but instead of log-uniform, we first assign points to each vertex in an even fashion, then sample uniformly within each vertex.\n\n    Args:\n        nsample (int): The number of points to be sampled in the space of chart variables.\n            This is divided evenly to all the vertices of this binding network.\n        is_finite_only (bool, optional): Useful only when vertex_perm_list=[], so that all vertices are sampled.\n            If True, only finite vertices are sampled. This also allows chart 'tk' to work.\n            If False, both finite and infinite vertices are sampled. Defaults to False.\n        vertex_perm_list (list of vertex's perm tuples, optional): The list of perms indexing the vertices to be sampled.\n            e.g. [(0,1,2), (0,1,3)]. Defaults to empty list []. If empty, sample all vertices.\n        chart (str, optional): A string indicating the chart that the opt_constraints are specified in.\n            Choices are 'x', 'xak', and 'tk'. Defaults to 'x'.\n        margin (float, optional): The vertex's feasibility conditions are inequalities,\n            of the form c_mat * logx + c0_vec &gt; margin (e.g. in 'x' chart),\n            where margin is the positive threshold used here. Defaults to 0.\n            This can be adjusted to be stronger/weaker requirements on dominance.\n        logmin (float or ndarray vector): logmin, logmax could be scalars, then it's the same value applied to every variable.\n            They could also be vectors of length dim_n.\n        logmax (float or ndarray vector): logmin, logmax could be scalars, then it's the same value applied to every variable.\n            They could also be vectors of length dim_n.\n\n    Returns:\n        dict: A dictionary of ndarray with shape (nsample, dim_n).\n            Key is the perm of each vertex. Value is the sample for that vertex.\n    \"\"\"\n\n    # calculate number of vertex to be plotted and the dictionary of vertices.\n    vertex_plot_dict={}\n    if vertex_perm_list: # vertex_perm_list is not empty\n      nvertex=len(vertex_perm_list)\n      for perm in vertex_perm_list:\n        vertex_plot_dict[perm]=self.vertex_dict['all'][perm]\n    else: # plot all vertices\n      if is_finite_only: \n        finite_key='finite'\n      else: \n        finite_key='all'\n      nvertex=len(self.vertex_dict[finite_key].keys())\n      vertex_plot_dict=self.vertex_dict[finite_key]\n    # now sample each vertex.\n    nsample_per_vertex=int(nsample/nvertex) # take the floor for number of sample per vertex\n    sample_vertex_dict={}\n    for key,vv in vertex_plot_dict.items():\n      print(key)\n      sample_vertex_dict[key]=vv.vertex_hull_sampling(nsample_per_vertex,chart=chart,margin=margin,logmin=logmin,logmax=logmax,c_mat_extra=c_mat_extra,c0_vec_extra=c0_vec_extra)\n    return sample_vertex_dict\n\n  def sampling_over_activity_regime_hull(self,nsample,b_tuple,regime_key_list=[],is_finite_only=False,is_feasible_only=False,chart='x',logmin=-6,logmax=6,margin=0,c_mat_extra=[],c0_vec_extra=[]):\n    \"\"\"\n    Randomly sample points in the log space of chart variables for each dom_regime for a given activity, but instead of log-uniform, we first assign points to each vertex in an even fashion, then sample uniformly within each vertex.\n\n    Args:\n        nsample (int): The number of points to be sampled in the space of chart variables.\n            This is divided evenly to all the vertices of this binding network.\n        b_tuple (tuple of length dim_n): The b_tuple indicating the activity whose dom_regimes we are interested in sampling.\n        is_finite_only (bool, optional): If True, only finite dom_regimes are sampled.\n            If False, both finite and infinite dom_regimes are sampled. Defaults to False.\n        regime_key_list (list of dominance regime's keys, optional): The list of keys for dom_regimes indexing the dom_regimes to be sampled.\n            e.g. [((0,1,2),7), ((0,1,3),7)]. If empty, sample all dom_regimes. Defaults to empty list [].\n        is_feasible_only (bool, optional): If True, only feasible dom_regimes are sampled.\n            If False, all dom_regimes in regime_key_list (or all in this activity) are sampled.\n            Each dom_regime's is_feasible tag comes from results of the most recent feasibility test.\n        chart (str, optional): A string indicating the chart that the opt_constraints are specified in.\n            Choices are 'x', 'xak', and 'tk'. Defaults to 'x'.\n        margin (float, optional): The vertex's feasibility conditions are inequalities,\n            of the form c_mat * logx + c0_vec &gt; margin (e.g. in 'x' chart),\n            where margin is the positive threshold used here. Defaults to 0.\n            This can be adjusted to be stronger/weaker requirements on dominance.\n        logmin (float or ndarray vector): logmin, logmax could be scalars, then it's the same value applied to every variable.\n            They could also be vectors of length dim_n.\n        logmax (float or ndarray vector): logmin, logmax could be scalars, then it's the same value applied to every variable.\n            They could also be vectors of length dim_n.\n\n    Returns:\n        dict: A dictionary of ndarray with shape (nsample, dim_n).\n            Key is the perm of each vertex. Value is the sample for that vertex.\n    \"\"\"\n    pass\n    # # calculate number of vertex to be plotted and the dictionary of vertices.\n    # vertex_plot_dict={}\n    # if vertex_perm_list: # vertex_perm_list is not empty\n    #   nvertex=len(vertex_perm_list)\n    #   for perm in vertex_perm_list:\n    #     vertex_plot_dict[perm]=self.vertex_dict['all'][perm]\n    # else: # plot all vertices\n    #   if is_finite_only: \n    #     finite_key='finite'\n    #   else: \n    #     finite_key='all'\n    #   nvertex=len(self.vertex_dict[finite_key].keys())\n    #   vertex_plot_dict=self.vertex_dict[finite_key]\n    # # now sample each vertex.\n    # nsample_per_vertex=int(nsample/nvertex) # take the floor for number of sample per vertex\n    # sample_vertex_dict={}\n    # for key,vv in vertex_plot_dict.items():\n    #   sample_vertex_dict[key]=vv.vertex_hull_sampling(nsample_per_vertex,chart=chart,margin=margin,logmin=logmin,logmax=logmax)\n    # return sample_vertex_dict\n\n  def activity_regime_construct(self,b_vec):\n    # given b_vec, go through all vertices and their possible regimes\n    # test for basic feasibility, and return a dictionary of regimes\n    # {(perm,row):regime}; perm is vertex, row is dominant species in activity (b_vec)\n    # regime is an rop_dom_regime object.\n    b_vec=np.array(b_vec)\n    print('Computing feasible regimes...')\n    nnz_b=np.where(b_vec&gt;0)[0]\n    regime_fin_dict={}\n    regime_inf_dict={}\n    for perm,vv in self.vertex_dict['all'].items():\n      for j in nnz_b:\n        regime=rop_dom_regime(j,b_vec,perm,self)\n        # if vv.orientation == 0 and np.all(regime.ld==0): #this is an infinite vertex in direction not relevant for this activity\n        #   continue\n        is_feasible=regime.feasibility_test(chart='x',opt_constraints=[])\n        if is_feasible:\n          if vv.orientation == 0:\n            regime_inf_dict[(perm,j)]=regime\n          else: regime_fin_dict[(perm,j)]=regime\n\n    regime_all_dict={**regime_fin_dict,**regime_inf_dict}\n    self.activity_regime_dict[tuple(b_vec)]={'finite':regime_fin_dict,\n                                            'infinite':regime_inf_dict,\n                                            'all':regime_all_dict}\n\n    print('Feasible regime computed, computing their neighboring regimes...')\n    for key,regime in regime_all_dict.items():\n      regime.find_neighbors()\n    for key,regime in regime_all_dict.items():\n      regime.find_neighbors_zero()\n\n    print('Computing activity logder regimes dictionary... ')\n    # since several regimes will have the same log derivative, we use log derivative as key, rather than regimes.\n    ld_regime_fin_key_dict={}\n    ld_regime_inf_key_dict={}\n    for key,regime in regime_fin_dict.items():\n      try: ld_regime_fin_key_dict[tuple(regime.ld)]+=[key] #add regime to ld\n      except KeyError: ld_regime_fin_key_dict[tuple(regime.ld)]=[key] #no regimes yet, initiate.\n    for key,regime in regime_inf_dict.items():\n      try: ld_regime_inf_key_dict[tuple(regime.ld)]+=[key] #add regime to ld\n      except KeyError: ld_regime_inf_key_dict[tuple(regime.ld)]=[key] #no regimes yet, initiate.\n    # convert into dictionary of ld_regime objects\n    ld_regime_fin_dict={}\n    ld_regime_inf_dict={}\n    is_ray=False\n    for ld,regime_keys in ld_regime_fin_key_dict.items():\n      ld_regime=rop_ld_regime(ld,is_ray,b_vec,regime_keys,self)\n      ld_regime_fin_dict[ld]=ld_regime\n    is_ray=True\n    for ld,regime_keys in ld_regime_inf_key_dict.items():\n      ld_regime=rop_ld_regime(ld,is_ray,b_vec,regime_keys,self)\n      ld_regime_inf_dict[ld]=ld_regime\n\n    ld_regime_all_dict={**ld_regime_fin_dict,**ld_regime_inf_dict}\n    self.activity_ld_regime_dict[tuple(b_vec)]={'finite':ld_regime_fin_dict,\n                                               'infinite':ld_regime_inf_dict,\n                                               'all':ld_regime_all_dict}\n\n    print('Computing activity logder regimes neighbors... ')\n    for key,ld_regime in ld_regime_all_dict.items():\n      ld_regime.find_neighbors()\n\n    print('Done')\n\n  def activity_regime_constrained_construct(self,b_vec,opt_constraints,chart='xak'):\n    # For the given opt_constraints, test for each dom_regime whether it is\n    # feasible, update their neighbors under constraint,\n    # and create a dictionary for feasible dom_regimes, stored in\n    # self.activity_regime_contrained_dict[b_vec].\n    # and create a dictionary for feasible ld_regimes, stored in\n    # self.activity_ld_regime_constrained_dict[b_vec].\n    print(\"Compute dominance regimes' feasibility...\")\n    regime_constrained_fin={}\n    regime_constrained_inf={}\n    for key,regime in self.activity_regime_dict[tuple(b_vec)]['all'].items():\n      is_feasible=regime.feasibility_test(chart=chart,opt_constraints=opt_constraints)\n      regime.is_feasible=is_feasible\n      if is_feasible:\n        if regime.vertex.orientation==0:\n          regime_constrained_inf[key]=regime\n        else:\n          regime_constrained_fin[key]=regime\n    regime_constrained_all={**regime_constrained_fin,**regime_constrained_inf}\n    self.activity_regime_constrained_dict[tuple(b_vec)]={'all':regime_constrained_all,'finite':regime_constrained_fin,'infinite':regime_constrained_inf}\n\n    print(\"Compute regimes' neighboring regimes under opt_constraints...\")\n    for key,regime in self.activity_regime_dict[tuple(b_vec)]['all'].items():\n      if regime.is_feasible:\n        # if it is feasible, we want to look at its neighbors.\n        # if a neighbor is feasible, it is still a neighbor.\n        # if a neighbor is infeasible, we look at its neighbors to see whether\n        # they are feasible.\n        regime.update_constrained_neighbors()\n\n    print(\"Compute ld regimes' feasibility and compute neighbors under opt_constraints...\")\n    ld_regime_constrained_fin={}\n    ld_regime_constrained_inf={}\n    for ld,ld_regime in self.activity_ld_regime_dict[tuple(b_vec)]['all'].items():\n      ld_regime.update_feasibility()\n      if ld_regime.is_feasible:\n        ld_regime.update_constrained_neighbors()\n        if ld_regime.is_ray:\n          ld_regime_constrained_inf[ld]=ld_regime\n        else:\n          ld_regime_constrained_fin[ld]=ld_regime\n    ld_regime_constrained_all={**ld_regime_constrained_fin,**ld_regime_constrained_inf}\n    self.activity_ld_regime_constrained_dict[tuple(b_vec)]={\n        'all':ld_regime_constrained_all,\n        'finite':ld_regime_constrained_fin,\n        'infinite':ld_regime_constrained_inf\n        }\n\n    print('Done')\n\n  def activity_list_feasibility_test(self,b_vec,opt_constraints,chart='xak'):\n    # for the activity defined by b_vec (b_vec*x), and constraints given in\n    # opt_constraints in chart (default xak), test each of the ld_regime\n    # whether it is feasible.\n    # A ld_regime is feasible if one of its dom_regime is feasible.\n    is_feasible_fin={}\n    is_feasible_inf={}\n    for ld,ld_regime in self.activity_ld_regime_dict[tuple(b_vec)]['finite'].items():\n      is_feasible_dom_regime_list=[dom_regime.feasibility_test(chart=chart,opt_constraints=opt_constraints) for dom_regime in ld_regime.dom_regime_dict.values()]\n      is_feasible=np.any(is_feasible_dom_regime_list)\n      is_feasible_fin[ld]=is_feasible\n    for ld,ld_regime in self.activity_ld_regime_dict[tuple(b_vec)]['infinite'].items():\n      is_feasible_dom_regime_list=[dom_regime.feasibility_test(chart=chart,opt_constraints=opt_constraints) for dom_regime in ld_regime.dom_regime_dict.values()]\n      is_feasible=np.any(is_feasible_dom_regime_list)\n      is_feasible_inf[ld]=is_feasible\n    is_feasible_all={**is_feasible_fin,**is_feasible_inf}\n    is_feasible_dict={'all':is_feasible_all,'finite':is_feasible_fin,'infinite':is_feasible_inf}\n    return is_feasible_dict\n\n# BELOW ARE SYMBOLIC METHODS for the binding network\n\n  def logder_sym(self,a_mat=np.array([]),is_saved=True):\n    \"\"\"\n    Calculate the symbolic log derivative matrix of dlog(x)/dlog(a_mat @ x, k).\n\n    Args:\n        a_mat (numpy array, optional): Matrix defining the variables log derivative is taken in terms of.\n            Assumes all entries are non-negative, and each row has at least one positive entry.\n            Optional, defaults to l_mat of the binding network.\n        is_saved (bool, optional): To save the resulting logdermat as parameter ld_sym of the binding network or not.\n            Defaults to True.\n\n    Returns:\n        sympy.Matrix: Symbolic log derivative matrix for x to (t_sym_temp, k_sym) expressed in terms of x.\n\n    Note:\n        If the provided a_mat yields a noninvertible matrix, then the function will return logdermat as a matrix of zeros (with the appropriate size).\n    \"\"\"\n    if not np.any(a_mat): # no a_mat argument is given\n      a_mat=self.l_mat\n    else:\n      assert a_mat.shape==(self.dim_d,self.dim_n), f\"the shape of L matrix should be {self.dim_d} by {self.dim_n}.\"\n      assert np.all(a_mat&gt;=0), \"all entries of A matrix should be non-negative.\"\n      assert np.all(a_mat.dot(np.ones(self.dim_n))&gt;0), \"each row of A matrix should have at least one positive entry.\"\n\n    a_mat_sym=sp.Matrix(a_mat)\n    n_mat_sym=self.n_mat_sym\n\n    #it's much faster (10x) to use a dummy \"total\" variables to calculate matrix inverse,\n    # and then substitute the expression for the totals in terms of x, rather than\n    # inverting with the totals explicitly expressed in x variables.\n\n    temp_sym = sp.symbols(\"t:\"+str(self.dim_d))\n\n    Lam_t = sp.Matrix.diag(*temp_sym)\n    Lam_x = sp.Matrix.diag(*self.x_sym)\n\n    topmat = Lam_t**-1 * a_mat_sym * Lam_x\n    fullmat = topmat.col_join(n_mat_sym)\n\n    logdermat_t = fullmat**-1\n\n    temp_expr=a_mat_sym*sp.Matrix(self.x_sym)\n    temp2x_subs_list=[(temp_sym[i],temp_expr[i]) for i in range(self.dim_d)]\n    logdermat=sp.simplify(logdermat_t.subs(temp2x_subs_list))\n\n    if is_saved: self.ld_sym_dict[a_mat.tobytes()]=logdermat\n    return logdermat\n\n  def subs_list_t2x(self):\n    total_expr=self.l_mat_sym*sp.Matrix(self.x_sym)\n    t2x_subs_list=[(self.t_sym[i],total_expr[i]) for i in range(self.dim_d)]\n    return t2x_subs_list\n\n  def subs_list_xc2xak(self):\n    assert self.is_atomic, \"this operation requires the binding network to be atomic\"\n    l2_mat_sym=self.l_mat_sym[:,self.dim_d:]\n    n2_mat_sym=self.n_mat_sym[:,self.dim_d:]\n    xa_sym_vec=sp.Matrix(self.x_sym[:self.dim_d])\n    xa_sym_log=xa_sym_vec.applyfunc(sp.log)\n    xc2xak_log_expr=l2_mat_sym.T*xa_sym_log+n2_mat_sym.inv()*sp.Matrix(self.k_sym).applyfunc(sp.log)\n    func_exponentiate=lambda x:sp.E**x\n    xc2xak_expr=xc2xak_log_expr.applyfunc(func_exponentiate)\n    xc2xak_subs_list=[(self.x_sym[self.dim_d+i],xc2xak_expr[i]) for i in range(self.dim_r)]\n    return xc2xak_subs_list\n\n  def t2x_sym(self,expr):\n    \"\"\"\n    Input a symbolic expression containing totals t, and map it to x.\n\n    Args:\n        expr (sympy symbolic expression): A symbolic expression to be converted.\n\n    Returns:\n        sympy symbolic expression: The symbolic expression after conversion.\n    \"\"\"\n    # calculate the substitutions map for totals to species\n    try: expr_x=expr.subs(self.t2x)\n    except AttributeError:\n      t2x_subs_list=self.subs_list_t2x()\n      self.t2x=t2x_subs_list\n      expr_x=expr.subs(self.t2x)\n    return expr_x\n\n  def xc2xak_sym(self,expr):\n    \"\"\"\n    Input a symbolic expression containing complex species x^c, and map it to x^a and k.\n\n    Args:\n        expr (sympy symbolic expression): A symbolic expression to be converted.\n\n    Returns:\n        sympy symbolic expression: The symbolic expression after conversion.\n    \"\"\"\n    assert self.is_atomic, \"this operation requires the binding network to be atomic\"\n    # calculate the substitutions map for complex species to atomic species and k's, if it does not exist.\n    try: expr_xak=expr.subs(self.xc2xak)\n    except AttributeError:\n      xc2xak_subs_list=self.subs_list_xc2xak()\n      self.xc2xak=xc2xak_subs_list\n      expr_xak=expr.subs(self.xc2xak)\n    return expr_xak\n\n  def logder_sym_activity(self,b_vec_sym,a_mat=np.array([])):\n    \"\"\"\n    Compute the log derivative of a linear sum of x, i.e. dlog(b_vec_sym * x)/dlog(tp, k), where tp = a_mat * x.\n\n    Args:\n        b_vec_sym (sympy symbolic vector): A vector of symbolic expressions corresponding to coefficients to be summed. Shape is (n, 1).\n        a_mat (numpy array, optional): The matrix denoting the variables a_mat * x that the log derivative is taken with respect to.\n            Defaults to self.l_mat.\n\n    Returns:\n        sympy vector: The symbolic log derivative dlog(b_vec_sym * x)/dlog(tp, k), where tp = a_mat * x.\n    \"\"\"\n    if not np.any(a_mat): # no a_mat argument is given\n      a_mat=self.l_mat\n    # check if logder is already calculated with respect to this a_mat.\n    try: ld_sym=self.ld_sym_dict[a_mat.tobytes()]\n    except KeyError: # not calculated yet\n      print('Symbolic logder for this chart coordinate does not exist, calculating...')\n      ld_sym=self.logder_sym(a_mat=a_mat)\n    coeff_vec_sym=sp.Matrix(np.zeros(b_vec_sym.shape))\n    bx = sp.matrix_multiply_elementwise(b_vec_sym,sp.Matrix(self.x_sym)) #b multiply x element-wise\n    bx_sum = bx.T*sp.ones(*bx.shape)\n    coeff_vec_sym=bx*bx_sum**(-1) # convex coefficients for the log derivative sum\n    ld_sym_sum=(ld_sym.T*coeff_vec_sym).T # for logder matrix ld_sym, rows are species, columns are variables.\n    return ld_sym_sum\n</code></pre>"},{"location":"#bcn.binding_network.binding_network.__init__","title":"<code>__init__(n_mat, l_mat=np.array([]), is_atomic=False, x_sym=np.array([]), t_sym=np.array([]), k_sym=np.array([]))</code>","text":"<p>Initiate a binding network.</p> <p>Parameters:</p> Name Type Description Default <code>n_mat</code> <code>numpy array</code> <p>The stoichiometry matrix defining the binding network.</p> required <code>is_atomic</code> <code>bool</code> <p>Is the binding network atomic or not. Defaults to None.</p> <code>False</code> <code>l_mat</code> <code>numpy array</code> <p>The conservation law matrix defining the conserved total quantities. If not given, and is_atomic is True, then it will be computed from n_mat. Defaults to None.</p> <code>array([])</code> <code>x_sym</code> <code>list of symbols</code> <p>An ordered list of symbols for the chemical species, denoting columns of the n_mat and l_mat. Defaults to None.</p> <code>array([])</code> <code>t_sym</code> <code>list of symbols</code> <p>An ordered list of symbols for the total or conserved quantities, denoting rows of the l_mat. Defaults to None.</p> <code>array([])</code> <code>k_sym</code> <code>list of symbols</code> <p>An ordered list of symbols for the binding constants in the dissociation direction, denoting rows of the n_mat. Defaults to None.</p> <code>array([])</code> Source code in <code>src/bcn/binding_network.py</code> <pre><code>def __init__(self,\n             n_mat,\n             l_mat=np.array([]),\n             is_atomic=False,\n             x_sym=np.array([]),\n             t_sym=np.array([]),\n             k_sym=np.array([])):\n  \"\"\"\n  Initiate a binding network.\n\n  Args:\n      n_mat (numpy array): The stoichiometry matrix defining the binding network.\n      is_atomic (bool, optional): Is the binding network atomic or not. Defaults to None.\n      l_mat (numpy array, optional): The conservation law matrix defining the conserved total quantities.\n          If not given, and is_atomic is True, then it will be computed from n_mat. Defaults to None.\n      x_sym (list of symbols, optional): An ordered list of symbols for the chemical species, denoting columns of the n_mat and l_mat. Defaults to None.\n      t_sym (list of symbols, optional): An ordered list of symbols for the total or conserved quantities, denoting rows of the l_mat. Defaults to None.\n      k_sym (list of symbols, optional): An ordered list of symbols for the binding constants in the dissociation direction, denoting rows of the n_mat. Defaults to None.\n  \"\"\"\n  self.is_atomic=is_atomic\n  self.n_mat=n_mat\n  self.n_mat_sym=sp.Matrix(n_mat)\n  self.dim_r,self.dim_n=self.n_mat.shape\n  self.dim_d = self.dim_n - self.dim_r\n  if not np.any(l_mat): #no input l_mat\n    l_mat=self.l_from_n(self.n_mat)\n    assert np.all(l_mat&gt;=0)\n  # if no input symbols for the x,t,k variables then give them default numerically ordered ones.\n  if not np.any(x_sym):\n    x_sym = sp.symbols(\"x:\"+str(self.dim_n))\n  if not np.any(t_sym):\n    t_sym = sp.symbols(\"t:\"+str(self.dim_d))\n  if not np.any(k_sym):\n    k_sym = sp.symbols(\"k:\"+str(self.dim_r))\n\n  self.l_mat=l_mat\n  self.l_mat_sym=sp.Matrix(l_mat)\n  self.x_sym=x_sym\n  self.t_sym=t_sym\n  self.k_sym=k_sym\n  self.tk_sym=t_sym+k_sym\n  self.opt_var=cp.Variable(self.dim_n)\n\n  self.m_mat=np.concatenate((self.l_mat,self.n_mat),axis=0)\n  self.orientation=np.sign(np.linalg.det(self.m_mat))\n\n  self.ld_sym_dict={}\n  self.activity_regime_dict={}\n  self.activity_ld_regime_dict={}\n  self.activity_regime_constrained_dict={}\n  self.activity_ld_regime_constrained_dict={}\n</code></pre>"},{"location":"#bcn.binding_network.binding_network.l_from_n","title":"<code>l_from_n(n_mat)</code>","text":"<p>If the network is atomic, compute the L matrix from the N matrix.</p> <p>Parameters:</p> Name Type Description Default <code>n_mat</code> <code>numpy array</code> <p>The stoichiometry matrix defining the binding network. Assumes the columns are ordered so that the atomic species come first.</p> required <p>Returns:</p> Type Description <p>numpy array: The conservation law or totals matrix.</p> Source code in <code>src/bcn/binding_network.py</code> <pre><code>def l_from_n(self,n_mat):\n  \"\"\"\n  If the network is atomic, compute the L matrix from the N matrix.\n\n  Args:\n      n_mat (numpy array): The stoichiometry matrix defining the binding network.\n          Assumes the columns are ordered so that the atomic species come first.\n\n  Returns:\n      numpy array: The conservation law or totals matrix.\n  \"\"\"\n  assert self.is_atomic\n  r=n_mat.shape[0]\n  d=n_mat.shape[1]-r\n  n1_mat=n_mat[:,:d]\n  n2_mat=n_mat[:,-r:]\n  l2_mat=-(n1_mat.T).dot(np.linalg.inv(n2_mat).T)\n  l_mat=np.concatenate((np.eye(d),l2_mat),axis=1)\n  return l_mat\n</code></pre>"},{"location":"#bcn.binding_network.binding_network.logder_activity_num","title":"<code>logder_activity_num(b_vec, logx_array, ld_mat_array)</code>","text":"<p>Given a logder matrix, compute the logder of b^T x.</p> <p>Parameters:</p> Name Type Description Default <code>b_vec</code> <code>numpy vector</code> <p>Vector indicating which species are included in the catalytic activity. Shape is (dim_n,). All entries are non-negative, with at least one nonzero.</p> required <code>logx_array</code> <code>ndarray</code> <p>Array of logx-vector indicating the point at which the logder is evaluated. Shape is (n_points, dim_n). log is base 10.</p> required <code>ld_mat_array</code> <code>ndarray</code> <p>Array of n x n matrix for dlogx/dlog(t, k) at point x on the manifold. Shape is (n_points, dim_n, dim_n).</p> required <p>Returns:</p> Name Type Description <code>ndarray</code> <p>Array of vectors for dlog(b^T x)/dlog(t, k). Shape is (n_points, dim_n).</p> Source code in <code>src/bcn/binding_network.py</code> <pre><code>def logder_activity_num(self,b_vec,logx_array,ld_mat_array):\n  \"\"\"\n  Given a logder matrix, compute the logder of b^T x.\n\n  Args:\n      b_vec (numpy vector): Vector indicating which species are included in the catalytic activity. Shape is (dim_n,).\n          All entries are non-negative, with at least one nonzero.\n      logx_array (ndarray): Array of logx-vector indicating the point at which the logder is evaluated. Shape is (n_points, dim_n).\n          log is base 10.\n      ld_mat_array (ndarray): Array of n x n matrix for dlogx/dlog(t, k) at point x on the manifold. Shape is (n_points, dim_n, dim_n).\n\n  Returns:\n      ndarray: Array of vectors for dlog(b^T x)/dlog(t, k). Shape is (n_points, dim_n).\n  \"\"\"\n  assert np.all(b_vec&gt;=0), \"all entries of b_vec should be non-negative.\"\n  assert np.sum(b_vec)&gt;0, \"there should be at least one nonzero entry in b_vec.\"\n  x_array=10**logx_array # shape (n_points,dim_n)\n  bx_array=x_array*b_vec # each row element-wise product with b_vec\n  # so bx_array has shape (n_points,dim_n)\n  coeff=(bx_array.T/np.sum(bx_array,axis=1)).T # shape (n_points,dim_n)\n  npts=logx_array.shape[0]\n\n  # One implementation is iterate and sum, this is slow (not really?).\n  ld_activity=np.empty((npts,self.dim_n))\n  for i in range(npts):\n    ld_activity[i]=coeff[i].dot(ld_mat_array[i])\n\n  # Another implementation is directly writing out the product\n  # coeff_temp=np.repeat(coeff[:,:,np.newaxis],self.dim_n,axis=2)\n  # ld_activity=(ld_mat_array*coeff_temp).sum(-1)\n\n  # Yet another way is to use einsum. Will do these if speed is a problem.\n\n  return ld_activity\n</code></pre>"},{"location":"#bcn.binding_network.binding_network.logder_num","title":"<code>logder_num(logvar, chart='x', a_mat=np.array([]))</code>","text":"<p>Compute the numerical log derivative of the binding network at points specified by logvar in the specified chart and dominance a_mat.</p> <p>Parameters:</p> Name Type Description Default <code>logvar</code> <code>ndarray</code> <p>Array of the points to evaluate the log derivatives at, in base-10 log. Shape is (n_points, dim_n). In chart 'x', for example, this is logx.</p> required <code>chart</code> <code>str</code> <p>Specifying the chart that logvar is specified in. Could be 'x', 'xak', or 'tk'.</p> <code>'x'</code> <code>a_mat</code> <code>numpy array</code> <p>Matrix defining the variables log derivative is taken in terms of. Assumes all entries are non-negative, and each row has at least one positive entry. Optional, defaults to l_mat of the binding network.</p> <code>array([])</code> <p>Returns:</p> Name Type Description <code>logder</code> <code>ndarray</code> <p>Array of n-by-n matrix of log derivative of x to (t, k), where t = a_mat @ x, and n is the number of species. Shape is (n_points, dim_n, dim_n).</p> <code>logx</code> <code>ndarray</code> <p>Array of logx that the logvar points correspond to. Shape is (n_points, dim_n). This is returned since all input variables, regardless of chart, are mapped to the logx chart first. Returned for convenience.</p> Source code in <code>src/bcn/binding_network.py</code> <pre><code>def logder_num(self,logvar,chart='x',a_mat=np.array([])):\n  \"\"\"\n  Compute the numerical log derivative of the binding network at points specified by logvar in the specified chart and dominance a_mat.\n\n  Args:\n      logvar (ndarray): Array of the points to evaluate the log derivatives at, in base-10 log. Shape is (n_points, dim_n).\n          In chart 'x', for example, this is logx.\n      chart (str): Specifying the chart that logvar is specified in. Could be 'x', 'xak', or 'tk'.\n      a_mat (numpy array, optional): Matrix defining the variables log derivative is taken in terms of.\n          Assumes all entries are non-negative, and each row has at least one positive entry.\n          Optional, defaults to l_mat of the binding network.\n\n  Returns:\n      logder (ndarray): Array of n-by-n matrix of log derivative of x to (t, k), where t = a_mat @ x, and n is the number of species.\n          Shape is (n_points, dim_n, dim_n).\n      logx (ndarray): Array of logx that the logvar points correspond to. Shape is (n_points, dim_n).\n          This is returned since all input variables, regardless of chart, are mapped to the logx chart first.\n          Returned for convenience.\n  \"\"\"\n  # first check a_mat makes sense.\n  if not np.any(a_mat): # no a_mat argument is given\n    a_mat=self.l_mat\n  else:\n    assert a_mat.shape==(self.dim_d,self.dim_n), f\"the shape of L matrix should be {self.dim_d} by {self.dim_n}.\"\n    assert np.all(a_mat&gt;=0), \"all entries of A matrix should be non-negative.\"\n    assert np.all(a_mat.dot(np.ones(self.dim_n))&gt;0), \"each row of A matrix should have at least one positive entry.\"\n  # for different charts, use different functions to evaluate\n  npts=logvar.shape[0]\n  assert logvar.shape[1]==self.dim_n, 'shape of logvar should be num_points-by-dim_n'\n  logders=np.empty((logvar.shape[0],self.dim_n,self.dim_n))\n  if chart=='x':\n    for i in range(npts):\n      logders[i]=self.logder_x_num(logvar[i],a_mat)\n    logx=logvar\n  elif chart=='xak':\n    assert self.is_atomic, 'the binding network is not atomic, cannot use xak chart'\n    logx=np.empty(logvar.shape)\n    for i in range(npts):\n      logders[i],logx[i]=self.logder_xak_num(logvar[i],a_mat)\n  elif chart=='tk':\n    logx=np.empty(logvar.shape)\n    for i in range(npts):\n      logders[i],logx[i]=self.logder_tk_num(logvar[i],a_mat)\n  else: \n    raise Exception('chart that is not one of \"x,xak,tk\" is not implemented yet')\n  return logders,logx\n</code></pre>"},{"location":"#bcn.binding_network.binding_network.logder_sym","title":"<code>logder_sym(a_mat=np.array([]), is_saved=True)</code>","text":"<p>Calculate the symbolic log derivative matrix of dlog(x)/dlog(a_mat @ x, k).</p> <p>Parameters:</p> Name Type Description Default <code>a_mat</code> <code>numpy array</code> <p>Matrix defining the variables log derivative is taken in terms of. Assumes all entries are non-negative, and each row has at least one positive entry. Optional, defaults to l_mat of the binding network.</p> <code>array([])</code> <code>is_saved</code> <code>bool</code> <p>To save the resulting logdermat as parameter ld_sym of the binding network or not. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <p>sympy.Matrix: Symbolic log derivative matrix for x to (t_sym_temp, k_sym) expressed in terms of x.</p> Note <p>If the provided a_mat yields a noninvertible matrix, then the function will return logdermat as a matrix of zeros (with the appropriate size).</p> Source code in <code>src/bcn/binding_network.py</code> <pre><code>def logder_sym(self,a_mat=np.array([]),is_saved=True):\n  \"\"\"\n  Calculate the symbolic log derivative matrix of dlog(x)/dlog(a_mat @ x, k).\n\n  Args:\n      a_mat (numpy array, optional): Matrix defining the variables log derivative is taken in terms of.\n          Assumes all entries are non-negative, and each row has at least one positive entry.\n          Optional, defaults to l_mat of the binding network.\n      is_saved (bool, optional): To save the resulting logdermat as parameter ld_sym of the binding network or not.\n          Defaults to True.\n\n  Returns:\n      sympy.Matrix: Symbolic log derivative matrix for x to (t_sym_temp, k_sym) expressed in terms of x.\n\n  Note:\n      If the provided a_mat yields a noninvertible matrix, then the function will return logdermat as a matrix of zeros (with the appropriate size).\n  \"\"\"\n  if not np.any(a_mat): # no a_mat argument is given\n    a_mat=self.l_mat\n  else:\n    assert a_mat.shape==(self.dim_d,self.dim_n), f\"the shape of L matrix should be {self.dim_d} by {self.dim_n}.\"\n    assert np.all(a_mat&gt;=0), \"all entries of A matrix should be non-negative.\"\n    assert np.all(a_mat.dot(np.ones(self.dim_n))&gt;0), \"each row of A matrix should have at least one positive entry.\"\n\n  a_mat_sym=sp.Matrix(a_mat)\n  n_mat_sym=self.n_mat_sym\n\n  #it's much faster (10x) to use a dummy \"total\" variables to calculate matrix inverse,\n  # and then substitute the expression for the totals in terms of x, rather than\n  # inverting with the totals explicitly expressed in x variables.\n\n  temp_sym = sp.symbols(\"t:\"+str(self.dim_d))\n\n  Lam_t = sp.Matrix.diag(*temp_sym)\n  Lam_x = sp.Matrix.diag(*self.x_sym)\n\n  topmat = Lam_t**-1 * a_mat_sym * Lam_x\n  fullmat = topmat.col_join(n_mat_sym)\n\n  logdermat_t = fullmat**-1\n\n  temp_expr=a_mat_sym*sp.Matrix(self.x_sym)\n  temp2x_subs_list=[(temp_sym[i],temp_expr[i]) for i in range(self.dim_d)]\n  logdermat=sp.simplify(logdermat_t.subs(temp2x_subs_list))\n\n  if is_saved: self.ld_sym_dict[a_mat.tobytes()]=logdermat\n  return logdermat\n</code></pre>"},{"location":"#bcn.binding_network.binding_network.logder_sym_activity","title":"<code>logder_sym_activity(b_vec_sym, a_mat=np.array([]))</code>","text":"<p>Compute the log derivative of a linear sum of x, i.e. dlog(b_vec_sym * x)/dlog(tp, k), where tp = a_mat * x.</p> <p>Parameters:</p> Name Type Description Default <code>b_vec_sym</code> <code>sympy symbolic vector</code> <p>A vector of symbolic expressions corresponding to coefficients to be summed. Shape is (n, 1).</p> required <code>a_mat</code> <code>numpy array</code> <p>The matrix denoting the variables a_mat * x that the log derivative is taken with respect to. Defaults to self.l_mat.</p> <code>array([])</code> <p>Returns:</p> Type Description <p>sympy vector: The symbolic log derivative dlog(b_vec_sym * x)/dlog(tp, k), where tp = a_mat * x.</p> Source code in <code>src/bcn/binding_network.py</code> <pre><code>def logder_sym_activity(self,b_vec_sym,a_mat=np.array([])):\n  \"\"\"\n  Compute the log derivative of a linear sum of x, i.e. dlog(b_vec_sym * x)/dlog(tp, k), where tp = a_mat * x.\n\n  Args:\n      b_vec_sym (sympy symbolic vector): A vector of symbolic expressions corresponding to coefficients to be summed. Shape is (n, 1).\n      a_mat (numpy array, optional): The matrix denoting the variables a_mat * x that the log derivative is taken with respect to.\n          Defaults to self.l_mat.\n\n  Returns:\n      sympy vector: The symbolic log derivative dlog(b_vec_sym * x)/dlog(tp, k), where tp = a_mat * x.\n  \"\"\"\n  if not np.any(a_mat): # no a_mat argument is given\n    a_mat=self.l_mat\n  # check if logder is already calculated with respect to this a_mat.\n  try: ld_sym=self.ld_sym_dict[a_mat.tobytes()]\n  except KeyError: # not calculated yet\n    print('Symbolic logder for this chart coordinate does not exist, calculating...')\n    ld_sym=self.logder_sym(a_mat=a_mat)\n  coeff_vec_sym=sp.Matrix(np.zeros(b_vec_sym.shape))\n  bx = sp.matrix_multiply_elementwise(b_vec_sym,sp.Matrix(self.x_sym)) #b multiply x element-wise\n  bx_sum = bx.T*sp.ones(*bx.shape)\n  coeff_vec_sym=bx*bx_sum**(-1) # convex coefficients for the log derivative sum\n  ld_sym_sum=(ld_sym.T*coeff_vec_sym).T # for logder matrix ld_sym, rows are species, columns are variables.\n  return ld_sym_sum\n</code></pre>"},{"location":"#bcn.binding_network.binding_network.logder_tk2x_num","title":"<code>logder_tk2x_num(logvar, chart='x', a_mat=np.array([]))</code>","text":"<p>Compute the numerical dlog(t, k)/dlog(x) log derivative of the binding network at points specified by logvar in the specified chart and dominance a_mat.</p> <p>Parameters:</p> Name Type Description Default <code>logvar</code> <code>ndarray</code> <p>Array of the points to evaluate the log derivatives at, in base-10 log. Shape is (n_points, dim_n). In chart 'x', for example, this is logx.</p> required <code>chart</code> <code>str</code> <p>Specifying the chart that logvar is specified in. Could be 'x', 'xak', or 'tk'.</p> <code>'x'</code> <code>a_mat</code> <code>numpy array</code> <p>Matrix defining the variables log derivative is taken in terms of. Assumes all entries are non-negative, and each row has at least one positive entry. Optional, defaults to l_mat of the binding network.</p> <code>array([])</code> <p>Returns:</p> Name Type Description <code>logder</code> <code>ndarray</code> <p>Array of n-by-n matrix of log derivative of (t, k) to x, where t = a_mat @ x, and n is the number of species. Shape is (n_points, dim_n, dim_n).</p> <code>logx</code> <code>ndarray</code> <p>Array of logx that the logvar points correspond to. Shape is (n_points, dim_n). This is returned since all input variables, regardless of chart, are mapped to the logx chart first. Returned for convenience.</p> Source code in <code>src/bcn/binding_network.py</code> <pre><code>def logder_tk2x_num(self,logvar,chart='x',a_mat=np.array([])):\n  \"\"\"\n  Compute the numerical dlog(t, k)/dlog(x) log derivative of the binding network at points specified by logvar in the specified chart and dominance a_mat.\n\n  Args:\n      logvar (ndarray): Array of the points to evaluate the log derivatives at, in base-10 log. Shape is (n_points, dim_n).\n          In chart 'x', for example, this is logx.\n      chart (str): Specifying the chart that logvar is specified in. Could be 'x', 'xak', or 'tk'.\n      a_mat (numpy array, optional): Matrix defining the variables log derivative is taken in terms of.\n          Assumes all entries are non-negative, and each row has at least one positive entry.\n          Optional, defaults to l_mat of the binding network.\n\n  Returns:\n      logder (ndarray): Array of n-by-n matrix of log derivative of (t, k) to x, where t = a_mat @ x, and n is the number of species.\n          Shape is (n_points, dim_n, dim_n).\n      logx (ndarray): Array of logx that the logvar points correspond to. Shape is (n_points, dim_n).\n          This is returned since all input variables, regardless of chart, are mapped to the logx chart first.\n          Returned for convenience.\n  \"\"\"\n  # first check a_mat makes sense.\n  if not np.any(a_mat): # no a_mat argument is given\n    a_mat=self.l_mat\n  else:\n    assert a_mat.shape==(self.dim_d,self.dim_n), f\"the shape of L matrix should be {self.dim_d} by {self.dim_n}.\"\n    assert np.all(a_mat&gt;=0), \"all entries of A matrix should be non-negative.\"\n    assert np.all(a_mat.dot(np.ones(self.dim_n))&gt;0), \"each row of A matrix should have at least one positive entry.\"\n  # for different charts, use different functions to evaluate\n  npts=logvar.shape[0]\n  assert logvar.shape[1]==self.dim_n, 'shape of logvar should be num_points-by-dim_n'\n  logders=np.empty((logvar.shape[0],self.dim_n,self.dim_n))\n  if chart=='x':\n    for i in range(npts):\n      logders[i]=self.logder_tk2x_x_num(logvar[i],a_mat)\n    logx=logvar\n  elif chart=='xak':\n    assert self.is_atomic, 'the binding network is not atomic, cannot use xak chart'\n    logx=np.empty(logvar.shape)\n    for i in range(npts):\n      logx[i]=self.xak2x_num(logvar[i])\n      logders[i]=self.logder_tk2x_x_num(logx[i],a_mat)\n  elif chart=='tk':\n    logx=np.empty(logvar.shape)\n    for i in range(npts):\n      logx[i]=self.tk2x_num(logvar[i],a_mat)\n      logders[i]=self.logder_tk2x_x_num(logvar[i],a_mat)\n  else: \n    raise Exception('chart that is not one of \"x,xak,tk\" is not implemented yet')\n  return logders,logx\n</code></pre>"},{"location":"#bcn.binding_network.binding_network.logder_tk2x_x_num","title":"<code>logder_tk2x_x_num(logx, a_mat)</code>","text":"<p>Compute the numerical dlog(t, k)/dlog(x) log derivative of the binding network at one point in chart x.</p> <p>Parameters:</p> Name Type Description Default <code>logx</code> <code>numpy vector</code> <p>Vector of concentrations for all the species in log, base-10.</p> required <code>a_mat</code> <code>numpy array</code> <p>Matrix defining the variables log derivative is taken in terms of. Assumes all entries are non-negative, and each row has at least one positive entry.</p> required <p>Returns:</p> Name Type Description <code>ndarray</code> <p>Array of n-by-n matrix of log derivative of (t, k) to x, where t = a_mat @ x, and n is the number of species. Shape is (n_points, dim_n, dim_n).</p> Source code in <code>src/bcn/binding_network.py</code> <pre><code>def logder_tk2x_x_num(self,logx,a_mat):\n  \"\"\"\n  Compute the numerical dlog(t, k)/dlog(x) log derivative of the binding network at one point in chart x.\n\n  Args:\n      logx (numpy vector): Vector of concentrations for all the species in log, base-10.\n      a_mat (numpy array): Matrix defining the variables log derivative is taken in terms of.\n          Assumes all entries are non-negative, and each row has at least one positive entry.\n\n  Returns:\n      ndarray: Array of n-by-n matrix of log derivative of (t, k) to x, where t = a_mat @ x, and n is the number of species.\n          Shape is (n_points, dim_n, dim_n).\n  \"\"\"\n  x=10**logx\n  t_inv = 1/(a_mat.dot(x))\n  temp=a_mat*x\n  upper=(temp.T*t_inv).T\n  logder=np.concatenate((upper,self.n_mat),axis=0)\n  return logder\n</code></pre>"},{"location":"#bcn.binding_network.binding_network.logder_tk_num","title":"<code>logder_tk_num(logtk, a_mat)</code>","text":"<p>Compute the numerical log derivative of dlog(x)/dlog(a_mat @ x, k) at a point specified by log(t, k), where t = a_mat @ x is the concentration of atomic species, and k is the binding constants. log is base 10.</p> <p>Parameters:</p> Name Type Description Default <code>logtk</code> <code>numpy vector</code> <p>Vector numerical value for total concentration (first dim_d entries) and binding reaction constants (last dim_r entries). Shape is (dim_n,). log is base 10.</p> required <code>a_mat</code> <code>numpy array</code> <p>Matrix defining the variables log derivative is taken in terms of. Assumes all entries are non-negative, and each row has at least one positive entry.</p> required <p>Returns:</p> Name Type Description <code>logder</code> <code>ndarray</code> <p>Array of n-by-n matrix of log derivative of x to (t, k), where t = a_mat @ x, and n is the number of species. Shape is (n_points, dim_n, dim_n).</p> <code>logx</code> <code>ndarray</code> <p>Array of logx that the logvar points correspond to. Shape is (n_points, dim_n). This is returned since all input variables, regardless of chart, are mapped to the logx chart first. Returned for convenience.</p> Source code in <code>src/bcn/binding_network.py</code> <pre><code>def logder_tk_num(self,logtk,a_mat):\n  \"\"\"\n  Compute the numerical log derivative of dlog(x)/dlog(a_mat @ x, k) at a point specified by log(t, k), where t = a_mat @ x is the concentration of atomic species, and k is the binding constants. log is base 10.\n\n  Args:\n      logtk (numpy vector): Vector numerical value for total concentration (first dim_d entries) and binding reaction constants (last dim_r entries). Shape is (dim_n,).\n          log is base 10.\n      a_mat (numpy array): Matrix defining the variables log derivative is taken in terms of.\n          Assumes all entries are non-negative, and each row has at least one positive entry.\n\n  Returns:\n      logder (ndarray): Array of n-by-n matrix of log derivative of x to (t, k), where t = a_mat @ x, and n is the number of species.\n          Shape is (n_points, dim_n, dim_n).\n      logx (ndarray): Array of logx that the logvar points correspond to. Shape is (n_points, dim_n).\n          This is returned since all input variables, regardless of chart, are mapped to the logx chart first.\n          Returned for convenience.\n  \"\"\"\n  logx=self.tk2x_num(logtk,a_mat)\n  return self.logder_x_num(logx,a_mat),logx\n</code></pre>"},{"location":"#bcn.binding_network.binding_network.logder_x_num","title":"<code>logder_x_num(logx, a_mat)</code>","text":"<p>Compute the numerical log derivative of the binding network at one point in chart x.</p> <p>Parameters:</p> Name Type Description Default <code>logx</code> <code>numpy vector</code> <p>Vector of concentrations for all the species in log, base-10.</p> required <code>a_mat</code> <code>numpy array</code> <p>Matrix defining the variables log derivative is taken in terms of. Assumes all entries are non-negative, and each row has at least one positive entry.</p> required <p>Returns:</p> Name Type Description <code>ndarray</code> <p>Array of n-by-n matrix of log derivative of x to (t, k), where t = a_mat @ x, and n is the number of species. Shape is (n_points, dim_n, dim_n).</p> Source code in <code>src/bcn/binding_network.py</code> <pre><code>def logder_x_num(self,logx,a_mat):\n  \"\"\"\n  Compute the numerical log derivative of the binding network at one point in chart x.\n\n  Args:\n      logx (numpy vector): Vector of concentrations for all the species in log, base-10.\n      a_mat (numpy array): Matrix defining the variables log derivative is taken in terms of.\n          Assumes all entries are non-negative, and each row has at least one positive entry.\n\n  Returns:\n      ndarray: Array of n-by-n matrix of log derivative of x to (t, k), where t = a_mat @ x, and n is the number of species.\n          Shape is (n_points, dim_n, dim_n).\n  \"\"\"\n  x=10**logx\n  t_inv = 1/(a_mat.dot(x))\n  temp=a_mat*x\n  upper=(temp.T*t_inv).T\n  logder_inv=np.concatenate((upper,self.n_mat),axis=0)\n  try:\n    np.linalg.inv(logder_inv)\n  except:\n    print(x)\n    print(t_inv)\n    print(logder_inv)\n\n  return np.linalg.inv(logder_inv)\n</code></pre>"},{"location":"#bcn.binding_network.binding_network.logder_xak_num","title":"<code>logder_xak_num(logxak, a_mat)</code>","text":"<p>Compute the numerical log derivative of dlog(x)/dlog(a_mat * x, k) at a point specified by log(xa, k), where xa is the concentration of atomic species, and k is the binding constants. log is base 10.     Assumes the network is atomic, and n_mat, a_mat have atomic species coming first.</p> <p>Parameters:</p> Name Type Description Default <code>logxak</code> <code>numpy vector</code> <p>Vector numerical value for atomic species concentration (first dim_d entries) and binding reaction constants (last dim_r entries). Shape is (dim_n,). log is base 10.</p> required <code>a_mat</code> <code>numpy array</code> <p>Matrix defining the variables log derivative is taken in terms of. Assumes all entries are non-negative, and each row has at least one positive entry.</p> required <p>Returns:</p> Name Type Description <code>logder</code> <code>ndarray</code> <p>Array of n-by-n matrix of log derivative of x to (t, k), where t = a_mat @ x, and n is the number of species. Shape is (n_points, dim_n, dim_n).</p> <code>logx</code> <code>ndarray</code> <p>Array of logx that the logvar points correspond to. Shape is (n_points, dim_n). This is returned since all input variables, regardless of chart, are mapped to the logx chart first. Returned for convenience.</p> Source code in <code>src/bcn/binding_network.py</code> <pre><code>def logder_xak_num(self,logxak,a_mat):\n  \"\"\"\n  Compute the numerical log derivative of dlog(x)/dlog(a_mat * x, k) at a point specified by log(xa, k), where xa is the concentration of atomic species, and k is the binding constants. log is base 10.\n      Assumes the network is atomic, and n_mat, a_mat have atomic species coming first.\n\n  Args:\n      logxak (numpy vector): Vector numerical value for atomic species concentration (first dim_d entries) and binding reaction constants (last dim_r entries). Shape is (dim_n,).\n          log is base 10.\n      a_mat (numpy array): Matrix defining the variables log derivative is taken in terms of.\n          Assumes all entries are non-negative, and each row has at least one positive entry.\n\n  Returns:\n      logder (ndarray): Array of n-by-n matrix of log derivative of x to (t, k), where t = a_mat @ x, and n is the number of species.\n          Shape is (n_points, dim_n, dim_n).\n      logx (ndarray): Array of logx that the logvar points correspond to. Shape is (n_points, dim_n).\n          This is returned since all input variables, regardless of chart, are mapped to the logx chart first.\n          Returned for convenience.\n  \"\"\"\n  ## commented out are old code that directly calculate logx, now we use stored map.\n  # d=self.dim_d\n  # logxa=logxak[:d]\n  # logk=logxak[d:]\n  # temp1=(a_mat.T).dot(logxa)\n  # n2_mat=self.n_mat[:,d:]\n  # temp2=np.linalg.inv(n2_mat).dot(logk)\n  # logx=temp1 + np.pad(temp2,(d,0),mode='constant',constant_values=(0,0))\n\n  logx=self.xak2x_num(logxak)\n  return self.logder_x_num(logx,a_mat),logx\n</code></pre>"},{"location":"#bcn.binding_network.binding_network.sampling_over_activity_regime_hull","title":"<code>sampling_over_activity_regime_hull(nsample, b_tuple, regime_key_list=[], is_finite_only=False, is_feasible_only=False, chart='x', logmin=-6, logmax=6, margin=0, c_mat_extra=[], c0_vec_extra=[])</code>","text":"<p>Randomly sample points in the log space of chart variables for each dom_regime for a given activity, but instead of log-uniform, we first assign points to each vertex in an even fashion, then sample uniformly within each vertex.</p> <p>Parameters:</p> Name Type Description Default <code>nsample</code> <code>int</code> <p>The number of points to be sampled in the space of chart variables. This is divided evenly to all the vertices of this binding network.</p> required <code>b_tuple</code> <code>tuple of length dim_n</code> <p>The b_tuple indicating the activity whose dom_regimes we are interested in sampling.</p> required <code>is_finite_only</code> <code>bool</code> <p>If True, only finite dom_regimes are sampled. If False, both finite and infinite dom_regimes are sampled. Defaults to False.</p> <code>False</code> <code>regime_key_list</code> <code>list of dominance regime's keys</code> <p>The list of keys for dom_regimes indexing the dom_regimes to be sampled. e.g. [((0,1,2),7), ((0,1,3),7)]. If empty, sample all dom_regimes. Defaults to empty list [].</p> <code>[]</code> <code>is_feasible_only</code> <code>bool</code> <p>If True, only feasible dom_regimes are sampled. If False, all dom_regimes in regime_key_list (or all in this activity) are sampled. Each dom_regime's is_feasible tag comes from results of the most recent feasibility test.</p> <code>False</code> <code>chart</code> <code>str</code> <p>A string indicating the chart that the opt_constraints are specified in. Choices are 'x', 'xak', and 'tk'. Defaults to 'x'.</p> <code>'x'</code> <code>margin</code> <code>float</code> <p>The vertex's feasibility conditions are inequalities, of the form c_mat * logx + c0_vec &gt; margin (e.g. in 'x' chart), where margin is the positive threshold used here. Defaults to 0. This can be adjusted to be stronger/weaker requirements on dominance.</p> <code>0</code> <code>logmin</code> <code>float or ndarray vector</code> <p>logmin, logmax could be scalars, then it's the same value applied to every variable. They could also be vectors of length dim_n.</p> <code>-6</code> <code>logmax</code> <code>float or ndarray vector</code> <p>logmin, logmax could be scalars, then it's the same value applied to every variable. They could also be vectors of length dim_n.</p> <code>6</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary of ndarray with shape (nsample, dim_n). Key is the perm of each vertex. Value is the sample for that vertex.</p> Source code in <code>src/bcn/binding_network.py</code> <pre><code>def sampling_over_activity_regime_hull(self,nsample,b_tuple,regime_key_list=[],is_finite_only=False,is_feasible_only=False,chart='x',logmin=-6,logmax=6,margin=0,c_mat_extra=[],c0_vec_extra=[]):\n  \"\"\"\n  Randomly sample points in the log space of chart variables for each dom_regime for a given activity, but instead of log-uniform, we first assign points to each vertex in an even fashion, then sample uniformly within each vertex.\n\n  Args:\n      nsample (int): The number of points to be sampled in the space of chart variables.\n          This is divided evenly to all the vertices of this binding network.\n      b_tuple (tuple of length dim_n): The b_tuple indicating the activity whose dom_regimes we are interested in sampling.\n      is_finite_only (bool, optional): If True, only finite dom_regimes are sampled.\n          If False, both finite and infinite dom_regimes are sampled. Defaults to False.\n      regime_key_list (list of dominance regime's keys, optional): The list of keys for dom_regimes indexing the dom_regimes to be sampled.\n          e.g. [((0,1,2),7), ((0,1,3),7)]. If empty, sample all dom_regimes. Defaults to empty list [].\n      is_feasible_only (bool, optional): If True, only feasible dom_regimes are sampled.\n          If False, all dom_regimes in regime_key_list (or all in this activity) are sampled.\n          Each dom_regime's is_feasible tag comes from results of the most recent feasibility test.\n      chart (str, optional): A string indicating the chart that the opt_constraints are specified in.\n          Choices are 'x', 'xak', and 'tk'. Defaults to 'x'.\n      margin (float, optional): The vertex's feasibility conditions are inequalities,\n          of the form c_mat * logx + c0_vec &gt; margin (e.g. in 'x' chart),\n          where margin is the positive threshold used here. Defaults to 0.\n          This can be adjusted to be stronger/weaker requirements on dominance.\n      logmin (float or ndarray vector): logmin, logmax could be scalars, then it's the same value applied to every variable.\n          They could also be vectors of length dim_n.\n      logmax (float or ndarray vector): logmin, logmax could be scalars, then it's the same value applied to every variable.\n          They could also be vectors of length dim_n.\n\n  Returns:\n      dict: A dictionary of ndarray with shape (nsample, dim_n).\n          Key is the perm of each vertex. Value is the sample for that vertex.\n  \"\"\"\n  pass\n</code></pre>"},{"location":"#bcn.binding_network.binding_network.sampling_over_vertex_hull","title":"<code>sampling_over_vertex_hull(nsample, vertex_perm_list=[], is_finite_only=False, chart='x', logmin=-6, logmax=6, margin=0, c_mat_extra=[], c0_vec_extra=[])</code>","text":"<p>Randomly sample points in the log space of chart variables, but instead of log-uniform, we first assign points to each vertex in an even fashion, then sample uniformly within each vertex.</p> <p>Parameters:</p> Name Type Description Default <code>nsample</code> <code>int</code> <p>The number of points to be sampled in the space of chart variables. This is divided evenly to all the vertices of this binding network.</p> required <code>is_finite_only</code> <code>bool</code> <p>Useful only when vertex_perm_list=[], so that all vertices are sampled. If True, only finite vertices are sampled. This also allows chart 'tk' to work. If False, both finite and infinite vertices are sampled. Defaults to False.</p> <code>False</code> <code>vertex_perm_list</code> <code>list of vertex's perm tuples</code> <p>The list of perms indexing the vertices to be sampled. e.g. [(0,1,2), (0,1,3)]. Defaults to empty list []. If empty, sample all vertices.</p> <code>[]</code> <code>chart</code> <code>str</code> <p>A string indicating the chart that the opt_constraints are specified in. Choices are 'x', 'xak', and 'tk'. Defaults to 'x'.</p> <code>'x'</code> <code>margin</code> <code>float</code> <p>The vertex's feasibility conditions are inequalities, of the form c_mat * logx + c0_vec &gt; margin (e.g. in 'x' chart), where margin is the positive threshold used here. Defaults to 0. This can be adjusted to be stronger/weaker requirements on dominance.</p> <code>0</code> <code>logmin</code> <code>float or ndarray vector</code> <p>logmin, logmax could be scalars, then it's the same value applied to every variable. They could also be vectors of length dim_n.</p> <code>-6</code> <code>logmax</code> <code>float or ndarray vector</code> <p>logmin, logmax could be scalars, then it's the same value applied to every variable. They could also be vectors of length dim_n.</p> <code>6</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary of ndarray with shape (nsample, dim_n). Key is the perm of each vertex. Value is the sample for that vertex.</p> Source code in <code>src/bcn/binding_network.py</code> <pre><code>def sampling_over_vertex_hull(self,nsample,vertex_perm_list=[],is_finite_only=False, chart='x',logmin=-6,logmax=6,margin=0,c_mat_extra=[],c0_vec_extra=[]):\n  \"\"\"\n  Randomly sample points in the log space of chart variables, but instead of log-uniform, we first assign points to each vertex in an even fashion, then sample uniformly within each vertex.\n\n  Args:\n      nsample (int): The number of points to be sampled in the space of chart variables.\n          This is divided evenly to all the vertices of this binding network.\n      is_finite_only (bool, optional): Useful only when vertex_perm_list=[], so that all vertices are sampled.\n          If True, only finite vertices are sampled. This also allows chart 'tk' to work.\n          If False, both finite and infinite vertices are sampled. Defaults to False.\n      vertex_perm_list (list of vertex's perm tuples, optional): The list of perms indexing the vertices to be sampled.\n          e.g. [(0,1,2), (0,1,3)]. Defaults to empty list []. If empty, sample all vertices.\n      chart (str, optional): A string indicating the chart that the opt_constraints are specified in.\n          Choices are 'x', 'xak', and 'tk'. Defaults to 'x'.\n      margin (float, optional): The vertex's feasibility conditions are inequalities,\n          of the form c_mat * logx + c0_vec &gt; margin (e.g. in 'x' chart),\n          where margin is the positive threshold used here. Defaults to 0.\n          This can be adjusted to be stronger/weaker requirements on dominance.\n      logmin (float or ndarray vector): logmin, logmax could be scalars, then it's the same value applied to every variable.\n          They could also be vectors of length dim_n.\n      logmax (float or ndarray vector): logmin, logmax could be scalars, then it's the same value applied to every variable.\n          They could also be vectors of length dim_n.\n\n  Returns:\n      dict: A dictionary of ndarray with shape (nsample, dim_n).\n          Key is the perm of each vertex. Value is the sample for that vertex.\n  \"\"\"\n\n  # calculate number of vertex to be plotted and the dictionary of vertices.\n  vertex_plot_dict={}\n  if vertex_perm_list: # vertex_perm_list is not empty\n    nvertex=len(vertex_perm_list)\n    for perm in vertex_perm_list:\n      vertex_plot_dict[perm]=self.vertex_dict['all'][perm]\n  else: # plot all vertices\n    if is_finite_only: \n      finite_key='finite'\n    else: \n      finite_key='all'\n    nvertex=len(self.vertex_dict[finite_key].keys())\n    vertex_plot_dict=self.vertex_dict[finite_key]\n  # now sample each vertex.\n  nsample_per_vertex=int(nsample/nvertex) # take the floor for number of sample per vertex\n  sample_vertex_dict={}\n  for key,vv in vertex_plot_dict.items():\n    print(key)\n    sample_vertex_dict[key]=vv.vertex_hull_sampling(nsample_per_vertex,chart=chart,margin=margin,logmin=logmin,logmax=logmax,c_mat_extra=c_mat_extra,c0_vec_extra=c0_vec_extra)\n  return sample_vertex_dict\n</code></pre>"},{"location":"#bcn.binding_network.binding_network.t2x_sym","title":"<code>t2x_sym(expr)</code>","text":"<p>Input a symbolic expression containing totals t, and map it to x.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>sympy symbolic expression</code> <p>A symbolic expression to be converted.</p> required <p>Returns:</p> Type Description <p>sympy symbolic expression: The symbolic expression after conversion.</p> Source code in <code>src/bcn/binding_network.py</code> <pre><code>def t2x_sym(self,expr):\n  \"\"\"\n  Input a symbolic expression containing totals t, and map it to x.\n\n  Args:\n      expr (sympy symbolic expression): A symbolic expression to be converted.\n\n  Returns:\n      sympy symbolic expression: The symbolic expression after conversion.\n  \"\"\"\n  # calculate the substitutions map for totals to species\n  try: expr_x=expr.subs(self.t2x)\n  except AttributeError:\n    t2x_subs_list=self.subs_list_t2x()\n    self.t2x=t2x_subs_list\n    expr_x=expr.subs(self.t2x)\n  return expr_x\n</code></pre>"},{"location":"#bcn.binding_network.binding_network.tk2x_num","title":"<code>tk2x_num(logtk, a_mat)</code>","text":"<p>Compute the logx value by numerical integration along the equilibrium manifold using log derivatives. The point on the manifold defined by logtk = (logt, logk) is the same as that defined by logx.</p> <p>Parameters:</p> Name Type Description Default <code>logtk</code> <code>numpy vector</code> <p>Vector numerical value for total variables (in first dim_d entries) and the binding reaction constants (in last dim_r entries) that define the point.  p_(logx) = p_(logt, logk). Shape is (dim_n,). log is base 10.</p> required <code>a_mat</code> <code>numpy array</code> <p>The matrix defining the total variables t = a_mat @ x that the log derivatives are taken with respect to. Default should be specified to be self.l_mat.</p> required <p>Returns:</p> Type Description <p>numpy vector: The numerical value of x at this point. log is base 10.</p> Source code in <code>src/bcn/binding_network.py</code> <pre><code>def tk2x_num(self,logtk,a_mat):\n  \"\"\"\n  Compute the logx value by numerical integration along the equilibrium manifold using log derivatives. The point on the manifold defined by logtk = (logt, logk) is the same as that defined by logx.\n\n  Args:\n      logtk (numpy vector): Vector numerical value for total variables (in first dim_d entries) and the binding reaction constants (in last dim_r entries) that define the point. \n          p_(logx) = p_(logt, logk). Shape is (dim_n,). log is base 10.\n      a_mat (numpy array): The matrix defining the total variables t = a_mat @ x that the log derivatives are taken with respect to.\n          Default should be specified to be self.l_mat.\n\n  Returns:\n      numpy vector: The numerical value of x at this point. log is base 10.\n  \"\"\"\n\n  # the initial point is always x=1, (t,k) = (A*1, 1)\n  # or, in log, logx=0, (logt,logk) = (log(A*1),0)\n\n  logt0=np.log10(np.sum(a_mat,axis=1))\n  logk0=np.zeros(self.dim_r)\n  y0=np.concatenate((logt0,logk0),axis=0)\n  y1=logtk\n  logx0=np.zeros(self.dim_n)\n  # The time is pseudo time, parameterizing trajectory from y0 to y1,\n  # where y0=(logt0,logk0) = (log(A*1),0), and y1=(logt,logk) the input.\n  # So a point on the trajectory is gamma(tau) = tau*(y1-y0)+y0, 0&lt;=tau&lt;=1.\n  # The time derivative is therefore\n  # dlogx/dtau (x0) = dlogx/dlog(t,k) (x0) * dlog(t,k)/dtau (x0)\n  #                 = dlogx/dlog(t,k) (x0) * (y1-y0)\n  # dlogx/dlog(t,k) (x0) is log derivative matrix evaluated at x0.\n  time_derivative_func=lambda tau,logx: self.logder_x_num(logx,a_mat).dot(y1-y0)\n  sol=solve_ivp(time_derivative_func, [0, 1], logx0)\n  logx=sol.y[:,-1]\n  return logx\n</code></pre>"},{"location":"#bcn.binding_network.binding_network.vertex_constrained_construct","title":"<code>vertex_constrained_construct(opt_constraints, chart='xak')</code>","text":"<p>Assuming self.vertex_dict is already computed, for given opt_constraints, this function computes whether the vertices are feasible under these constraints, updates rop_vertex.is_feasible for each vertex, and updates each vertex's feasible neighbors (stored in vertex.neighbors_constrained_dict). It returns is_feasible_dict, a dictionary of {perm: is_feasible} pairs. This function calls vertex_list_feasibility_test.</p> <p>Parameters:</p> Name Type Description Default <code>opt_constraints</code> <code>list of cvxpy inequalities</code> <p>List of constraints under which vertices are tested for feasibility.</p> required <code>chart</code> <code>str</code> <p>A string with value from {'x', 'xak', 'tk'} that specifies the chart that the opt_constraints are described in. Defaults to None.</p> <code>'xak'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary of {perm: is_feasible} pairs indicating whether a vertex is feasible.</p> Source code in <code>src/bcn/binding_network.py</code> <pre><code>def vertex_constrained_construct(self,opt_constraints,chart='xak'):\n  \"\"\"\n  Assuming self.vertex_dict is already computed, for given opt_constraints, this function computes whether the vertices are feasible under these constraints, updates rop_vertex.is_feasible for each vertex, and updates each vertex's feasible neighbors (stored in vertex.neighbors_constrained_dict). It returns is_feasible_dict, a dictionary of {perm: is_feasible} pairs.\n  This function calls vertex_list_feasibility_test.\n\n  Args:\n      opt_constraints (list of cvxpy inequalities): List of constraints under which vertices are tested for feasibility.\n      chart (str, optional): A string with value from {'x', 'xak', 'tk'} that specifies the chart that the opt_constraints are described in. Defaults to None.\n\n  Returns:\n      dict: A dictionary of {perm: is_feasible} pairs indicating whether a vertex is feasible.\n  \"\"\"\n  # for the given opt_constraints, test for each vertex whether it is feasible\n  # under opt_constraints, and create a vertex dictionary for feasible vertices\n  # under opt_constraints, stored in self.vertex_constrained_dict.\n  # Also update each vertex's neighbors under constraints,\n  # stored in each vertex.neighbors_constrained_dict.\n\n  print('Compute feasible vertices...')\n  for perm,vv in self.vertex_dict['all'].items():\n    is_feasible=vv.vertex_feasibility_test(chart=chart,opt_constraints=opt_constraints)\n    vv.is_feasible=is_feasible\n  vertex_feasible_all={perm:vv for perm,vv in self.vertex_dict['all'].items() if vv.is_feasible}\n  vertex_feasible_fin={perm:vv for perm,vv in self.vertex_dict['finite'].items() if vv.is_feasible}\n  vertex_feasible_inf={perm:vv for perm,vv in self.vertex_dict['infinite'].items() if vv.is_feasible}\n  self.vertex_constrained_dict={'all':vertex_feasible_all,'finite':vertex_feasible_fin,'infinite':vertex_feasible_inf}\n\n  print('Compute neighbors under opt_constraints...')\n  for perm,vv in self.vertex_dict['all'].items():\n    if vv.is_feasible:\n      # if it is feasible, we want to look at its neighbors.\n      # if a neighbor is feasible, it is still a neighbor under constraint.\n      # if a neighbor is infeasible, we look at its neighbors to see whether\n      # they are feasible. This recurses.\n      vv.vertex_update_constrained_neighbors()\n  print('Done.')\n</code></pre>"},{"location":"#bcn.binding_network.binding_network.vertex_construct","title":"<code>vertex_construct()</code>","text":"<p>Construct the rop_vertex objects that this binding network can have, compute their orientation and feasibility (without additional constraints), and store them in self.vertex_dict. Then the vertices' neighbors, log derivative, and c_mat_xak are computed and stored in these objects.</p> <p>Returns:</p> Type Description <p>None. The vertices are recorded in self.vertex_dict and by updating the vertex objects.</p> Source code in <code>src/bcn/binding_network.py</code> <pre><code>  def vertex_construct(self):\n    \"\"\"\n    Construct the rop_vertex objects that this binding network can have, compute their orientation and feasibility (without additional constraints), and store them in self.vertex_dict.\n    Then the vertices' neighbors, log derivative, and c_mat_xak are computed and stored in these objects.\n\n    Args:\n        None.\n\n    Returns:\n        None. The vertices are recorded in self.vertex_dict and by updating the vertex objects.\n\"\"\"\n    # Construct a dictionary of reachable vertices.\n    # because l_mat tends to be sparse, we iterate through its rows to get nonzero indices,\n    # then each vertex's dominance condition a_mat is choosen from the nonezro indices.\n\n    print('Constructing vertex objects and test for feasibility...')\n    d,n=self.l_mat.shape\n    orientation=self.orientation\n    nnz_list=[]\n    for i in range(d):\n      nnz_list=nnz_list+[np.nonzero(self.l_mat[i,:])[0]]\n    vertex_inf_dict={}\n    vertex_fin_dict={}\n    for perm in itertools.product(*nnz_list):\n      vertex=rop_vertex(perm,self)\n      if vertex.orientation==0:\n        # this is possibly an infinite vertex\n        # check for rank =1, meaning perm has exactly one repeat\n        perm_count=[perm.count(perm[i]) for i in range(d)]\n        if max(perm_count)==2:\n          if perm_count.count(2)==2: # because that same value shows up twice, each with count 2.\n            # after all that check, there still can be infinite vertices that are not reachable\n            # so we do feasibility test.\n            is_feasible=vertex.vertex_feasibility_test(chart='x',opt_constraints=[])\n            # and then add to vertex_inf_dict.\n            if is_feasible:\n              vertex_inf_dict[perm]=vertex\n      elif vertex.orientation==orientation:\n        # this is a finite vertex with the right orientation\n        # we test for feasibility\n        is_feasible=vertex.vertex_feasibility_test(chart='x',opt_constraints=[])\n        # and then add to vertex_fin_dict.\n        if is_feasible:\n          vertex_fin_dict[perm]=vertex\n    vertex_dict={**vertex_fin_dict,**vertex_inf_dict}\n    self.vertex_dict={'all':vertex_dict,'finite':vertex_fin_dict,'infinite':vertex_inf_dict}\n\n    print('Finished vertex construction, now computing neighbors of vertices...')\n    for perm,vv in vertex_dict.items():\n      vv.vertex_find_neighbors()\n\n    print('Finished neighbors, now computing log derivatives...')\n    # first compute log der for finite vertices, since infinite ones rely on\n    # finite neighbors to find orientation.\n    for perm,vv in vertex_dict.items():\n      vv.vertex_ld_calc()\n\n    print('Finished log derivatives, now computing c_mat_xak')\n    # compute c_mat_xak for each vertex in preparation for feasibility tests.\n    for perm,vv in vertex_dict.items():\n      vv.vertex_c_mat_xak_calc()\n    print('Done.')\n</code></pre>"},{"location":"#bcn.binding_network.binding_network.vertex_construct_direct","title":"<code>vertex_construct_direct()</code>","text":"<p>Construct the rop_vertex objects that this binding network can have, directly, without feasibility test.</p> <p>Returns:</p> Type Description <p>None. The vertices are recorded in self.vertex_dict and by updating the vertex objects.</p> Source code in <code>src/bcn/binding_network.py</code> <pre><code>def vertex_construct_direct(self):\n  \"\"\"\n  Construct the rop_vertex objects that this binding network can have, directly, without feasibility test.\n\n  Args:\n      None.\n\n  Returns:\n      None. The vertices are recorded in self.vertex_dict and by updating the vertex objects.\n  \"\"\"\n  # We construct the vertices by iteratively construct all the possible\n  # dominance vector (perm).\n  print('Constructing vertex objects DIRECTLY...')\n  a_mat=self.l_mat\n  d,n=a_mat.shape\n  not_dominated_col_idx=list(range(n))\n  dominated_row_vec_prev=np.zeros(d)\n  dom_tuple_prev=tuple(np.empty(d,dtype=int))\n  perm_dict=self.__get_dom_vec(a_mat,not_dominated_col_idx,dominated_row_vec_prev,dom_tuple_prev)\n  vertex_fin_dict={}\n  vertex_inf_dict={}\n  vertex_infHO_dict={}\n  for perm in perm_dict.keys():\n    vertex=rop_vertex(perm,self)\n    repeat_vec=np.sum(vertex.p_mat,axis=0)\n    if vertex.orientation!=0:\n      vertex_fin_dict[perm]=vertex\n    # elif np.max(repeat_vec)&gt;2 or np.sum(repeat_vec&gt;1) &gt;=2:\n      # there is an index repeated 3 or more times, OR there are more than two indices repeated twice or above;\n      # So this is an infinite vertex of higher order.\n    elif np.sum(repeat_vec[np.where(repeat_vec&gt;1)[0]])&gt;2:\n      # another way to test for higher order is the sum of repeated indices' total repeated times is &gt;2.\n      vertex_infHO_dict[perm]=vertex\n    else: #infinite vertex of order one\n      vertex_inf_dict[perm]=vertex\n  vertex_dict={**vertex_fin_dict,**vertex_inf_dict}\n  self.vertex_dict={'all':vertex_dict,'finite':vertex_fin_dict,'infinite':vertex_inf_dict,'infiniteHO':vertex_infHO_dict}\n\n  print('Finished vertex construction, now computing neighbors of vertices...')\n  for perm,vv in vertex_dict.items():\n    vv.vertex_find_neighbors()\n\n  print('Finished neighbors, now computing log derivatives...')\n  # first compute log der for finite vertices, since infinite ones rely on\n  # finite neighbors to find orientation.\n  for perm,vv in vertex_dict.items():\n    vv.vertex_ld_calc()\n\n  print('Finished log derivatives, now computing c_mat_xak')\n  # compute c_mat_xak for each vertex in preparation for feasibility tests.\n  for perm,vv in vertex_dict.items():\n    vv.vertex_c_mat_xak_calc()\n  print('Done.')\n</code></pre>"},{"location":"#bcn.binding_network.binding_network.vertex_list_feasibility_test","title":"<code>vertex_list_feasibility_test(opt_constraints, chart='xak')</code>","text":"<p>Given opt_constraints, test all the vertices for their feasibility and return is_feasible_dict. This function is called by vertex_constrained_construct. It can also be directly called to test for feasibility without storing or finding feasible neighbors.</p> <p>Parameters:</p> Name Type Description Default <code>opt_constraints</code> <code>list of cvxpy inequalities</code> <p>List of constraints under which vertices are tested for feasibility.</p> required <code>chart</code> <code>str</code> <p>A string with value from {'x', 'xak', 'tk'} that specifies the chart that the opt_constraints are described in. Defaults to None.</p> <code>'xak'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary of {perm: is_feasible} pairs indicating whether a vertex is feasible.</p> Source code in <code>src/bcn/binding_network.py</code> <pre><code>def vertex_list_feasibility_test(self,opt_constraints,chart='xak'):\n  \"\"\"\n  Given opt_constraints, test all the vertices for their feasibility and return is_feasible_dict.\n  This function is called by vertex_constrained_construct.\n  It can also be directly called to test for feasibility without storing or finding feasible neighbors.\n\n  Args:\n      opt_constraints (list of cvxpy inequalities): List of constraints under which vertices are tested for feasibility.\n      chart (str, optional): A string with value from {'x', 'xak', 'tk'} that specifies the chart that the opt_constraints are described in. Defaults to None.\n\n  Returns:\n      dict: A dictionary of {perm: is_feasible} pairs indicating whether a vertex is feasible.\n  \"\"\"\n  # for the given opt_constraints, test each of the vertex whether it is feasible\n  is_feasible_fin={}\n  is_feasible_inf={}\n  for perm,vv in self.vertex_dict['finite'].items():\n    is_feasible=vv.vertex_feasibility_test(chart=chart,opt_constraints=opt_constraints)\n    is_feasible_fin[perm]=is_feasible\n  for perm,vv in self.vertex_dict['infinite'].items():\n    is_feasible=vv.vertex_feasibility_test(chart=chart,opt_constraints=opt_constraints)\n    is_feasible_inf[perm]=is_feasible\n\n  is_feasible_all={**is_feasible_fin,**is_feasible_inf}\n  is_feasible_dict={'all':is_feasible_all,'finite':is_feasible_fin,'infinite':is_feasible_inf}\n  return is_feasible_dict\n</code></pre>"},{"location":"#bcn.binding_network.binding_network.x2tk_num","title":"<code>x2tk_num(logx)</code>","text":"<p>Compute the (logt, logk) value given logx.</p> <p>Parameters:</p> Name Type Description Default <code>logx</code> <code>numpy vector</code> <p>Vector numerical value for total variables that define the x point.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing two numpy vectors: - logt: The numerical value of total concentration at this point. log is base 10. - logk: The numerical value of binding constants at this point. log is base 10.</p> Source code in <code>src/bcn/binding_network.py</code> <pre><code>def x2tk_num(self,logx):\n  \"\"\"\n  Compute the (logt, logk) value given logx.\n\n  Args:\n      logx (numpy vector): Vector numerical value for total variables that define the x point.\n\n  Returns:\n      tuple: A tuple containing two numpy vectors:\n          - logt: The numerical value of total concentration at this point. log is base 10.\n          - logk: The numerical value of binding constants at this point. log is base 10.\n  \"\"\"\n  logt=np.log10(self.l_mat.dot(10**logx))\n  logk=self.n_mat.dot(logx)\n  return logt,logk\n</code></pre>"},{"location":"#bcn.binding_network.binding_network.xak2x_num","title":"<code>xak2x_num(logxak)</code>","text":"<p>Compute the logx value given logxak = (logxa, logk).</p> <p>Parameters:</p> Name Type Description Default <code>logxak</code> <code>numpy vector</code> <p>Vector numerical value for atomic species concentration (first dim_d entries) and binding reaction constants (last dim_r entries). Shape is (dim_n,). log is base 10.</p> required <p>Returns:</p> Type Description <p>numpy vector: The numerical value of logx at this point.</p> Source code in <code>src/bcn/binding_network.py</code> <pre><code>def xak2x_num(self,logxak):\n  \"\"\"\n  Compute the logx value given logxak = (logxa, logk).\n\n  Args:\n      logxak (numpy vector): Vector numerical value for atomic species concentration (first dim_d entries) and binding reaction constants (last dim_r entries). Shape is (dim_n,).\n          log is base 10.\n\n  Returns:\n      numpy vector: The numerical value of logx at this point.\n  \"\"\"\n  try: xak2x_map=self.xak2x_map\n  except AttributeError:\n    self.calc_xak2x_map() # if doesn't exist, calculate it\n    xak2x_map=self.xak2x_map\n  return xak2x_map.dot(logxak)\n</code></pre>"},{"location":"#bcn.binding_network.binding_network.xc2xak_sym","title":"<code>xc2xak_sym(expr)</code>","text":"<p>Input a symbolic expression containing complex species x^c, and map it to x^a and k.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>sympy symbolic expression</code> <p>A symbolic expression to be converted.</p> required <p>Returns:</p> Type Description <p>sympy symbolic expression: The symbolic expression after conversion.</p> Source code in <code>src/bcn/binding_network.py</code> <pre><code>def xc2xak_sym(self,expr):\n  \"\"\"\n  Input a symbolic expression containing complex species x^c, and map it to x^a and k.\n\n  Args:\n      expr (sympy symbolic expression): A symbolic expression to be converted.\n\n  Returns:\n      sympy symbolic expression: The symbolic expression after conversion.\n  \"\"\"\n  assert self.is_atomic, \"this operation requires the binding network to be atomic\"\n  # calculate the substitutions map for complex species to atomic species and k's, if it does not exist.\n  try: expr_xak=expr.subs(self.xc2xak)\n  except AttributeError:\n    xc2xak_subs_list=self.subs_list_xc2xak()\n    self.xc2xak=xc2xak_subs_list\n    expr_xak=expr.subs(self.xc2xak)\n  return expr_xak\n</code></pre>"},{"location":"#bcn.binding_network.rop_dom_regime","title":"<code>rop_dom_regime</code>","text":"<p>A dominance regime (dom_regime) object for a catalytic activity on top of a given binding network defined by b^T x, for some b vector.   A dominance regime is labeled by a tuple ((perm), j) where perm is the permutation (a length-n tuple) defining the vertex, and j is the dominant species index in activity b^T x.</p> <p>Parameters:</p> Name Type Description Default <code>row_idx</code> <code>int</code> <p>The integer j indicating x_j is the dominant species in b^T x at this regime.</p> required <code>b_vec</code> <code>numpy array</code> <p>The b vector defining the activity b^T x.</p> required <code>vertex_perm</code> <code>tuple of int</code> <p>The tuple of length d (number of totals of binding network) referring to the dominance vertex that this dom_regime belongs to.</p> required <code>vertex</code> <code>ROP_vertex</code> <p>The vertex that this dom_regime belongs to. This dom_regime is at this vertex with an additional dominance condition for the activity.</p> required <code>bn</code> <code>binding_network</code> <p>The binding network that this dom_regime belongs to.</p> required <code>ld</code> <code>tuple</code> <p>The reaction order or log derivative of this dom_regime. The row_idx row of the vertex's h_mat.</p> required <code>neighbors_dict</code> <code>dict</code> <p>The dictionary for dom_regime neighbors of this dom_regime. Has four keys, three of them are \"finite\", \"infinite\", and \"all\", for finite, infinite (ray) dom_regime neighbors, and all of dom_regime neighbors, respectively. For each of these keys, we get a dictionary as well, with a (perm, row_idx) tuple as key and the dom_regime object as value. The last key is \"zero\", which maps to neighbors connected via dom_regimes that are zero rays in reaction orders (or log derivative). The value is itself a dictionary with \"finite\", \"infinite\", and \"all\" mapping to dictionaries with (ld: ld_regime) entries.</p> required <code>is_feasible</code> <code>bool</code> <p>Whether this dom_regime is feasible under the last given constraints. If a new set of constraints is given and tested, then this is overwritten.</p> required <code>neighbors_constrained_dict</code> <code>dict</code> <p>The dictionary for ld_regime neighbors of this ld_regime that are feasible under constraints applied to each dom_regime. Same keys as neighbors_dict.</p> required <code>c_mat_add_x</code> <code>numpy array</code> <p>Additional inequalities specifying the condition to reach this dom_regime on top of the inequalities from its vertex. To be concatenated vertically with vertex.c_mat_x. This is in chart 'x'.</p> required <code>c_mat_add_xak</code> <code>numpy array</code> <p>Additional inequalities specifying the condition to reach this dom_regime on top of the inequalities from its vertex. To be concatenated vertically with vertex.c_mat_xak. This is in chart 'xak'.</p> required <code>c0_vec_add</code> <code>numpy array</code> <p>Additional intercept vector entries for the inequalities specifying the condition to reach this dom_regime on top of the inequalities from its vertex. To be concatenated vertically with vertex.c0_vec when used to specify inequalities. Same vector for both chart 'x' and 'xak'.</p> required <code>c_mat_add_tk</code> <code>numpy array</code> <p>Additional inequalities specifying this dom_regime on top of the inequalities from its vertex. To be concatenated vertically with vertex.c_mat_tk. This is in chart 'tk'. Is only meaningful if its vertex is non-singular.</p> required Source code in <code>src/bcn/binding_network.py</code> <pre><code>class rop_dom_regime:\n  \"\"\"\n  A dominance regime (dom_regime) object for a catalytic activity on top of a given binding network defined by b^T x, for some b vector.\n    A dominance regime is labeled by a tuple ((perm), j) where perm is the permutation (a length-n tuple) defining the vertex, and j is the dominant species index in activity b^T x.\n\n  Args:\n      row_idx (int): The integer j indicating x_j is the dominant species in b^T x at this regime.\n      b_vec (numpy array): The b vector defining the activity b^T x.\n      vertex_perm (tuple of int): The tuple of length d (number of totals of binding network) referring to the dominance vertex that this dom_regime belongs to.\n      vertex (ROP_vertex): The vertex that this dom_regime belongs to. This dom_regime is at this vertex with an additional dominance condition for the activity.\n      bn (binding_network): The binding network that this dom_regime belongs to.\n      ld (tuple): The reaction order or log derivative of this dom_regime. The row_idx row of the vertex's h_mat.\n      neighbors_dict (dict): The dictionary for dom_regime neighbors of this dom_regime.\n          Has four keys, three of them are \"finite\", \"infinite\", and \"all\",\n          for finite, infinite (ray) dom_regime neighbors, and all of dom_regime neighbors, respectively.\n          For each of these keys, we get a dictionary as well, with a (perm, row_idx) tuple as key and the dom_regime object as value.\n          The last key is \"zero\", which maps to neighbors connected via dom_regimes that are zero rays in reaction orders (or log derivative).\n          The value is itself a dictionary with \"finite\", \"infinite\", and \"all\" mapping to dictionaries with (ld: ld_regime) entries.\n      is_feasible (bool): Whether this dom_regime is feasible under the last given constraints.\n          If a new set of constraints is given and tested, then this is overwritten.\n      neighbors_constrained_dict (dict): The dictionary for ld_regime neighbors of this ld_regime that are feasible under constraints applied to each dom_regime.\n          Same keys as neighbors_dict.\n      c_mat_add_x (numpy array): Additional inequalities specifying the condition to reach this dom_regime on top of the inequalities from its vertex.\n          To be concatenated vertically with vertex.c_mat_x. This is in chart 'x'.\n      c_mat_add_xak (numpy array): Additional inequalities specifying the condition to reach this dom_regime on top of the inequalities from its vertex.\n          To be concatenated vertically with vertex.c_mat_xak. This is in chart 'xak'.\n      c0_vec_add (numpy array): Additional intercept vector entries for the inequalities specifying the condition to reach this dom_regime on top of the inequalities from its vertex.\n          To be concatenated vertically with vertex.c0_vec when used to specify inequalities.\n          Same vector for both chart 'x' and 'xak'.\n      c_mat_add_tk (numpy array): Additional inequalities specifying this dom_regime on top of the inequalities from its vertex.\n          To be concatenated vertically with vertex.c_mat_tk. This is in chart 'tk'.\n          Is only meaningful if its vertex is non-singular.\n  \"\"\"\n  def __init__(self,row_idx,b_vec,vertex_perm,bn):\n    \"\"\"\n    Initiates a ROP vertex.\n\n    Args:\n        row_idx (int): The integer j indicating x_j is the dominant species in b^T x at this regime.\n        b_vec (numpy array): The b vector defining the activity b^T x.\n        vertex_perm (tuple of int): The tuple of length d (number of totals of binding network) referring to the dominance vertex that this dom_regime belongs to.\n        bn (binding_network): The binding network that this dom_regime belongs to.\n    \"\"\"\n    self.row_idx=row_idx\n    self.b_vec=tuple(b_vec)\n    self.vertex_perm=vertex_perm\n    self.vertex=bn.vertex_dict['all'][vertex_perm]\n    self.bn=bn\n    self.ld=tuple(self.vertex.h_mat[row_idx,:])\n    self.is_feasible=True\n\n  def chart_check_add(self,chart):\n    if chart=='x':\n      try: \n        c_mat_add=self.c_mat_add_x\n        c0_vec_add=self.c0_vec_add\n      except AttributeError: # c_mat_add is not yet calculated\n        self.calc_c_mat_add_x()\n        c_mat_add=self.c_mat_add_x\n        c0_vec_add=self.c0_vec_add\n    elif chart=='xak':\n      try: \n        c_mat_add=self.c_mat_add_xak\n        c0_vec_add=self.c0_vec_add\n      except AttributeError: # c_mat_add_xak is not yet calculated\n        self.calc_c_mat_add_xak()\n        c_mat_add=self.c_mat_add_xak\n        c0_vec_add=self.c0_vec_add\n    elif chart=='tk':\n      try: \n        c_mat_add=self.c_mat_add_tk\n        c0_vec_add=self.c0_vec_add_tk\n      except AttributeError: # c_mat_add_tk is not yet calculated\n        self.calc_c_mat_add_tk()\n        c_mat_add=self.c_mat_add_tk\n        c0_vec_add=self.c0_vec_add_tk\n    else:\n      raise Exception('chart that is not one of \"x,xak,tk\" is not implemented yet')\n    return c_mat_add,c0_vec_add\n\n  def feasibility_test(self,chart='x',opt_constraints=[],positive_threshold=1e-5,is_asymptotic=True):\n    c_mat_add,c0_vec_add = self.chart_check_add(chart)\n    vv=self.vertex\n    opt_var=self.bn.opt_var\n    opt_constraints_test=[]\n    opt_constraints_test+=opt_constraints\n    if np.any(c_mat_add): #c_mat_add could be empty if b_vec has just one nonzero entry.\n      if is_asymptotic: # if the test condition is asymptotic, c0_vec_add is considered 0.\n        opt_constraints_test+=[c_mat_add @ opt_var &gt;= positive_threshold]\n      else: # if not asymptotic, it is exact, so c0_vec_add needs to be considered.\n        opt_constraints_test+=[c_mat_add @ opt_var + self.c0_vec_add &gt;= positive_threshold]\n    is_feasible=vv.vertex_feasibility_test(chart=chart,opt_constraints=opt_constraints_test,is_asymptotic=is_asymptotic)\n    return is_feasible\n\n  def calc_c_mat_add_x(self):\n    # Compute feasibility conditions of this dominance regime in addition \n    #   to vertex feasibility conditions in the form of \n    #   c_mat_add_x * logx + c0_vec_add &gt; 0, i.e. in chart x.\n    # Each condition comes from and inequality of the form \n    #   b_j1 x_j1 &gt; b_j2 x_j2, which can be written as \n    #   log(x_j1) - log(x_j2) + [log(b_j1) - log(b_j2)] &gt; 0.\n    # So the corresponding row of c_mat_add_x are all 0's except 1 at j1 \n    #   and -1 at j2. And corresponding entry of c0_vec is log(b_j1) - log(b_j2).\n    j=self.row_idx\n    b_vec=np.array(self.b_vec)\n    idx_nonzero_b=np.where(b_vec &gt; 0)[0]\n    n_ineq=len(idx_nonzero_b)-1\n    c_mat_add_x=np.zeros((n_ineq,self.bn.dim_n))\n    c0_vec_add=np.zeros(n_ineq)\n    counter=0\n    for jp in idx_nonzero_b:\n      if jp!=j:\n        c_mat_add_x[counter,j]=1\n        c_mat_add_x[counter,jp]=-1\n        c0_vec_add[counter]=np.log10(b_vec[j])-np.log10(b_vec[jp])\n        counter+=1\n    self.c_mat_add_x=c_mat_add_x\n    self.c0_vec_add=c0_vec_add\n\n  def calc_c_mat_add_xak(self):\n    # compute feasibility conditions of this dominance regime in addition to vertex feasibility conditions\n    # in the form of c_mat_add_xak * log(xa,k) + c0_vec_add &gt; 0, i.e. in chart log(xa,k)\n    try: c_mat_add_x=self.c_mat_add_x\n    except AttributeError: # c_mat_add is not yet calculated\n      self.calc_c_mat_add_x()\n      c_mat_add_x=self.c_mat_add_x\n    try: xak2x_map=self.bn.xak2x_map\n    except AttributeError:\n      self.bn.calc_xak2x_map()\n      xak2x_map=self.bn.xak2x_map\n    c_mat_add_xak=c_mat_add_x.dot(xak2x_map)\n    self.c_mat_add_xak=c_mat_add_xak\n\n  def calc_c_mat_add_tk(self):\n    # compute feasibility conditions of this dominance regime in addition to vertex feasibility conditions\n    # in the form of c_mat_add_tk * log(t,k) &gt; 0, i.e. in chart log(t,k)\n    assert self.vertex.orientation!=0, \"only finite vertices can have non-singular (t,k) chart\"\n    try: c_mat_add_x=self.c_mat_add_x\n    except AttributeError: # c_mat_add is not yet calculated\n      self.calc_c_mat_add_x()\n      c_mat_add_x=self.c_mat_add_x\n    # The equivalence here is the following:\n    # c_mat_tk @ log(t,k) + c0_vec_tk &gt;=0  &lt;=&gt;  c_mat_x @ logx + c0_vec &gt;=0\n    # and we use h_mat*log(t,k)=log(x) at the vertex\n    c_mat_add_tk=c_mat_add_x.dot(self.vertex.h_mat) \n    c0_vec_add_tk=self.c0_vec_add - c_mat_add_x.dot(self.h_mat.dot(self.m0_vec))\n    self.c_mat_add_tk=c_mat_add_tk\n    self.c0_vec_tk=c0_vec_add_tk\n\n  def find_neighbors(self):\n    vv=self.vertex\n    neighbors_fin={}\n    neighbors_inf={}\n    regime_fin_dict=self.bn.activity_regime_dict[tuple(self.b_vec)]['finite']\n    regime_inf_dict=self.bn.activity_regime_dict[tuple(self.b_vec)]['infinite']\n    for key,regime in regime_fin_dict.items():\n      perm,row_idx=key\n      # if same vertex, but different dominance, then it's neighbor.\n      if perm==self.vertex_perm and row_idx!=self.row_idx:\n        neighbors_fin[key] = regime\n      # if different vertex, but it's a neighboring vertex, then it's neighbor.\n      else:\n        try: # if perm is in neighbors\n          vv.neighbors_dict['all'][perm]\n          # If the neighboring vertex's transition index (the row_idx that changed compared to self)\n          # is the same as its dominance index, then it's a neighbor.\n          # Or, if the transition index is not the same, then its dominance index needs to be the same as self.\n          if row_idx == self.row_idx or perm[np.where(np.array(perm)!=self.vertex_perm)[0][0]]==row_idx:\n            neighbors_fin[key] = regime\n        except KeyError: # not in neighbors\n          continue\n\n\n    for key,regime in regime_inf_dict.items():\n      perm,row_idx=key\n      # if same vertex, but different dominance, then it's neighbor.\n      if perm==self.vertex_perm and row_idx!=self.row_idx:\n        neighbors_inf[key] = regime\n      # if different vertex, but it's a neighboring vertex, then it's neighbor.\n      else:\n        try: # if perm is in neighbors\n          vv.neighbors_dict['all'][perm]\n          if row_idx == self.row_idx or perm[np.where(np.array(perm)!=self.vertex_perm)[0][0]]==row_idx:\n            neighbors_inf[key] = regime\n        except KeyError: # not in neighbors\n          continue\n    neighbors_all = {**neighbors_fin,**neighbors_inf}\n    self.neighbors_dict={'finite':neighbors_fin,'infinite':neighbors_inf,'all':neighbors_all}\n\n  def find_neighbors_zero(self):\n    # Find neighbors that connect through dom_regimes with zero ld.\n    # neighbors via zero are not considered neighbors of dom_regimes,\n    # but we would like to keep them tracked, since they will become neighbors\n    # in ld space.\n    # This should be done after all neighbors of dom_regimes are constructed\n    # since it relies on knowing the neighbors of dom_regime with ld=0.\n    # A zero neighbor could have a zero neighbor, so recursion is needed to exhaust this.\n    def extract_zero_neighbor(infinite_neighbors, finite_zero_neighbors, infinite_zero_neighbors, ld_zero, visited):\n      zero_neighbors = {\n          key: dom_regime for key, dom_regime in infinite_neighbors.items() if tuple(dom_regime.ld) == ld_zero\n      }\n      if zero_neighbors:  # the dictionary is not empty\n          for key, dom_regime in zero_neighbors.items():\n              if key not in visited:\n                  visited.add(key)\n                  finite_zero_neighbors.update(dom_regime.neighbors_dict['finite'])\n                  infinite_zero_neighbors.update(dom_regime.neighbors_dict['infinite'])\n                  finite_zero_neighbors, infinite_zero_neighbors, visited = extract_zero_neighbor(\n                      dom_regime.neighbors_dict['infinite'],\n                      finite_zero_neighbors,\n                      infinite_zero_neighbors,\n                      ld_zero,\n                      visited\n                  )\n      return finite_zero_neighbors, infinite_zero_neighbors, visited\n\n    n = self.bn.dim_n\n    ld_zero = tuple(np.zeros(n))\n    finite_zero_neighbors = {}\n    infinite_zero_neighbors = {}\n    visited = set()\n\n    infinite_neighbors = self.neighbors_dict['infinite']\n    finite_zero_neighbors, infinite_zero_neighbors, visited = extract_zero_neighbor(\n        infinite_neighbors, finite_zero_neighbors, infinite_zero_neighbors, ld_zero, visited\n    )\n\n    # Remove self from the neighbors' dictionaries if present\n    try:\n        if self.vertex.orientation == 0:\n            del infinite_zero_neighbors[(self.vertex_perm, self.row_idx)]\n        else:\n            del finite_zero_neighbors[(self.vertex_perm, self.row_idx)]\n    except KeyError:\n        pass\n\n    all_zero_neighbors = {**finite_zero_neighbors, **infinite_zero_neighbors}\n    self.neighbors_dict['zero'] = {\n        'finite': finite_zero_neighbors,\n        'infinite': infinite_zero_neighbors,\n        'all': all_zero_neighbors\n    }\n    self.neighbors_dict['allnzero'] = {\n        'finite': {**finite_zero_neighbors,**self.neighbors_dict['finite']},\n        'infinite': {**infinite_zero_neighbors,**self.neighbors_dict['infinite']},\n        'all': {**all_zero_neighbors,**self.neighbors_dict['all']}\n    }\n\n  def update_constrained_neighbors(self):\n    # Using dom_regimes' is_feasible tag to have updated neighbors.\n    # The feasible neighbors of an infeasible neighbor becomes this vertex's neighbors.\n    # We search the next level for the infeasible neighbors of an infeasible neighbor.\n    # So this uses recursion.\n\n    def extract_infeasible_neighbor(infeasible_neighbors,neighbors_feasible_all,visited):\n      for key,dom_regime in infeasible_neighbors.items():\n          if key not in visited:\n              visited.add(key)\n              # get the feasible and infeasible neighbors of this dom_regime\n              infeasible_neighbors = {}\n              feasible_neighbors={}\n              for key,dom_regime in dom_regime.neighbors_dict['allnzero']['all'].items():\n                if dom_regime.is_feasible:\n                  feasible_neighbors[key]=dom_regime\n                else:\n                  infeasible_neighbors[key]=dom_regime\n              # the feasible ones are neighbors under constraint.\n              neighbors_feasible_all.update(feasible_neighbors)\n              # the infeasible ones we need to look further\n              if infeasible_neighbors:\n                neighbors_feasible_all, visited = extract_infeasible_neighbor(\n                  infeasible_neighbors,\n                  neighbors_feasible_all,\n                  visited\n                )\n      return neighbors_feasible_all, visited\n\n    neighbors_feasible_all = {key:dom_regime for key,dom_regime in self.neighbors_dict['allnzero']['all'].items() if dom_regime.is_feasible}\n    infeasible_neighbors = {key:dom_regime for key,dom_regime in self.neighbors_dict['allnzero']['all'].items() if not dom_regime.is_feasible}\n    visited = set()\n    if infeasible_neighbors:\n      neighbors_feasible_all,visited = extract_infeasible_neighbor(\n        infeasible_neighbors,neighbors_feasible_all,visited\n      )\n    # Remove self from the neighbors' dictionaries if present\n    try:\n        del neighbors_feasible_all[(self.vertex_perm,self.row_idx)]\n    except KeyError:\n        pass\n    neighbors_feasible_inf = {\n        key:dom_regime for key,dom_regime in neighbors_feasible_all.items() if dom_regime.vertex.orientation==0\n        }\n    neighbors_feasible_fin = {\n        key:dom_regime for key,dom_regime in neighbors_feasible_all.items() if dom_regime.vertex.orientation!=0\n        }\n    self.neighbors_constrained_dict={'finite':neighbors_feasible_fin,\n                                  'infinite':neighbors_feasible_inf,\n                                  'all':neighbors_feasible_all}\n\n  # def print_validity_condition(self,is_asymptotic=False):\n  #   # print the expression for t=x, x(t,k) and inequalities for the\n  #   # region of validity for this dominance regime,\n  #   # using the labels of x,t,k\n\n  def hull_sampling(self,nsample,chart='x', margin=0,logmin=-6,logmax=6,c_mat_extra=[],c0_vec_extra=[]):\n    \"\"\"\n    Sample points in the dom_regime's region of validity based on its hull of feasible regions.\n    Extra conditions (linear) can be added as c_mat_extra @ var + c0_vec_extra &gt;= 0.\n    This is done by adding dom_regime's additional constraints to its vertex's sampling function.\n\n    Args:\n        nsample (int): Number of points to be sampled.\n        chart (str, optional): A string indicating the chart that the opt_constraints are specified in.\n            Choices are 'x','xak', and 'tk'.\n        margin (float, optional): The dom_regime's feasibility conditions are inequalities, \n            of the form c_mat*x + c0_vec &gt;= margin (e.g. in 'x' chart),\n            where margin is the margin used here. Defaults to 0.\n            This can be adjusted to be stronger/weaker requirements on dominance.\n        logmin (float or ndarray vector): logmin, logmax could be scalars, then it's the same value applied to \n            every variable. \n            They could also be vectors of length dim_n.\n        logmax (float or ndarray vector): logmin, logmax could be scalars, then it's the same value applied to \n            every variable. \n            They could also be vectors of length dim_n.\n        c_mat_extra (ndarray, shape (n_constraints, n_var)): Extra optimization constraints to be added to feasibility conditions,\n            in the form of c_mat_extra @ var + c0_vec_extra &gt;= 0.\n        c0_vec_extra (numpy vector, shape (n_constraints,)): Extra optimization constraints to be added to feasibility conditions,\n            in the form of c_mat_extra @ var + c0_vec_extra &gt;=0.\n\n    Returns:\n        sample (ndarray of shape nsample-by-dim_n): dim_n is number of species in the binding network.\n            Sampled points satisfying the feasibility conditions of this vertex.\n            Each row (sample[i,:]) is a sampled point.\n    \"\"\"\n    # Get the additional constraints for the dom_regime\n    c_mat_add,c0_vec_add=self.chart_check_add(chart=chart)\n    # Combine dom_regime constraints with given additional constraints \n    #   to get the full constraints to be added to vertex validity.\n    if np.any(c_mat_extra): # if there are additional constraints\n      c_mat_extra_full=np.vstack((c_mat_add,c_mat_extra))\n      # Incorporate margin into c0_vec_add, since this won't be added again later in the vertex.\n      c0_vec_extra_full=np.concatenate((c0_vec_add-margin*np.ones(c0_vec_add.shape[0]),c0_vec_extra))\n    else: # there are no additional constraints\n      c_mat_extra_full = c_mat_add\n      c0_vec_extra_full = c0_vec_add-margin\n    # Get the hull using the vertex's method, but with additional\n    #   constraints from the dom_regime.\n    points,hull,_,_=self.vertex.vertex_hull_of_validity(chart=chart,margin=margin,logmin=logmin,logmax=logmax,c_mat_extra=c_mat_extra_full,c0_vec_extra=c0_vec_extra_full)\n    ncoeffs=points.shape[0]\n    temp=np.sort(np.random.rand(nsample,ncoeffs-1),axis=1)\n    coeffs=np.diff(temp,prepend=0,append=1,axis=1)\n    sample=coeffs@points # this has shape nsample-by-dim_n\n    return sample\n</code></pre>"},{"location":"#bcn.binding_network.rop_dom_regime.__init__","title":"<code>__init__(row_idx, b_vec, vertex_perm, bn)</code>","text":"<p>Initiates a ROP vertex.</p> <p>Parameters:</p> Name Type Description Default <code>row_idx</code> <code>int</code> <p>The integer j indicating x_j is the dominant species in b^T x at this regime.</p> required <code>b_vec</code> <code>numpy array</code> <p>The b vector defining the activity b^T x.</p> required <code>vertex_perm</code> <code>tuple of int</code> <p>The tuple of length d (number of totals of binding network) referring to the dominance vertex that this dom_regime belongs to.</p> required <code>bn</code> <code>binding_network</code> <p>The binding network that this dom_regime belongs to.</p> required Source code in <code>src/bcn/binding_network.py</code> <pre><code>def __init__(self,row_idx,b_vec,vertex_perm,bn):\n  \"\"\"\n  Initiates a ROP vertex.\n\n  Args:\n      row_idx (int): The integer j indicating x_j is the dominant species in b^T x at this regime.\n      b_vec (numpy array): The b vector defining the activity b^T x.\n      vertex_perm (tuple of int): The tuple of length d (number of totals of binding network) referring to the dominance vertex that this dom_regime belongs to.\n      bn (binding_network): The binding network that this dom_regime belongs to.\n  \"\"\"\n  self.row_idx=row_idx\n  self.b_vec=tuple(b_vec)\n  self.vertex_perm=vertex_perm\n  self.vertex=bn.vertex_dict['all'][vertex_perm]\n  self.bn=bn\n  self.ld=tuple(self.vertex.h_mat[row_idx,:])\n  self.is_feasible=True\n</code></pre>"},{"location":"#bcn.binding_network.rop_dom_regime.hull_sampling","title":"<code>hull_sampling(nsample, chart='x', margin=0, logmin=-6, logmax=6, c_mat_extra=[], c0_vec_extra=[])</code>","text":"<p>Sample points in the dom_regime's region of validity based on its hull of feasible regions. Extra conditions (linear) can be added as c_mat_extra @ var + c0_vec_extra &gt;= 0. This is done by adding dom_regime's additional constraints to its vertex's sampling function.</p> <p>Parameters:</p> Name Type Description Default <code>nsample</code> <code>int</code> <p>Number of points to be sampled.</p> required <code>chart</code> <code>str</code> <p>A string indicating the chart that the opt_constraints are specified in. Choices are 'x','xak', and 'tk'.</p> <code>'x'</code> <code>margin</code> <code>float</code> <p>The dom_regime's feasibility conditions are inequalities,  of the form c_mat*x + c0_vec &gt;= margin (e.g. in 'x' chart), where margin is the margin used here. Defaults to 0. This can be adjusted to be stronger/weaker requirements on dominance.</p> <code>0</code> <code>logmin</code> <code>float or ndarray vector</code> <p>logmin, logmax could be scalars, then it's the same value applied to  every variable.  They could also be vectors of length dim_n.</p> <code>-6</code> <code>logmax</code> <code>float or ndarray vector</code> <p>logmin, logmax could be scalars, then it's the same value applied to  every variable.  They could also be vectors of length dim_n.</p> <code>6</code> <code>c_mat_extra</code> <code>ndarray, shape (n_constraints, n_var</code> <p>Extra optimization constraints to be added to feasibility conditions, in the form of c_mat_extra @ var + c0_vec_extra &gt;= 0.</p> <code>[]</code> <code>c0_vec_extra</code> <code>numpy vector, shape (n_constraints,</code> <p>Extra optimization constraints to be added to feasibility conditions, in the form of c_mat_extra @ var + c0_vec_extra &gt;=0.</p> <code>[]</code> <p>Returns:</p> Name Type Description <code>sample</code> <code>ndarray of shape nsample-by-dim_n</code> <p>dim_n is number of species in the binding network. Sampled points satisfying the feasibility conditions of this vertex. Each row (sample[i,:]) is a sampled point.</p> Source code in <code>src/bcn/binding_network.py</code> <pre><code>def hull_sampling(self,nsample,chart='x', margin=0,logmin=-6,logmax=6,c_mat_extra=[],c0_vec_extra=[]):\n  \"\"\"\n  Sample points in the dom_regime's region of validity based on its hull of feasible regions.\n  Extra conditions (linear) can be added as c_mat_extra @ var + c0_vec_extra &gt;= 0.\n  This is done by adding dom_regime's additional constraints to its vertex's sampling function.\n\n  Args:\n      nsample (int): Number of points to be sampled.\n      chart (str, optional): A string indicating the chart that the opt_constraints are specified in.\n          Choices are 'x','xak', and 'tk'.\n      margin (float, optional): The dom_regime's feasibility conditions are inequalities, \n          of the form c_mat*x + c0_vec &gt;= margin (e.g. in 'x' chart),\n          where margin is the margin used here. Defaults to 0.\n          This can be adjusted to be stronger/weaker requirements on dominance.\n      logmin (float or ndarray vector): logmin, logmax could be scalars, then it's the same value applied to \n          every variable. \n          They could also be vectors of length dim_n.\n      logmax (float or ndarray vector): logmin, logmax could be scalars, then it's the same value applied to \n          every variable. \n          They could also be vectors of length dim_n.\n      c_mat_extra (ndarray, shape (n_constraints, n_var)): Extra optimization constraints to be added to feasibility conditions,\n          in the form of c_mat_extra @ var + c0_vec_extra &gt;= 0.\n      c0_vec_extra (numpy vector, shape (n_constraints,)): Extra optimization constraints to be added to feasibility conditions,\n          in the form of c_mat_extra @ var + c0_vec_extra &gt;=0.\n\n  Returns:\n      sample (ndarray of shape nsample-by-dim_n): dim_n is number of species in the binding network.\n          Sampled points satisfying the feasibility conditions of this vertex.\n          Each row (sample[i,:]) is a sampled point.\n  \"\"\"\n  # Get the additional constraints for the dom_regime\n  c_mat_add,c0_vec_add=self.chart_check_add(chart=chart)\n  # Combine dom_regime constraints with given additional constraints \n  #   to get the full constraints to be added to vertex validity.\n  if np.any(c_mat_extra): # if there are additional constraints\n    c_mat_extra_full=np.vstack((c_mat_add,c_mat_extra))\n    # Incorporate margin into c0_vec_add, since this won't be added again later in the vertex.\n    c0_vec_extra_full=np.concatenate((c0_vec_add-margin*np.ones(c0_vec_add.shape[0]),c0_vec_extra))\n  else: # there are no additional constraints\n    c_mat_extra_full = c_mat_add\n    c0_vec_extra_full = c0_vec_add-margin\n  # Get the hull using the vertex's method, but with additional\n  #   constraints from the dom_regime.\n  points,hull,_,_=self.vertex.vertex_hull_of_validity(chart=chart,margin=margin,logmin=logmin,logmax=logmax,c_mat_extra=c_mat_extra_full,c0_vec_extra=c0_vec_extra_full)\n  ncoeffs=points.shape[0]\n  temp=np.sort(np.random.rand(nsample,ncoeffs-1),axis=1)\n  coeffs=np.diff(temp,prepend=0,append=1,axis=1)\n  sample=coeffs@points # this has shape nsample-by-dim_n\n  return sample\n</code></pre>"},{"location":"#bcn.binding_network.rop_ld_regime","title":"<code>rop_ld_regime</code>","text":"<p>The ld_regime object, for a given ld (log derivative or reaction order), there could be multiple dominance regimes (defined by dominance relations in x for a given catalytic activity on top of a binding network).   Each ld_regime has possibly several dominance regimes with the same ld.</p> <p>Args:       ld (tuple of integers): The log derivative, or reaction order, of this ld_regime.       b_vec (numpy array vector): The b vector defining the activity, b^T x.       bn (binding_network object): The binding network that this ld_regime belongs to.       is_ray (boolean): Whether this ld_regime is a ray or not.       dom_regime_keys (list of tuples): The list of tuples, each tuple is the key for a dominance regime that has reaction order (ld) the same as this ld_regime.       dom_regime_dict (dictionary): The dictionary with key as the tuple (perm, dom_idx) representing a dominance regime and value of the dominance regime object.       neighbors_dict (dictionary): The dictionary for ld_regime neighbors of this ld_regime.           Has four keys, three of them are \"finite\", \"infinite\", and \"all\",           for finite, infinite (ray) ld_regime neighbors, and all of ld_regime neighbors, respectively.           For each of these keys, we get a dictionary as well, with ld tuple as key and the ld_regime object as value.           The last key is \"zero\", which maps to neighbors connected via ld_regimes that are zero rays. The value is itself a dictionary with \"finite\", \"infinite\", and \"all\" mapping to dictionaries with (ld: ld_regime) entries.       is_feasible (boolean): Whether this ld_regime is feasible. It is feasible if it has at least one dom_regime that is feasible.       neighbors_constrained_dict (dictionary): The dictionary for ld_regime neighbors of this ld_regime that are feasible under constraints applied to each dom_regime.</p> Source code in <code>src/bcn/binding_network.py</code> <pre><code>class rop_ld_regime:\n  \"\"\"\n  The ld_regime object, for a given ld (log derivative or reaction order), there could be multiple dominance regimes (defined by dominance relations in x for a given catalytic activity on top of a binding network).\n    Each ld_regime has possibly several dominance regimes with the same ld.\n\n    Args:\n        ld (tuple of integers): The log derivative, or reaction order, of this ld_regime.\n        b_vec (numpy array vector): The b vector defining the activity, b^T x.\n        bn (binding_network object): The binding network that this ld_regime belongs to.\n        is_ray (boolean): Whether this ld_regime is a ray or not.\n        dom_regime_keys (list of tuples): The list of tuples, each tuple is the key for a dominance regime that has reaction order (ld) the same as this ld_regime.\n        dom_regime_dict (dictionary): The dictionary with key as the tuple (perm, dom_idx) representing a dominance regime and value of the dominance regime object.\n        neighbors_dict (dictionary): The dictionary for ld_regime neighbors of this ld_regime.\n            Has four keys, three of them are \"finite\", \"infinite\", and \"all\",\n            for finite, infinite (ray) ld_regime neighbors, and all of ld_regime neighbors, respectively.\n            For each of these keys, we get a dictionary as well, with ld tuple as key and the ld_regime object as value.\n            The last key is \"zero\", which maps to neighbors connected via ld_regimes that are zero rays. The value is itself a dictionary with \"finite\", \"infinite\", and \"all\" mapping to dictionaries with (ld: ld_regime) entries.\n        is_feasible (boolean): Whether this ld_regime is feasible. It is feasible if it has at least one dom_regime that is feasible.\n        neighbors_constrained_dict (dictionary): The dictionary for ld_regime neighbors of this ld_regime that are feasible under constraints applied to each dom_regime.\n    \"\"\"\n  # b_vec defines an activity, yielding possibly multiple regimes for each vertex,\n  # with logder corresponding to different rows of the vertex logder matrix.\n  # ld_regime focus on logder, collapsing the same logder to be the same ld_regime,\n  # which may come from different vertices.\n  # Each ld_regime has multiple dom_regimes and regions of feasibility.\n  def __init__(self,ld,is_ray,b_vec,dom_regime_keys,bn):\n    \"\"\"\n    Args:\n        ld (tuple of integers): The log derivative, or reaction order, of this ld_regime.\n        is_ray (bool): Whether this ld_regime is a ray or not.\n        b_vec (numpy array): The b vector defining the activity, b^T x.\n        dom_regime_keys (list of tuples): The list of tuples, each tuple is the key for a dominance regime that has reaction order (ld) the same as this ld_regime.\n        bn (binding_network): The binding network that this ld_regime belongs to.\n    \"\"\"\n    self.ld=ld\n    self.b_vec=tuple(b_vec)\n    self.bn=bn\n    self.is_ray=is_ray\n    self.dom_regime_keys=dom_regime_keys\n    self.dom_regime_dict={key:bn.activity_regime_dict[self.b_vec]['all'][key] for key in dom_regime_keys}\n    self.is_feasible=True\n\n  def find_neighbors(self):\n    # Construct self.neighbors_dict based on dominance regimes' neighbors,\n    # then construct neighbors_constrained_dict.\n    neighbors_fin={};neighbors_inf={};neighbors_fin_zero={};neighbors_inf_zero={}\n    # Instead of iterating through all ld_regimes, we just look at this ld_regime's\n    # dom_regimes and their corresponding ld_regimes as neighbors.\n    for key,dom_regime in self.dom_regime_dict.items():\n      for nb_key,nb_regime in dom_regime.neighbors_dict['finite'].items():\n        neighbors_fin[nb_regime.ld]=self.bn.activity_ld_regime_dict[self.b_vec]['finite'][nb_regime.ld]\n      for nb_key,nb_regime in dom_regime.neighbors_dict['infinite'].items():\n        neighbors_inf[nb_regime.ld]=self.bn.activity_ld_regime_dict[self.b_vec]['infinite'][nb_regime.ld]\n      for nb_key,nb_regime in dom_regime.neighbors_dict['zero']['finite'].items():\n        neighbors_fin_zero[nb_regime.ld]=self.bn.activity_ld_regime_dict[self.b_vec]['finite'][nb_regime.ld]\n      for nb_key,nb_regime in dom_regime.neighbors_dict['zero']['infinite'].items():\n        neighbors_inf_zero[nb_regime.ld]=self.bn.activity_ld_regime_dict[self.b_vec]['infinite'][nb_regime.ld]\n    neighbors_all={**neighbors_fin,**neighbors_inf}\n    neighbors_all_zero={**neighbors_fin_zero,**neighbors_inf_zero}\n    self.neighbors_dict={'all':neighbors_all,'finite':neighbors_fin,'infinite':neighbors_inf,\n                         'zero':{'all':neighbors_all_zero,'finite':neighbors_fin_zero,'infinite':neighbors_inf_zero}}\n\n  def update_feasibility(self):\n    # Construct self.dom_regime_constrained_dict using dom_regime's is_feasible tag.\n    # Then update self.is_feasible tag, True if self.dom_regime_constrained_dict is not empty,\n    # since this means there are some dom_regimes satisfying the constraints.\n    self.dom_regime_constrained_dict={key:regime for key,regime in self.dom_regime_dict.items() if regime.is_feasible}\n    if self.dom_regime_constrained_dict: self.is_feasible=True\n    else: self.is_feasible=False\n\n  def update_constrained_neighbors(self):\n    # Construct self.neighbors_constrained_dict based on dominance regimes' neighbors_constrained_dict.\n    # This does not distinguish neighbors via zero or not.\n\n    neighbors_constrained_fin={}\n    neighbors_constrained_inf={}\n    # Instead of iterating through all ld_regimes, we just look at this ld_regime's\n    # dom_regimes and their corresponding ld_regimes as neighbors.\n    for key,dom_regime in self.dom_regime_constrained_dict.items():\n      for nb_key,nb_regime in dom_regime.neighbors_constrained_dict['finite'].items():\n        neighbors_constrained_fin[nb_regime.ld]=self.bn.activity_ld_regime_dict[self.b_vec]['finite'][nb_regime.ld]\n      for nb_key,nb_regime in dom_regime.neighbors_constrained_dict['infinite'].items():\n        neighbors_constrained_inf[nb_regime.ld]=self.bn.activity_ld_regime_dict[self.b_vec]['infinite'][nb_regime.ld]\n    neighbors_constrained_all={**neighbors_constrained_fin,**neighbors_constrained_inf}\n    self.neighbors_constrained_dict={'all':neighbors_constrained_all,\n                                     'finite':neighbors_constrained_fin,\n                                     'infinite':neighbors_constrained_inf}\n</code></pre>"},{"location":"#bcn.binding_network.rop_ld_regime.__init__","title":"<code>__init__(ld, is_ray, b_vec, dom_regime_keys, bn)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>ld</code> <code>tuple of integers</code> <p>The log derivative, or reaction order, of this ld_regime.</p> required <code>is_ray</code> <code>bool</code> <p>Whether this ld_regime is a ray or not.</p> required <code>b_vec</code> <code>numpy array</code> <p>The b vector defining the activity, b^T x.</p> required <code>dom_regime_keys</code> <code>list of tuples</code> <p>The list of tuples, each tuple is the key for a dominance regime that has reaction order (ld) the same as this ld_regime.</p> required <code>bn</code> <code>binding_network</code> <p>The binding network that this ld_regime belongs to.</p> required Source code in <code>src/bcn/binding_network.py</code> <pre><code>def __init__(self,ld,is_ray,b_vec,dom_regime_keys,bn):\n  \"\"\"\n  Args:\n      ld (tuple of integers): The log derivative, or reaction order, of this ld_regime.\n      is_ray (bool): Whether this ld_regime is a ray or not.\n      b_vec (numpy array): The b vector defining the activity, b^T x.\n      dom_regime_keys (list of tuples): The list of tuples, each tuple is the key for a dominance regime that has reaction order (ld) the same as this ld_regime.\n      bn (binding_network): The binding network that this ld_regime belongs to.\n  \"\"\"\n  self.ld=ld\n  self.b_vec=tuple(b_vec)\n  self.bn=bn\n  self.is_ray=is_ray\n  self.dom_regime_keys=dom_regime_keys\n  self.dom_regime_dict={key:bn.activity_regime_dict[self.b_vec]['all'][key] for key in dom_regime_keys}\n  self.is_feasible=True\n</code></pre>"},{"location":"#bcn.binding_network.rop_vertex","title":"<code>rop_vertex</code>","text":"<p>A vertex object for reaction order polyhedra. Each binding network has multiple vertices.</p> <p>Parameters:</p> Name Type Description Default <code>perm</code> <code>int tuple</code> <p>An integer tuple of length dim_d, indicating for each conserved quantity,  which species is dominant.</p> required <code>bn</code> <code>binding_network object</code> <p>The binding network that this vertex belongs to. Has l_mat (conservation law matrix) and n_mat (stoichiometry matrix).</p> required <code>p_mat</code> <code>numpy array, d-by-n</code> <p>d x n matrix with exactly one nonzero entry in each row,  of value 1. One-hot representation of perm.</p> required <code>p0_vec</code> <code>numpy array, d-by-1</code> <p>Vector used in (logt, logk) = [p_mat n_mat]' logx + [p0_vec 0]'.  Intercept relating log x to (logt, logk). n_mat is that of the binding network. p0_vec is all zeros if all entries of bn's l_mat are 0 and 1's.</p> required <code>m_mat</code> <code>numpy array, n-by-n</code> <p>Matrix formed by p_mat and n_mat stacked vertically.  In other words, m_mat = [p_mat n_mat]'. n_mat is that of the binding network.</p> required <code>m0_vec</code> <code>numpy array, n-by-1</code> <p>Vector used in (logt, logk) = m_mat logx + m0_vec. m0_vec is the same as [p0_vec 0]', i.e., p0_vec vertically extended with r more zeros.</p> required <code>orientation</code> <code>int</code> <p>Take value in +1, 0, -1. Sign of determinant of [A' N'] matrix.</p> required <code>h_mat</code> <code>numpy array, n-by-n</code> <p>n x n matrix corresponding to the log derivative of this vertex. If finite (non-singular), then this is the log derivative. If infinite (singular), then this is the direction that log derivative goes into. At this vertex, we have relation logx = h_mat (logt, logk) + h0_vec. Not always defined, computed and stored once log derivative is  computed by calling self.vertex_ld_calc().</p> required <code>h0_vec</code> <code>numpy array, n-by-1</code> <p>The intercept vector used in the following relation at this vertex: logx = h_mat (logt, logk) + h0_vec. Only defined for finite (non-singular) vertices. Not always defined, computed and stored once log derivative is  computed by calling self.vertex_ld_calc().</p> required <code>c_mat_x</code> <code>numpy array, shape (n_constraints, n_var</code> <p>Matrix encoding feasibility condition of this vertex in 'x' chart, c_mat_x * logx + c0_vec &gt; 0. If the feasibility condition is considered \"asymptotic\", i.e., in positive projective measure rather than Lebesgue measure (so a ray is an infinitesimal of volume, not a point), then c0_vec is dropped. Not always defined, computed and stored when used in feasibility tests.</p> required <code>c_mat_xak</code> <code>numpy array, shape (n_constraints, n_var</code> <p>Matrix encoding feasibility condition of this vertex in 'xak' chart, c_mat_xak * (logxa, logk) + c0_vec &gt; 0. If the feasibility condition is considered \"asymptotic\", i.e., in positive projective measure rather than Lebesgue measure (so a ray is an infinitesimal of volume, not a point), then c0_vec is dropped. Not always defined, computed and stored when used in feasibility tests.</p> required <code>c0_vec</code> <code>numpy vector, shape (n_constraints,</code> <p>Numpy vector encoding a part of the feasibility condition of this vertex, same for 'x' chart and 'xak' chart. Not always defined, computed and stored when used in feasibility tests.</p> required <code>c_mat_tk</code> <code>numpy array, shape (n_constraints, n_var</code> <p>Matrix encoding feasibility condition of this vertex in 'tk' chart, c_mat_tk * (logt, logk) + c0_vec_tk &gt; 0. If the feasibility condition is considered \"asymptotic\", i.e., in positive projective measure rather than Lebesgue measure (so a ray is an infinitesimal of volume, not a point), then c0_vec_tk is dropped. Only defined for finite (non-singular) vertices. Not always defined, computed and stored when used in feasibility tests.</p> required <code>c0_vec_tk</code> <code>numpy vector, shape (n_constraints,</code> <p>Numpy vector encoding a part of the feasibility condition of this vertex in the 'tk' chart. Only defined for finite (non-singular) vertices. Not always defined, computed and stored when used in feasibility tests.</p> required <code>neighbors_dict</code> <code>dict</code> <p>The dictionary for dom_regime neighbors of this dom_regime. Has four keys: \"finite\", \"infinite\", \"all\", and \"zero\". - \"finite\", \"infinite\", and \"all\" map to dictionaries with (perm, row_idx) tuple as keys    and the dom_regime object as values. - \"zero\" maps to neighbors connected via dom_regimes that are zero rays in reaction orders    (or log derivative).</p> required <code>neighbors_constrained_dict</code> <code>dict</code> <p>The dictionary for ld_regime neighbors of this ld_regime that are feasible under constraints applied to each dom_regime.  Same keys as neighbors_dict.</p> required Source code in <code>src/bcn/binding_network.py</code> <pre><code>class rop_vertex:\n  \"\"\"\n    A vertex object for reaction order polyhedra.\n    Each binding network has multiple vertices.\n\n    Args:\n        perm (int tuple): An integer tuple of length dim_d, indicating for each conserved quantity, \n            which species is dominant.\n        bn (binding_network object): The binding network that this vertex belongs to.\n            Has l_mat (conservation law matrix) and n_mat (stoichiometry matrix).\n        p_mat (numpy array, d-by-n): d x n matrix with exactly one nonzero entry in each row, \n            of value 1. One-hot representation of perm.\n        p0_vec (numpy array, d-by-1): Vector used in (logt, logk) = [p_mat n_mat]' logx + [p0_vec 0]'. \n            Intercept relating log x to (logt, logk).\n            n_mat is that of the binding network.\n            p0_vec is all zeros if all entries of bn's l_mat are 0 and 1's.\n        m_mat (numpy array, n-by-n): Matrix formed by p_mat and n_mat stacked vertically. \n            In other words, m_mat = [p_mat n_mat]'.\n            n_mat is that of the binding network.\n        m0_vec (numpy array, n-by-1): Vector used in (logt, logk) = m_mat logx + m0_vec.\n            m0_vec is the same as [p0_vec 0]', i.e., p0_vec vertically extended with r more zeros.\n        orientation (int): Take value in +1, 0, -1. Sign of determinant of [A' N'] matrix.\n        h_mat (numpy array, n-by-n): n x n matrix corresponding to the log derivative of this vertex.\n            If finite (non-singular), then this is the log derivative.\n            If infinite (singular), then this is the direction that log derivative goes into.\n            At this vertex, we have relation logx = h_mat (logt, logk) + h0_vec.\n            Not always defined, computed and stored once log derivative is \n            computed by calling self.vertex_ld_calc().\n        h0_vec (numpy array, n-by-1): The intercept vector used in the following relation at this vertex:\n            logx = h_mat (logt, logk) + h0_vec.\n            Only defined for finite (non-singular) vertices.\n            Not always defined, computed and stored once log derivative is \n            computed by calling self.vertex_ld_calc().\n        c_mat_x (numpy array, shape (n_constraints, n_var)): Matrix encoding feasibility condition of this vertex\n            in 'x' chart, c_mat_x * logx + c0_vec &gt; 0.\n            If the feasibility condition is considered \"asymptotic\", i.e., in positive\n            projective measure rather than Lebesgue measure (so a ray is an infinitesimal\n            of volume, not a point), then c0_vec is dropped.\n            Not always defined, computed and stored when used in feasibility tests.\n        c_mat_xak (numpy array, shape (n_constraints, n_var)): Matrix encoding feasibility condition of this vertex\n            in 'xak' chart, c_mat_xak * (logxa, logk) + c0_vec &gt; 0.\n            If the feasibility condition is considered \"asymptotic\", i.e., in positive\n            projective measure rather than Lebesgue measure (so a ray is an infinitesimal\n            of volume, not a point), then c0_vec is dropped.\n            Not always defined, computed and stored when used in feasibility tests.\n        c0_vec (numpy vector, shape (n_constraints,)): Numpy vector encoding a part of the feasibility condition of this vertex,\n            same for 'x' chart and 'xak' chart.\n            Not always defined, computed and stored when used in feasibility tests.\n        c_mat_tk (numpy array, shape (n_constraints, n_var)): Matrix encoding feasibility condition of this vertex\n            in 'tk' chart, c_mat_tk * (logt, logk) + c0_vec_tk &gt; 0.\n            If the feasibility condition is considered \"asymptotic\", i.e., in positive\n            projective measure rather than Lebesgue measure (so a ray is an infinitesimal\n            of volume, not a point), then c0_vec_tk is dropped.\n            Only defined for finite (non-singular) vertices.\n            Not always defined, computed and stored when used in feasibility tests.\n        c0_vec_tk (numpy vector, shape (n_constraints,)): Numpy vector encoding a part of the feasibility condition of this vertex\n            in the 'tk' chart.\n            Only defined for finite (non-singular) vertices.\n            Not always defined, computed and stored when used in feasibility tests.\n        neighbors_dict (dict): The dictionary for dom_regime neighbors of this dom_regime.\n            Has four keys: \"finite\", \"infinite\", \"all\", and \"zero\".\n            - \"finite\", \"infinite\", and \"all\" map to dictionaries with (perm, row_idx) tuple as keys \n              and the dom_regime object as values.\n            - \"zero\" maps to neighbors connected via dom_regimes that are zero rays in reaction orders \n              (or log derivative).\n        neighbors_constrained_dict (dict): The dictionary for ld_regime neighbors of this ld_regime that are feasible\n            under constraints applied to each dom_regime. \n            Same keys as neighbors_dict.\n    \"\"\"\n  def __init__(self,perm,bn):\n    \"\"\"\n    Initiates a ROP vertex.\n\n    Args:\n        perm (int tuple): An integer tuple of length dim_d, indicating for each conserved quantity, \n            which species is dominant.\n        bn (binding_network object): The binding network that this vertex is a part of.\n            Used to get dimensions and stoichiometry matrix.\n    \"\"\"\n    self.perm=perm\n    self.bn=bn\n    p_mat=np.zeros((bn.dim_d,bn.dim_n)) # p_mat is all 0 and 1\n    p0_vec=np.zeros(bn.dim_d) # the value of nonzero entries of l_mat chosen by p_mat in each row for this vertex\n    for i in range(bn.dim_d):\n      p_mat[i,perm[i]]=1\n      p0_vec[i]=np.log10(bn.l_mat[i,perm[i]])\n    self.p_mat=p_mat\n    self.p0_vec=p0_vec\n    self.m_mat=np.concatenate((self.p_mat,self.bn.n_mat),axis=0)\n    self.m0_vec=np.concatenate((self.p0_vec,np.zeros(self.bn.dim_r)),axis=0)\n    self.orientation=np.sign(np.linalg.det(self.m_mat))\n    self.is_feasible=True\n\n  def vertex_ld_calc(self):\n    # calculate log derivative matrix,\n    # gives ray direction matrix if infinite vertex\n    dim_n = self.bn.dim_n\n    m_mat = self.m_mat\n    if self.orientation==0: # if singular, get the ray direction\n      m_mult_left=np.kron(np.eye(dim_n),m_mat)\n      m_mult_right=np.kron(m_mat.T,np.eye(dim_n))\n      temp=np.concatenate( (m_mult_left,m_mult_right),axis=0)\n      # the following assertion test is not necessary if guaranteed to be rank 1 singularity.\n      # assert temp.shape[1]-np.linalg.matrix_rank(temp)==1, \"the vertex is singular in more than one direction.\"\n      # we assert that an infinite vertex cannot be singular in more than one direction\n      # so the ray is always rank 1. We assume higher order rays are convex combinations of first order rays.\n      rslt=null_space(temp)\n      # the following normalizes the entries to largest entry = 1.\n      h_mat_coarse=np.reshape(rslt,(dim_n,dim_n),order='F') #order='F' is earlier index changes first. here fortran\n      temp=np.abs(h_mat_coarse)\n      minfactor=np.min(temp[temp&gt;1e-7])\n      h_mat_coarse_int=h_mat_coarse/minfactor #all non-zero entries are now integers\n      h_mat_int=np.rint(h_mat_coarse_int)\n      assert np.max(np.abs(h_mat_int-h_mat_coarse_int)) &lt;1e-3, 'rounding of h_mat for vertices caused large error.'\n      h_mat=h_mat_int/np.max(h_mat_int) # normalize largest entry to 1.\n\n      # now we need to check the directionality. This utilizes neighbors\n      vv_nb=list(self.neighbors_dict['finite'].values())[0]\n      if np.sign(np.linalg.det(vv_nb.h_mat+1e5*h_mat))!=self.bn.orientation:\n        h_mat=-1*h_mat\n    else: # if not singular, just invert the matrix.\n      h_mat = np.linalg.inv(m_mat)\n      self.h0_vec = -h_mat.dot(self.m0_vec) # only non-singular vertices have h0_vec.\n    self.h_mat=h_mat\n\n  def vertex_c_mat_x_calc(self):\n    # Get feasibility condition for this vertex expressed in (x) chart.\n    # c_mat*log(x) + c0_vec &gt; 0 is the validity condition, log is log10.\n    l_mat=self.bn.l_mat\n    j_list=self.j_func(self.p_mat,l_mat)\n    dim=np.sum([len(j) for j in j_list])\n    c_mat_x=np.zeros((dim,self.bn.dim_n))\n    c0_vec = np.zeros(dim)\n    dim_n=self.bn.dim_n\n    counter=0\n    for i in range(self.bn.dim_d):\n      j_i=self.perm[i]\n      for j in j_list[i]:\n        c_mat_x[counter,j_i]=1\n        c_mat_x[counter,j]=-1\n        c0_vec[counter]=np.log10(l_mat[i,j_i])-np.log10(l_mat[i,j])\n        counter+=1\n    self.c_mat_x=c_mat_x\n    self.c0_vec = c0_vec\n\n  def j_func(self,p_mat,l_mat):\n    \"\"\"\n    For p_mat and l_mat, find (column) indices that are nonzero in each row of\n    l_mat but not nonzero in p_mat.\n\n    Args:\n        p_mat (numpy array): d-by-n matrix, each row has only one nonzero entry that is 1.\n        l_mat (numpy array): d-by-n matrix, binding network's conservation law matrix.\n\n    Returns:\n        j_list (list of int): List of (column) indices that are nonzero in l_mat but zero in p_mat.\n    \"\"\"\n    j_list=[]\n    l_mat_masked=np.ma.array(l_mat,mask=p_mat).filled(fill_value=0)\n    for i in range(p_mat.shape[0]):\n      j_list+=[np.nonzero(l_mat_masked[i,:])[0]]\n    return j_list\n\n  def vertex_feasibility_test(self,chart='x',opt_constraints=[],positive_threshold=1e-5,is_asymptotic=True):\n    \"\"\"\n    For given constraints, compute whether this vertex is feasible.\n\n    Args:\n        chart (str, optional): A string indicating the chart that the opt_constraints are specified in.\n            Choices are 'x','xak', and 'tk'.\n        opt_constraints (list of cvxpy inequalities, optional): A list of optimization constraints specified in terms of inequalities\n            relating cvxpy variables of the binding network.\n        positive_threshold (float, optional): The vertex itself has inequality conditions, of the form c_mat*x + c0_vec &gt; th,\n            where th is the positive threshold used here. Defaults to 1e-5.\n        is_asymptotic (bool, optional): Whether the inequalities of the vertex itself should be considered asymptotically\n            or exactly. If asymptotically, then the inequality tested omits c0_vec,\n            so it is c_mat*x &gt; th. is_asymptotic=True corresponds to inequality satisfied\n            for the positive projective measure (where a ray is an infinitesimal of volume),\n            and is_asymptotic=False is Lebesgue measure (a point is an infinitesimal of volume).\n\n    Returns:\n        is_feasible (bool): Whether this vertex is feasible under the constraints.\n    \"\"\"\n    # first prepare the c_mat and c0_vec for the desired chart.\n    c_mat,c0_vec=self.chart_check(chart)\n    is_feasible=True\n    opt_var=self.bn.opt_var #opt_var came from the binding network.\n    if is_asymptotic: #if asymptotic, c0_vec is zero.\n      prob=cp.Problem(cp.Minimize(1),opt_constraints+[c_mat @ opt_var &gt;= positive_threshold])\n    else: # if not asymptotic, it is exact, so c0_vec is taken into account.\n      prob=cp.Problem(cp.Minimize(1),opt_constraints+[c_mat @ opt_var + c0_vec &gt;= positive_threshold])\n    prob.solve()\n    if prob.status=='infeasible':\n      is_feasible=False\n    return is_feasible\n\n  def vertex_find_neighbors(self):\n    # Given a binding network with (already-computed) vertex dictionaries,\n    #   compute this vertex's neighbors and store in self.neighbors,\n    #   depending on whether it is finite or infinite.\n    # Neighbor is defined as changing one row by moving the \"1\" to another place.\n    # For chart 'x', neighbor is more nuanced.\n    #   For example, (0,7,7) can have a neighbor (7,1,7) because it has \n    #     neighbor (7,7,7), which is shared with (7,1,7).\n    #   But we do not consider (7,7,7) as an \"infinite vertex\",\n    #     since &gt;1 order infinite vertices only matter as a \n    #     \"connecting region\", and they are ignored in vertex construction. \n    #   To include these cases, for an infinite vertex perm1, for a given candidate \n    #     infinite neighbor perm 2, if difference is 2 then of course it's a neighbor,\n    #     e.g. (5,5,2) and (5,5,3); if difference is more than 2, then switch the\n    #     differing rows' order and see whether now they match with difference in just one row.\n    #   Since whenever this is the case, there is the regime (j,j,j,*)\n    neighbors_fin={}\n    neighbors_inf={}\n    for perm,vv in self.bn.vertex_dict['finite'].items():\n      # temp=[not np.all(self.p_mat[i,:]==vv.p_mat[i,:]) for i in range(self.bn.dim_d)]\n      # if np.sum(temp)==1: #the difference is just one row\n      if np.sum(np.abs(self.p_mat-vv.p_mat))==2: #difference is in just one row and it's -1, 1.\n        neighbors_fin[perm]=vv\n    for perm,vv in self.bn.vertex_dict['infinite'].items():\n      # temp=[not np.all(self.p_mat[i,:]==vv.p_mat[i,:]) for i in range(self.bn.dim_d)]\n      # if np.sum(temp)==1: #the difference is just one row\n      if np.sum(np.abs(self.p_mat-vv.p_mat))==2: #difference is in just one row and it's -1, 1.\n        neighbors_inf[perm]=vv\n\n    # if self.orientation==0:\n    neighbors_all={**neighbors_fin,**neighbors_inf}\n    self.neighbors_dict={'finite':neighbors_fin,'infinite':neighbors_inf,'all':neighbors_all}\n\n\n  def vertex_update_constrained_neighbors(self):\n    # Using vertices' is_feasible tag to have updated neighbors under constraints.\n    # The feasible neighbors of an infeasible neighbor becomes this vertex's neighbors\n    # under constraints.\n    # If an infeasible neighbor has infeasible neighbors as well, we need to look at\n    # their feasible neighbors as neighbors under constraint as well.\n    # So this uses recursion.\n    # The resulting constrained neighbors is stored in self.neighbors_constrained_dict.\n\n    def extract_infeasible_neighbor(neighbors_all,neighbors_feasible_all,visited):\n      infeasible_neighbors = {\n        perm: vv for perm,vv in neighbors_all.items() if not vv.is_feasible\n      }\n      if infeasible_neighbors:  # the dictionary is not empty\n        for perm,vv in infeasible_neighbors.items():\n            if perm not in visited:\n                visited.add(perm)\n                neighbors_feasible_all.update({perm:vv for perm,vv in vv.neighbors_dict['all'].items() if vv.is_feasible})\n                neighbors_feasible_all, visited = extract_infeasible_neighbor(\n                  vv.neighbors_dict['all'],\n                  neighbors_feasible_all,\n                  visited\n                )\n      return neighbors_feasible_all, visited\n\n    # first, each neighbor that is feasible should be a neighbor under constraint.\n    neighbors_feasible_all = {perm:vv for perm,vv in self.neighbors_dict['all'].items() if vv.is_feasible}\n    visited = set()\n\n    neighbors_feasible_all,visited = extract_infeasible_neighbor(\n      self.neighbors_dict['all'],neighbors_feasible_all,visited\n    )\n    # Remove self from the neighbors' dictionaries if present\n    try:\n        del neighbors_feasible_all[self.perm]\n    except KeyError:\n        pass\n    neighbors_feasible_inf = {\n        perm:vv for perm,vv in neighbors_feasible_all.items() if vv.orientation==0\n        }\n    neighbors_feasible_fin = {\n        perm:vv for perm,vv in neighbors_feasible_all.items() if vv.orientation!=0\n        }\n    self.neighbors_constrained_dict={'finite':neighbors_feasible_fin,\n                                  'infinite':neighbors_feasible_inf,\n                                  'all':neighbors_feasible_all}\n\n  def vertex_c_mat_xak_calc(self):\n    # get the C matrix but for log(xa,k) coordinate\n    # store as self.c_mat_xak\n    try: c_mat_x=self.c_mat_x\n    except AttributeError:\n      self.vertex_c_mat_x_calc()\n      c_mat_x=self.c_mat_x\n    try: xak2x_map=self.bn.xak2x_map\n    except AttributeError:\n      self.bn.calc_xak2x_map()\n      xak2x_map=self.bn.xak2x_map\n    c_mat_xak=c_mat_x.dot(xak2x_map)\n    self.c_mat_xak=c_mat_xak\n\n  def vertex_c_mat_tk_calc(self):\n    # get the C matrix but for log(t,k) coordinate\n    # store as self.c_mat_tk\n    assert self.orientation!=0, \"only finite vertices can have non-singular (t,k) chart\"\n    try:\n      c_mat_x=self.c_mat_x\n    except AttributeError:\n      self.vertex_c_mat_x_calc()\n      c_mat_x=self.c_mat_x\n    # The equivalence here is the following:\n    # c_mat_tk @ log(t,k) + c0_vec_tk &gt;=0  &lt;=&gt;  c_mat_x @ logx + c0_vec &gt;=0\n    c_mat_tk=c_mat_x.dot(self.h_mat) #because h_mat*log(t,k)=log(x)\n    c0_vec_tk=self.c0_vec - c_mat_x.dot(self.h_mat.dot(self.m0_vec))\n    self.c_mat_tk=c_mat_tk\n    self.c0_vec_tk=c0_vec_tk\n\n  def chart_check(self,chart):\n    \"\"\"\n    Prepare the c_mat and c0_vec for the desired chart.\n\n    Args:\n        chart (str, optional): A string indicating the chart that the opt_constraints are specified in.\n            Choices are 'x','xak', and 'tk'.\n\n    Returns:\n        c_mat (ndarray, shape (n_constraints, n_var)): Matrix used in this vertex's feasibility condition in the \n            desired chart, e.g., it is c_mat * x + c0_vec &gt; 0 in chart 'x'.\n        c0_vec (ndarray, shape (n_constraints,)): The vector used in this vertex's feasibility condition in the\n            desired chart, e.g., it is c_mat * x + c0_vec &gt; 0 in chart 'x'.\n    \"\"\"\n    if chart=='x':\n      try:\n        c_mat=self.c_mat_x\n        c0_vec=self.c0_vec\n      except AttributeError: # if c_mat_x is not yet calculated\n        self.vertex_c_mat_x_calc()\n        c_mat=self.c_mat_x\n        c0_vec=self.c0_vec\n    elif chart=='xak':\n      try:\n        c_mat=self.c_mat_xak\n        c0_vec=self.c0_vec #c0_vec is the same for chart x and xak.\n      except AttributeError: # if c_mat_xak is not yet calculated\n        self.vertex_c_mat_xak_calc()\n        c_mat=self.c_mat_xak\n        c0_vec=self.c0_vec\n    elif chart=='tk':\n      try:\n        c_mat=self.c_mat_tk\n        c0_vec=self.c0_vec_tk\n      except AttributeError: # if c_mat_xak is not yet calculated\n        self.vertex_c_mat_tk_calc()\n        c_mat=self.c_mat_tk\n        c0_vec=self.c0_vec_tk\n    else:\n      raise Exception('chart that is not one of x,xak or tk is not implemented yet')\n    return c_mat,c0_vec\n\n  def vertex_hull_of_validity(self,chart='x',margin=0,logmin=-6,logmax=6,c_mat_extra=[],c0_vec_extra=[]):\n    \"\"\"\n    Compute the vertices of the validity region as a bounded convex hull.\n\n    Args:\n        chart (str, optional): A string indicating the chart that the opt_constraints are specified in.\n            Choices are 'x','xak', and 'tk'.\n        margin (float, optional): The vertex's feasibility conditions are inequalities, \n            of the form c_mat*x + c0_vec &gt;= margin (e.g., in 'x' chart),\n            Margin defaults to 0, and its values are in log10.\n            This can be adjusted to be stronger/weaker requirements on dominance.\n        logmin (float or ndarray vector): logmin, logmax could be scalars, then it's the same value applied to \n            every variable. \n            They could also be vectors of length dim_n.\n        logmax (float or ndarray vector): logmin, logmax could be scalars, then it's the same value applied to \n            every variable. \n            They could also be vectors of length dim_n.\n        c_mat_extra (ndarray, shape (n_constraints, n_var)): Extra optimization constraints to be added to feasibility conditions,\n            in the form of c_mat_extra @ var + c0_vec_extra &gt;= 0.\n        c0_vec_extra (numpy vector, shape (n_constraints,)): Extra optimization constraints to be added to feasibility conditions,\n            in the form of c_mat_extra @ var + c0_vec_extra &gt;=0.\n\n    Returns:\n        points (ndarray): The points corresponding to vertices of the convex hull that is the \n            region of validity.\n        feasible_point (ndarray vector): The point that is feasible in the interior of the convex hull.\n        hs (scipy.spatial.HalfspaceIntersection): The half space intersection built from the feasibility inequalities.\n    \"\"\"\n\n    # first check whether logmin and logmax are scalars or vectors.\n    try: \n      float(logmin) # if logmin and logmax are scalars\n      bbox = np.repeat(np.array([[logmin,logmax]]),self.bn.dim_n,axis=0) #bounding box to make polyhedra bounded\n    except TypeError: # if logmin and logmax are vectors\n      # stack them horizontally as column vectors\n      bbox = np.hstack((logmin[:,None],logmax[:,None]))\n\n    c_mat,c0_vec=self.chart_check(chart)\n\n    # the inequality c_mat*var + c0_vec - margin &gt;= 0, becomes A*var + b &lt;=0\n    # where A = -c_mat, and b = th - c0_vec.\n    # With extra constraints, margin is always 0 for extra constraints,\n    # so margin_full = vstack((margin,zeros)) where zeros is of length len(c0_vec_extra)\n    if np.any(c_mat_extra): # if there are additional constraints\n      c_mat_full=np.vstack((c_mat,c_mat_extra))\n      c0_vec_full=np.concatenate((c0_vec,c0_vec_extra))\n      margin_vec_full = np.concatenate((margin*np.ones(c0_vec.shape[0]),np.zeros(c0_vec_extra.shape[0])))\n    else: # there are no additional constraints\n      c_mat_full=c_mat \n      c0_vec_full = c0_vec\n      margin_vec_full = margin*np.ones(c0_vec.shape[0])\n    A=-c_mat_full # negtive because the optimization code is for Ax+b&lt;=0, while our notation is c_mat*x+c0_vec &gt;=0.\n    b=margin_vec_full - c0_vec_full\n\n    points, hull, feasible_point, hs = self.get_convex_hull(A,b,bbox)\n    return points, hull, feasible_point,hs\n\n  def __feasible_point_calc(self,A, b):\n    # Finds the center of the largest sphere fitting in the convex hull of\n    #   A x + b &lt;= 0.\n    # Use method in description of scipy.spatial.HalfspaceIntersection.\n    # Based on Chebyshev center finding of Boyd's book 4.3.1\n    # Needs to solve max y s.t. A x + y |A_i| + b &lt;= 0. A_i are rows of A,\n    #   so |A_i| is the norm vector of rows of A.\n    # We transform this inequality into min c*x, A_lp x &lt;= b_lp,\n    #   standard form of a linear program,\n    #   where c=(0,...,0,-1) so that c*x = x[-1] = y, and x[:-1] is x above,\n    #   A_lp = hstack(A,|A_i|). b_lp is the same as -b, but as a column vector.\n    norm_vector = np.linalg.norm(A, axis=1) # Frobenius norm\n    A_linprog = np.hstack((A, norm_vector[:, None])) \n    b_linprog = -b[:, None] # this makes b into shape len(b)-by-1.\n    c=np.zeros((A.shape[1] + 1,))\n    c[-1] = -1\n    res = linprog(c, A_ub=A_linprog, b_ub=b_linprog, bounds=(None, None))\n    if res.status!=0: breakpoint()\n    return res.x[:-1]\n\n  def __add_bbox(self,A, b, bbox):\n    # in case A x + b &lt;= 0 is not bounded, add a bounding box specified by bbox.\n    # bbox is an array, n-by-2, the ith row is (min,max) of x_i.\n    # Transform: bbox[i,0] is min, so x_i &gt;= bbox[i,0] becomes -x_i + bbox[i,0] &lt;=0.\n    #   This is encoded in A's entry is -I, and b's entry is bbox[i,0].\n    #   Similarly for max, A's entry is +I, and b's entry is -bbox[i,1].\n    dim_n=A.shape[1]\n    A_bounded=A\n    b_bounded=b\n    for i in range(dim_n):\n      A_bounded = np.vstack((A_bounded,-np.eye(1,dim_n,i),np.eye(1,dim_n,i)))\n      b_bounded = np.hstack((b_bounded,bbox[i,0],-bbox[i,1]))\n    return A_bounded, b_bounded   \n\n  def __hs_intersection(self,A, b, feasible_point):\n    # HalfspaceIntersection take the convention halfspaces=[A;b]\n    #   to indicate A x + b &lt;= 0.\n    halfspaces = np.hstack((A, b[:, None]))\n    # hs = HalfspaceIntersection(halfspaces, feasible_point,qhull_options='QJ') #QJ option to joggle to avoid non-full-dimensional constraints.\n    # Qt option to triangulate all the time to avoid precision issues.\n    # This is helpful to avoid problems since later on the \"ConvexHull\"\n    #   function uses this Qt option.\n    hs = HalfspaceIntersection(halfspaces, feasible_point,qhull_options='Qt') \n    return hs\n\n\n  def get_convex_hull(self,A_local, b_local, bbox):\n    # Given A,b for halfspace intersection A x + b &lt;=0,\n    #   and bounding box bbox,\n    #   get the vertices of the convex hull that formed.\n    # Modified from https://stackoverflow.com/questions/65343771/solve-linear-inequalities\n    A_bounded, b_bounded = self.__add_bbox(A_local, b_local, bbox)\n    feasible_point = self.__feasible_point_calc(A_bounded, b_bounded)\n    hs = self.__hs_intersection(A_bounded, b_bounded, feasible_point)\n    # hs = hs_intersection(A, b, interior_point)\n    points = hs.intersections\n    hull = ConvexHull(points,qhull_options='Q12') # to allow wide facets and dulbridge... meaning what???\n    return points,points[hull.vertices],feasible_point, hs\n\n\n  def vertex_hull_sampling(self,nsample,chart='x', margin=0,logmin=-6,logmax=6,c_mat_extra=[],c0_vec_extra=[]):\n    \"\"\"\n    Sample points in the vertex's region of validity based on its hull of feasible regions.\n    Extra conditions (linear) can be added as c_mat_extra @ var + c0_vec_extra &gt;= 0.\n\n    Args:\n        nsample (int): Number of points to be sampled.\n        chart (str, optional): A string indicating the chart that the opt_constraints are specified in.\n            Choices are 'x','xak', and 'tk'.\n        margin (float, optional): The vertex's feasibility conditions are inequalities, \n            of the form c_mat*x + c0_vec &gt;= margin (e.g., in 'x' chart),\n            where margin is the margin used here. Defaults to 0.\n            This can be adjusted to be stronger/weaker requirements on dominance.\n        logmin (float or ndarray vector): logmin, logmax could be scalars, then it's the same value applied to \n            every variable. \n            They could also be vectors of length dim_n.\n        logmax (float or ndarray vector): logmin, logmax could be scalars, then it's the same value applied to \n            every variable. \n            They could also is vectors of length dim_n.\n        c_mat_extra (ndarray, shape (n_constraints, n_var)): Extra optimization constraints to be added to feasibility conditions,\n            in the form of c_mat_extra @ var + c0_vec_extra &gt;= 0.\n        c0_vec_extra (numpy vector, shape (n_constraints,)): Extra optimization constraints to be added to feasibility conditions,\n            in the form of c_mat_extra @ var + c0_vec_extra &gt;=0.\n\n    Returns:\n        sample (ndarray of shape nsample-by-dim_n): dim_n is number of species in the binding network.\n            Sampled points satisfying the feasibility conditions of this vertex.\n            Each row (sample[i,:]) is a sampled point.\n    \"\"\"\n    # first compute the convex hull for this vertex's validity and get the vertex points.\n    points,hull,_,_=self.vertex_hull_of_validity(chart=chart,margin=margin,logmin=logmin,logmax=logmax,c_mat_extra=c_mat_extra,c0_vec_extra=c0_vec_extra)\n    sample=self.__dist_in_hull(points,nsample,points_are_vertices=False)\n    # To sample a simplex in n-dim uniformly, take n uniform(0,1) random \n    #   variables and take difference after padding 0 at the beginning and\n    #   1 at the end. This gives a vector of n-dim in the simplex, with\n    #   a probability density that is uniform in the simplex.\n    #   See https://cs.stackexchange.com/questions/3227/uniform-sampling-from-a-simplex\n    # ncoeffs=points.shape[0]\n    # temp=np.sort(np.random.rand(nsample,ncoeffs-1),axis=1)\n    # coeffs=np.diff(temp,prepend=0,append=1,axis=1)\n    # sample=coeffs@points # this has shape nsample-by-dim_n\n    return sample\n\n  def __dist_in_hull(self,points, nsample, points_are_vertices=False):\n    \"\"\"\n    Create uniform sample over convex hulls by Delaunay triangulation.\n    Adapted from https://stackoverflow.com/questions/59073952/how-to-get-uniformly-distributed-points-in-convex-hull\n\n    Args:\n        points (ndarray, shape (num_points, dim)): Points whose convex hull is to be sampled uniformly.\n        nsample (int): Number of points to be sampled.\n        points_are_vertices (bool, optional): If True, points are assumed to be vertices.\n            If False, convex hull of points is first taken to find vertices.\n            Defaults to False.\n\n    Returns:\n        sample (ndarray, shape (nsample, dim)): Sampled points uniformly in convex hull of points.\n    \"\"\"\n    dims = points.shape[-1]\n    if points_are_vertices:\n      hull=points \n    else: \n      hull = points[ConvexHull(points,qhull_options='Q12').vertices]\n    breakpoint()\n    deln = hull[Delaunay(hull,qhull_options='Q12').simplices]\n    vols = np.abs(np.linalg.det(deln[:, :dims, :] - deln[:, dims:, :])) / np.math.factorial(dims)    \n    sample = np.random.choice(len(vols), size = nsample, p = vols / vols.sum())\n    return np.einsum('ijk, ij -&gt; ik', deln[sample], dirichlet.rvs([1]*(dims + 1), size = nsample))\n\n  def vertex_print_validity_condition(self,is_asymptotic=False):\n    \"\"\"\n    Print the expression for t=x, x(t,k) and inequalities for the region of validity \n    given a regime, using the labels of x, t, k.\n\n    Args:\n        is_asymptotic (bool, optional): If False, the inequalities are shown with intercept.\n            If True, the inequalities are shown without intercept.\n\n    Returns:\n        None: Prints a lot of text.\n    \"\"\"\n    try:\n      c_mat=self.c_mat_tk\n      c0_vec=self.c0_vec_tk\n    except AttributeError: # if c_mat_xak is not yet calculated\n      self.vertex_c_mat_tk_calc()\n      c_mat=self.c_mat_tk\n      c0_vec=self.c0_vec_tk\n    h_mat=self.h_mat\n    h0_vec=self.h0_vec\n    p0_vec=self.p0_vec\n    perm=self.perm\n    x_sym=self.bn.x_sym\n    tk_sym=self.bn.tk_sym\n\n    print('======This is vertex perm '+str(perm)+'======\\n')\n    t2x_list=[]\n    for i in range(self.bn.dim_d):\n      p0=p0_vec[i]\n      if p0==1 or is_asymptotic:\n        t2x_list+=[tk_sym[i].name + '=' + x_sym[perm[i]].name]\n      else:\n        t2x_list+=[tk_sym[i].name + '=' + str(p0) + x_sym[perm[i]].name]\n    print('(1) t in x: t is dominated by... \\n'+ ','.join(t2x_list) + '\\n')\n\n    # BELOW we obtain x's expression in terms of t,k by\n    # log(x) = h_mat * log(t,k) + h0_vec\n\n    if self.orientation==0:\n      print('(2) x in tk: Vertex is singular, cannot express (x) in (t,k).')\n    else:\n      x2tk_list=[]\n      for i in range(self.bn.dim_n):\n        h_row=h_mat[i,:]\n        pos_idx=np.where(h_row&gt;0)[0]\n        neg_idx=np.where(h_row&lt;0)[0]\n        expr_pos=' '.join([tk_sym[j].name + '^' + str(h_row[j]) if h_row[j]!=1.0 else tk_sym[j].name for j in pos_idx])\n        expr_neg=' '.join([tk_sym[j].name + '^' + str(-h_row[j]) if -h_row[j]!=1.0 else tk_sym[j].name for j in neg_idx])\n        if neg_idx.size==0:\n          expr=expr_pos\n        else:\n          expr=expr_pos + ' / ' + expr_neg\n        h0=h0_vec[i]\n        if h0==0:\n          x2tk_list+=[x_sym[i].name + ' = '+ expr]\n        else:\n          x2tk_list+=[x_sym[i].name + ' = ' + expr + ' / '+str(10**h0)]\n      print('(2) x in tk: \\n'+',\\n'.join(x2tk_list) + '\\n')\n\n\n    ineq_list=[]\n    for i in range(c_mat.shape[0]):\n      c_row=c_mat[i,:]\n      pos_idx=np.where(c_row&gt;0)[0]\n      neg_idx=np.where(c_row&lt;0)[0]\n      expr_pos=' '.join([tk_sym[j].name + '^'+str(c_row[j]) if c_row[j]!=1.0 else tk_sym[j].name for j in pos_idx])\n      expr_neg=' '.join([tk_sym[j].name + '^'+str(-c_row[j]) if -c_row[j]!=1.0 else tk_sym[j].name for j in neg_idx])\n      c0=c0_vec[i]\n      if c0==0:\n        ineq_list+=[expr_pos + ' &gt; ' + expr_neg]\n      else:\n        ineq_list+=[expr_pos + ' &gt; ' + str(10**(-c0)) + ' ' + expr_neg]\n\n    print('(3) BELOW is constraints for regions of validity \\n'+',\\n'.join(ineq_list) + '\\n')\n</code></pre>"},{"location":"#bcn.binding_network.rop_vertex.__dist_in_hull","title":"<code>__dist_in_hull(points, nsample, points_are_vertices=False)</code>","text":"<p>Create uniform sample over convex hulls by Delaunay triangulation. Adapted from https://stackoverflow.com/questions/59073952/how-to-get-uniformly-distributed-points-in-convex-hull</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>ndarray, shape (num_points, dim</code> <p>Points whose convex hull is to be sampled uniformly.</p> required <code>nsample</code> <code>int</code> <p>Number of points to be sampled.</p> required <code>points_are_vertices</code> <code>bool</code> <p>If True, points are assumed to be vertices. If False, convex hull of points is first taken to find vertices. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>sample</code> <code>(ndarray, shape(nsample, dim))</code> <p>Sampled points uniformly in convex hull of points.</p> Source code in <code>src/bcn/binding_network.py</code> <pre><code>def __dist_in_hull(self,points, nsample, points_are_vertices=False):\n  \"\"\"\n  Create uniform sample over convex hulls by Delaunay triangulation.\n  Adapted from https://stackoverflow.com/questions/59073952/how-to-get-uniformly-distributed-points-in-convex-hull\n\n  Args:\n      points (ndarray, shape (num_points, dim)): Points whose convex hull is to be sampled uniformly.\n      nsample (int): Number of points to be sampled.\n      points_are_vertices (bool, optional): If True, points are assumed to be vertices.\n          If False, convex hull of points is first taken to find vertices.\n          Defaults to False.\n\n  Returns:\n      sample (ndarray, shape (nsample, dim)): Sampled points uniformly in convex hull of points.\n  \"\"\"\n  dims = points.shape[-1]\n  if points_are_vertices:\n    hull=points \n  else: \n    hull = points[ConvexHull(points,qhull_options='Q12').vertices]\n  breakpoint()\n  deln = hull[Delaunay(hull,qhull_options='Q12').simplices]\n  vols = np.abs(np.linalg.det(deln[:, :dims, :] - deln[:, dims:, :])) / np.math.factorial(dims)    \n  sample = np.random.choice(len(vols), size = nsample, p = vols / vols.sum())\n  return np.einsum('ijk, ij -&gt; ik', deln[sample], dirichlet.rvs([1]*(dims + 1), size = nsample))\n</code></pre>"},{"location":"#bcn.binding_network.rop_vertex.__init__","title":"<code>__init__(perm, bn)</code>","text":"<p>Initiates a ROP vertex.</p> <p>Parameters:</p> Name Type Description Default <code>perm</code> <code>int tuple</code> <p>An integer tuple of length dim_d, indicating for each conserved quantity,  which species is dominant.</p> required <code>bn</code> <code>binding_network object</code> <p>The binding network that this vertex is a part of. Used to get dimensions and stoichiometry matrix.</p> required Source code in <code>src/bcn/binding_network.py</code> <pre><code>def __init__(self,perm,bn):\n  \"\"\"\n  Initiates a ROP vertex.\n\n  Args:\n      perm (int tuple): An integer tuple of length dim_d, indicating for each conserved quantity, \n          which species is dominant.\n      bn (binding_network object): The binding network that this vertex is a part of.\n          Used to get dimensions and stoichiometry matrix.\n  \"\"\"\n  self.perm=perm\n  self.bn=bn\n  p_mat=np.zeros((bn.dim_d,bn.dim_n)) # p_mat is all 0 and 1\n  p0_vec=np.zeros(bn.dim_d) # the value of nonzero entries of l_mat chosen by p_mat in each row for this vertex\n  for i in range(bn.dim_d):\n    p_mat[i,perm[i]]=1\n    p0_vec[i]=np.log10(bn.l_mat[i,perm[i]])\n  self.p_mat=p_mat\n  self.p0_vec=p0_vec\n  self.m_mat=np.concatenate((self.p_mat,self.bn.n_mat),axis=0)\n  self.m0_vec=np.concatenate((self.p0_vec,np.zeros(self.bn.dim_r)),axis=0)\n  self.orientation=np.sign(np.linalg.det(self.m_mat))\n  self.is_feasible=True\n</code></pre>"},{"location":"#bcn.binding_network.rop_vertex.chart_check","title":"<code>chart_check(chart)</code>","text":"<p>Prepare the c_mat and c0_vec for the desired chart.</p> <p>Parameters:</p> Name Type Description Default <code>chart</code> <code>str</code> <p>A string indicating the chart that the opt_constraints are specified in. Choices are 'x','xak', and 'tk'.</p> required <p>Returns:</p> Name Type Description <code>c_mat</code> <code>(ndarray, shape(n_constraints, n_var))</code> <p>Matrix used in this vertex's feasibility condition in the  desired chart, e.g., it is c_mat * x + c0_vec &gt; 0 in chart 'x'.</p> <code>c0_vec</code> <code>(ndarray, shape(n_constraints))</code> <p>The vector used in this vertex's feasibility condition in the desired chart, e.g., it is c_mat * x + c0_vec &gt; 0 in chart 'x'.</p> Source code in <code>src/bcn/binding_network.py</code> <pre><code>def chart_check(self,chart):\n  \"\"\"\n  Prepare the c_mat and c0_vec for the desired chart.\n\n  Args:\n      chart (str, optional): A string indicating the chart that the opt_constraints are specified in.\n          Choices are 'x','xak', and 'tk'.\n\n  Returns:\n      c_mat (ndarray, shape (n_constraints, n_var)): Matrix used in this vertex's feasibility condition in the \n          desired chart, e.g., it is c_mat * x + c0_vec &gt; 0 in chart 'x'.\n      c0_vec (ndarray, shape (n_constraints,)): The vector used in this vertex's feasibility condition in the\n          desired chart, e.g., it is c_mat * x + c0_vec &gt; 0 in chart 'x'.\n  \"\"\"\n  if chart=='x':\n    try:\n      c_mat=self.c_mat_x\n      c0_vec=self.c0_vec\n    except AttributeError: # if c_mat_x is not yet calculated\n      self.vertex_c_mat_x_calc()\n      c_mat=self.c_mat_x\n      c0_vec=self.c0_vec\n  elif chart=='xak':\n    try:\n      c_mat=self.c_mat_xak\n      c0_vec=self.c0_vec #c0_vec is the same for chart x and xak.\n    except AttributeError: # if c_mat_xak is not yet calculated\n      self.vertex_c_mat_xak_calc()\n      c_mat=self.c_mat_xak\n      c0_vec=self.c0_vec\n  elif chart=='tk':\n    try:\n      c_mat=self.c_mat_tk\n      c0_vec=self.c0_vec_tk\n    except AttributeError: # if c_mat_xak is not yet calculated\n      self.vertex_c_mat_tk_calc()\n      c_mat=self.c_mat_tk\n      c0_vec=self.c0_vec_tk\n  else:\n    raise Exception('chart that is not one of x,xak or tk is not implemented yet')\n  return c_mat,c0_vec\n</code></pre>"},{"location":"#bcn.binding_network.rop_vertex.j_func","title":"<code>j_func(p_mat, l_mat)</code>","text":"<p>For p_mat and l_mat, find (column) indices that are nonzero in each row of l_mat but not nonzero in p_mat.</p> <p>Parameters:</p> Name Type Description Default <code>p_mat</code> <code>numpy array</code> <p>d-by-n matrix, each row has only one nonzero entry that is 1.</p> required <code>l_mat</code> <code>numpy array</code> <p>d-by-n matrix, binding network's conservation law matrix.</p> required <p>Returns:</p> Name Type Description <code>j_list</code> <code>list of int</code> <p>List of (column) indices that are nonzero in l_mat but zero in p_mat.</p> Source code in <code>src/bcn/binding_network.py</code> <pre><code>def j_func(self,p_mat,l_mat):\n  \"\"\"\n  For p_mat and l_mat, find (column) indices that are nonzero in each row of\n  l_mat but not nonzero in p_mat.\n\n  Args:\n      p_mat (numpy array): d-by-n matrix, each row has only one nonzero entry that is 1.\n      l_mat (numpy array): d-by-n matrix, binding network's conservation law matrix.\n\n  Returns:\n      j_list (list of int): List of (column) indices that are nonzero in l_mat but zero in p_mat.\n  \"\"\"\n  j_list=[]\n  l_mat_masked=np.ma.array(l_mat,mask=p_mat).filled(fill_value=0)\n  for i in range(p_mat.shape[0]):\n    j_list+=[np.nonzero(l_mat_masked[i,:])[0]]\n  return j_list\n</code></pre>"},{"location":"#bcn.binding_network.rop_vertex.vertex_feasibility_test","title":"<code>vertex_feasibility_test(chart='x', opt_constraints=[], positive_threshold=1e-05, is_asymptotic=True)</code>","text":"<p>For given constraints, compute whether this vertex is feasible.</p> <p>Parameters:</p> Name Type Description Default <code>chart</code> <code>str</code> <p>A string indicating the chart that the opt_constraints are specified in. Choices are 'x','xak', and 'tk'.</p> <code>'x'</code> <code>opt_constraints</code> <code>list of cvxpy inequalities</code> <p>A list of optimization constraints specified in terms of inequalities relating cvxpy variables of the binding network.</p> <code>[]</code> <code>positive_threshold</code> <code>float</code> <p>The vertex itself has inequality conditions, of the form c_mat*x + c0_vec &gt; th, where th is the positive threshold used here. Defaults to 1e-5.</p> <code>1e-05</code> <code>is_asymptotic</code> <code>bool</code> <p>Whether the inequalities of the vertex itself should be considered asymptotically or exactly. If asymptotically, then the inequality tested omits c0_vec, so it is c_mat*x &gt; th. is_asymptotic=True corresponds to inequality satisfied for the positive projective measure (where a ray is an infinitesimal of volume), and is_asymptotic=False is Lebesgue measure (a point is an infinitesimal of volume).</p> <code>True</code> <p>Returns:</p> Name Type Description <code>is_feasible</code> <code>bool</code> <p>Whether this vertex is feasible under the constraints.</p> Source code in <code>src/bcn/binding_network.py</code> <pre><code>def vertex_feasibility_test(self,chart='x',opt_constraints=[],positive_threshold=1e-5,is_asymptotic=True):\n  \"\"\"\n  For given constraints, compute whether this vertex is feasible.\n\n  Args:\n      chart (str, optional): A string indicating the chart that the opt_constraints are specified in.\n          Choices are 'x','xak', and 'tk'.\n      opt_constraints (list of cvxpy inequalities, optional): A list of optimization constraints specified in terms of inequalities\n          relating cvxpy variables of the binding network.\n      positive_threshold (float, optional): The vertex itself has inequality conditions, of the form c_mat*x + c0_vec &gt; th,\n          where th is the positive threshold used here. Defaults to 1e-5.\n      is_asymptotic (bool, optional): Whether the inequalities of the vertex itself should be considered asymptotically\n          or exactly. If asymptotically, then the inequality tested omits c0_vec,\n          so it is c_mat*x &gt; th. is_asymptotic=True corresponds to inequality satisfied\n          for the positive projective measure (where a ray is an infinitesimal of volume),\n          and is_asymptotic=False is Lebesgue measure (a point is an infinitesimal of volume).\n\n  Returns:\n      is_feasible (bool): Whether this vertex is feasible under the constraints.\n  \"\"\"\n  # first prepare the c_mat and c0_vec for the desired chart.\n  c_mat,c0_vec=self.chart_check(chart)\n  is_feasible=True\n  opt_var=self.bn.opt_var #opt_var came from the binding network.\n  if is_asymptotic: #if asymptotic, c0_vec is zero.\n    prob=cp.Problem(cp.Minimize(1),opt_constraints+[c_mat @ opt_var &gt;= positive_threshold])\n  else: # if not asymptotic, it is exact, so c0_vec is taken into account.\n    prob=cp.Problem(cp.Minimize(1),opt_constraints+[c_mat @ opt_var + c0_vec &gt;= positive_threshold])\n  prob.solve()\n  if prob.status=='infeasible':\n    is_feasible=False\n  return is_feasible\n</code></pre>"},{"location":"#bcn.binding_network.rop_vertex.vertex_hull_of_validity","title":"<code>vertex_hull_of_validity(chart='x', margin=0, logmin=-6, logmax=6, c_mat_extra=[], c0_vec_extra=[])</code>","text":"<p>Compute the vertices of the validity region as a bounded convex hull.</p> <p>Parameters:</p> Name Type Description Default <code>chart</code> <code>str</code> <p>A string indicating the chart that the opt_constraints are specified in. Choices are 'x','xak', and 'tk'.</p> <code>'x'</code> <code>margin</code> <code>float</code> <p>The vertex's feasibility conditions are inequalities,  of the form c_mat*x + c0_vec &gt;= margin (e.g., in 'x' chart), Margin defaults to 0, and its values are in log10. This can be adjusted to be stronger/weaker requirements on dominance.</p> <code>0</code> <code>logmin</code> <code>float or ndarray vector</code> <p>logmin, logmax could be scalars, then it's the same value applied to  every variable.  They could also be vectors of length dim_n.</p> <code>-6</code> <code>logmax</code> <code>float or ndarray vector</code> <p>logmin, logmax could be scalars, then it's the same value applied to  every variable.  They could also be vectors of length dim_n.</p> <code>6</code> <code>c_mat_extra</code> <code>ndarray, shape (n_constraints, n_var</code> <p>Extra optimization constraints to be added to feasibility conditions, in the form of c_mat_extra @ var + c0_vec_extra &gt;= 0.</p> <code>[]</code> <code>c0_vec_extra</code> <code>numpy vector, shape (n_constraints,</code> <p>Extra optimization constraints to be added to feasibility conditions, in the form of c_mat_extra @ var + c0_vec_extra &gt;=0.</p> <code>[]</code> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>The points corresponding to vertices of the convex hull that is the  region of validity.</p> <code>feasible_point</code> <code>ndarray vector</code> <p>The point that is feasible in the interior of the convex hull.</p> <code>hs</code> <code>HalfspaceIntersection</code> <p>The half space intersection built from the feasibility inequalities.</p> Source code in <code>src/bcn/binding_network.py</code> <pre><code>def vertex_hull_of_validity(self,chart='x',margin=0,logmin=-6,logmax=6,c_mat_extra=[],c0_vec_extra=[]):\n  \"\"\"\n  Compute the vertices of the validity region as a bounded convex hull.\n\n  Args:\n      chart (str, optional): A string indicating the chart that the opt_constraints are specified in.\n          Choices are 'x','xak', and 'tk'.\n      margin (float, optional): The vertex's feasibility conditions are inequalities, \n          of the form c_mat*x + c0_vec &gt;= margin (e.g., in 'x' chart),\n          Margin defaults to 0, and its values are in log10.\n          This can be adjusted to be stronger/weaker requirements on dominance.\n      logmin (float or ndarray vector): logmin, logmax could be scalars, then it's the same value applied to \n          every variable. \n          They could also be vectors of length dim_n.\n      logmax (float or ndarray vector): logmin, logmax could be scalars, then it's the same value applied to \n          every variable. \n          They could also be vectors of length dim_n.\n      c_mat_extra (ndarray, shape (n_constraints, n_var)): Extra optimization constraints to be added to feasibility conditions,\n          in the form of c_mat_extra @ var + c0_vec_extra &gt;= 0.\n      c0_vec_extra (numpy vector, shape (n_constraints,)): Extra optimization constraints to be added to feasibility conditions,\n          in the form of c_mat_extra @ var + c0_vec_extra &gt;=0.\n\n  Returns:\n      points (ndarray): The points corresponding to vertices of the convex hull that is the \n          region of validity.\n      feasible_point (ndarray vector): The point that is feasible in the interior of the convex hull.\n      hs (scipy.spatial.HalfspaceIntersection): The half space intersection built from the feasibility inequalities.\n  \"\"\"\n\n  # first check whether logmin and logmax are scalars or vectors.\n  try: \n    float(logmin) # if logmin and logmax are scalars\n    bbox = np.repeat(np.array([[logmin,logmax]]),self.bn.dim_n,axis=0) #bounding box to make polyhedra bounded\n  except TypeError: # if logmin and logmax are vectors\n    # stack them horizontally as column vectors\n    bbox = np.hstack((logmin[:,None],logmax[:,None]))\n\n  c_mat,c0_vec=self.chart_check(chart)\n\n  # the inequality c_mat*var + c0_vec - margin &gt;= 0, becomes A*var + b &lt;=0\n  # where A = -c_mat, and b = th - c0_vec.\n  # With extra constraints, margin is always 0 for extra constraints,\n  # so margin_full = vstack((margin,zeros)) where zeros is of length len(c0_vec_extra)\n  if np.any(c_mat_extra): # if there are additional constraints\n    c_mat_full=np.vstack((c_mat,c_mat_extra))\n    c0_vec_full=np.concatenate((c0_vec,c0_vec_extra))\n    margin_vec_full = np.concatenate((margin*np.ones(c0_vec.shape[0]),np.zeros(c0_vec_extra.shape[0])))\n  else: # there are no additional constraints\n    c_mat_full=c_mat \n    c0_vec_full = c0_vec\n    margin_vec_full = margin*np.ones(c0_vec.shape[0])\n  A=-c_mat_full # negtive because the optimization code is for Ax+b&lt;=0, while our notation is c_mat*x+c0_vec &gt;=0.\n  b=margin_vec_full - c0_vec_full\n\n  points, hull, feasible_point, hs = self.get_convex_hull(A,b,bbox)\n  return points, hull, feasible_point,hs\n</code></pre>"},{"location":"#bcn.binding_network.rop_vertex.vertex_hull_sampling","title":"<code>vertex_hull_sampling(nsample, chart='x', margin=0, logmin=-6, logmax=6, c_mat_extra=[], c0_vec_extra=[])</code>","text":"<p>Sample points in the vertex's region of validity based on its hull of feasible regions. Extra conditions (linear) can be added as c_mat_extra @ var + c0_vec_extra &gt;= 0.</p> <p>Parameters:</p> Name Type Description Default <code>nsample</code> <code>int</code> <p>Number of points to be sampled.</p> required <code>chart</code> <code>str</code> <p>A string indicating the chart that the opt_constraints are specified in. Choices are 'x','xak', and 'tk'.</p> <code>'x'</code> <code>margin</code> <code>float</code> <p>The vertex's feasibility conditions are inequalities,  of the form c_mat*x + c0_vec &gt;= margin (e.g., in 'x' chart), where margin is the margin used here. Defaults to 0. This can be adjusted to be stronger/weaker requirements on dominance.</p> <code>0</code> <code>logmin</code> <code>float or ndarray vector</code> <p>logmin, logmax could be scalars, then it's the same value applied to  every variable.  They could also be vectors of length dim_n.</p> <code>-6</code> <code>logmax</code> <code>float or ndarray vector</code> <p>logmin, logmax could be scalars, then it's the same value applied to  every variable.  They could also is vectors of length dim_n.</p> <code>6</code> <code>c_mat_extra</code> <code>ndarray, shape (n_constraints, n_var</code> <p>Extra optimization constraints to be added to feasibility conditions, in the form of c_mat_extra @ var + c0_vec_extra &gt;= 0.</p> <code>[]</code> <code>c0_vec_extra</code> <code>numpy vector, shape (n_constraints,</code> <p>Extra optimization constraints to be added to feasibility conditions, in the form of c_mat_extra @ var + c0_vec_extra &gt;=0.</p> <code>[]</code> <p>Returns:</p> Name Type Description <code>sample</code> <code>ndarray of shape nsample-by-dim_n</code> <p>dim_n is number of species in the binding network. Sampled points satisfying the feasibility conditions of this vertex. Each row (sample[i,:]) is a sampled point.</p> Source code in <code>src/bcn/binding_network.py</code> <pre><code>def vertex_hull_sampling(self,nsample,chart='x', margin=0,logmin=-6,logmax=6,c_mat_extra=[],c0_vec_extra=[]):\n  \"\"\"\n  Sample points in the vertex's region of validity based on its hull of feasible regions.\n  Extra conditions (linear) can be added as c_mat_extra @ var + c0_vec_extra &gt;= 0.\n\n  Args:\n      nsample (int): Number of points to be sampled.\n      chart (str, optional): A string indicating the chart that the opt_constraints are specified in.\n          Choices are 'x','xak', and 'tk'.\n      margin (float, optional): The vertex's feasibility conditions are inequalities, \n          of the form c_mat*x + c0_vec &gt;= margin (e.g., in 'x' chart),\n          where margin is the margin used here. Defaults to 0.\n          This can be adjusted to be stronger/weaker requirements on dominance.\n      logmin (float or ndarray vector): logmin, logmax could be scalars, then it's the same value applied to \n          every variable. \n          They could also be vectors of length dim_n.\n      logmax (float or ndarray vector): logmin, logmax could be scalars, then it's the same value applied to \n          every variable. \n          They could also is vectors of length dim_n.\n      c_mat_extra (ndarray, shape (n_constraints, n_var)): Extra optimization constraints to be added to feasibility conditions,\n          in the form of c_mat_extra @ var + c0_vec_extra &gt;= 0.\n      c0_vec_extra (numpy vector, shape (n_constraints,)): Extra optimization constraints to be added to feasibility conditions,\n          in the form of c_mat_extra @ var + c0_vec_extra &gt;=0.\n\n  Returns:\n      sample (ndarray of shape nsample-by-dim_n): dim_n is number of species in the binding network.\n          Sampled points satisfying the feasibility conditions of this vertex.\n          Each row (sample[i,:]) is a sampled point.\n  \"\"\"\n  # first compute the convex hull for this vertex's validity and get the vertex points.\n  points,hull,_,_=self.vertex_hull_of_validity(chart=chart,margin=margin,logmin=logmin,logmax=logmax,c_mat_extra=c_mat_extra,c0_vec_extra=c0_vec_extra)\n  sample=self.__dist_in_hull(points,nsample,points_are_vertices=False)\n  # To sample a simplex in n-dim uniformly, take n uniform(0,1) random \n  #   variables and take difference after padding 0 at the beginning and\n  #   1 at the end. This gives a vector of n-dim in the simplex, with\n  #   a probability density that is uniform in the simplex.\n  #   See https://cs.stackexchange.com/questions/3227/uniform-sampling-from-a-simplex\n  # ncoeffs=points.shape[0]\n  # temp=np.sort(np.random.rand(nsample,ncoeffs-1),axis=1)\n  # coeffs=np.diff(temp,prepend=0,append=1,axis=1)\n  # sample=coeffs@points # this has shape nsample-by-dim_n\n  return sample\n</code></pre>"},{"location":"#bcn.binding_network.rop_vertex.vertex_print_validity_condition","title":"<code>vertex_print_validity_condition(is_asymptotic=False)</code>","text":"<p>Print the expression for t=x, x(t,k) and inequalities for the region of validity  given a regime, using the labels of x, t, k.</p> <p>Parameters:</p> Name Type Description Default <code>is_asymptotic</code> <code>bool</code> <p>If False, the inequalities are shown with intercept. If True, the inequalities are shown without intercept.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>None</code> <p>Prints a lot of text.</p> Source code in <code>src/bcn/binding_network.py</code> <pre><code>def vertex_print_validity_condition(self,is_asymptotic=False):\n  \"\"\"\n  Print the expression for t=x, x(t,k) and inequalities for the region of validity \n  given a regime, using the labels of x, t, k.\n\n  Args:\n      is_asymptotic (bool, optional): If False, the inequalities are shown with intercept.\n          If True, the inequalities are shown without intercept.\n\n  Returns:\n      None: Prints a lot of text.\n  \"\"\"\n  try:\n    c_mat=self.c_mat_tk\n    c0_vec=self.c0_vec_tk\n  except AttributeError: # if c_mat_xak is not yet calculated\n    self.vertex_c_mat_tk_calc()\n    c_mat=self.c_mat_tk\n    c0_vec=self.c0_vec_tk\n  h_mat=self.h_mat\n  h0_vec=self.h0_vec\n  p0_vec=self.p0_vec\n  perm=self.perm\n  x_sym=self.bn.x_sym\n  tk_sym=self.bn.tk_sym\n\n  print('======This is vertex perm '+str(perm)+'======\\n')\n  t2x_list=[]\n  for i in range(self.bn.dim_d):\n    p0=p0_vec[i]\n    if p0==1 or is_asymptotic:\n      t2x_list+=[tk_sym[i].name + '=' + x_sym[perm[i]].name]\n    else:\n      t2x_list+=[tk_sym[i].name + '=' + str(p0) + x_sym[perm[i]].name]\n  print('(1) t in x: t is dominated by... \\n'+ ','.join(t2x_list) + '\\n')\n\n  # BELOW we obtain x's expression in terms of t,k by\n  # log(x) = h_mat * log(t,k) + h0_vec\n\n  if self.orientation==0:\n    print('(2) x in tk: Vertex is singular, cannot express (x) in (t,k).')\n  else:\n    x2tk_list=[]\n    for i in range(self.bn.dim_n):\n      h_row=h_mat[i,:]\n      pos_idx=np.where(h_row&gt;0)[0]\n      neg_idx=np.where(h_row&lt;0)[0]\n      expr_pos=' '.join([tk_sym[j].name + '^' + str(h_row[j]) if h_row[j]!=1.0 else tk_sym[j].name for j in pos_idx])\n      expr_neg=' '.join([tk_sym[j].name + '^' + str(-h_row[j]) if -h_row[j]!=1.0 else tk_sym[j].name for j in neg_idx])\n      if neg_idx.size==0:\n        expr=expr_pos\n      else:\n        expr=expr_pos + ' / ' + expr_neg\n      h0=h0_vec[i]\n      if h0==0:\n        x2tk_list+=[x_sym[i].name + ' = '+ expr]\n      else:\n        x2tk_list+=[x_sym[i].name + ' = ' + expr + ' / '+str(10**h0)]\n    print('(2) x in tk: \\n'+',\\n'.join(x2tk_list) + '\\n')\n\n\n  ineq_list=[]\n  for i in range(c_mat.shape[0]):\n    c_row=c_mat[i,:]\n    pos_idx=np.where(c_row&gt;0)[0]\n    neg_idx=np.where(c_row&lt;0)[0]\n    expr_pos=' '.join([tk_sym[j].name + '^'+str(c_row[j]) if c_row[j]!=1.0 else tk_sym[j].name for j in pos_idx])\n    expr_neg=' '.join([tk_sym[j].name + '^'+str(-c_row[j]) if -c_row[j]!=1.0 else tk_sym[j].name for j in neg_idx])\n    c0=c0_vec[i]\n    if c0==0:\n      ineq_list+=[expr_pos + ' &gt; ' + expr_neg]\n    else:\n      ineq_list+=[expr_pos + ' &gt; ' + str(10**(-c0)) + ' ' + expr_neg]\n\n  print('(3) BELOW is constraints for regions of validity \\n'+',\\n'.join(ineq_list) + '\\n')\n</code></pre>"},{"location":"#bcn.catalysis_network.binding_and_catalysis","title":"<code>binding_and_catalysis</code>","text":"Source code in <code>src/bcn/catalysis_network.py</code> <pre><code>class binding_and_catalysis:\n  def __init__(self,bn,cn,kbind,kcat,total_const,total_const_idx,xcat_in_total_idx,cat_active_in_xbind_idx):\n    \"\"\"\n    Initiate a binding_and_catalysis object, which contains a binding network and a catalysis network, together with links between them.\n    On the catalysis time scale, the binding constants kbind don't change.\n\n    Args:\n        bn (binding_network object): The binding network that specifies how the catalysis fluxes are regulated.\n            It defines the map from xcat (catalysis variables) to concentrations of catalytic active species responsible for the catalysis fluxes.\n            Flux v = kcat * cat_active.\n            It has to contain all the catalytic active species of the catalysis reactions, even if there are reactions that have constant rates. (That corresponds to a binding reaction that is just one atomic entry with constant total.)\n        cn (catalysis_network object): The catalysis network that specifies how the fluxes change molecular concentrations.\n        xcat_in_total_idx (tuple of integers): Indices for xcat as totals in the binding network bn. Length is &lt;= self.dim_ncat.\n            Length could be less than self.dim_ncat, since not necessarily all xcat are contained in totals.\n            The xcat contained in totals NEED TO COME FIRST in the ordering of xcat.\n            xcat = np.concatenate((total[xcat_in_total_idx], xcat[...])).\n        cat_active_in_xbind_idx (tuple of integers): Indices that the active species for the catalysis reactions correspond to in the xbind species in the binding network bn. Length is self.dim_mcat.\n    \"\"\"\n    self.bn=bn\n    self.kbind=kbind # binding network's binding constants are fixed at the catalysis timescale\n    self.kcat=kcat\n    self.logkbind=np.log10(kbind)\n    self.total_const=total_const\n    self.logtotal_const=np.log10(total_const)\n    self.total_const_idx=total_const_idx\n    self.cn=cn\n    self.xcat_in_total_idx=xcat_in_total_idx\n    self.cat_active_in_xbind_idx=cat_active_in_xbind_idx\n\n    # # Extend cn.s_mat to shape bn.dim_d by cn.dim_mcat so that the dynamics for\n    # #   every total in the binding networks is contained.\n    # # These extra totals don't change, so their rows of s_mat are simply zeros.\n    # self.s_mat_total=np.zeros((bn.dim_d,cn.dim_mcat))\n    # self.s_mat_total[cn.xcat_in_total_idx,:]=cn.s_mat\n    # MAYBE, no need to extend. Since all totals that are changed in the catalysis\n    #   time scale are already contained in xcat. If they are not contained, then\n    #   they don't change, so they can be plugged in as just a parameter.\n\n  def dlogxcatdt(self,logxcat,a_mat):\n    \"\"\"\n    Calculate dlogxcat/dt for at a given logxcat point.\n\n    Args:\n        logxcat (numpy array): The vector of xcat in log10 indicating the current state of catalysis dynamics. Length is dim_ncat.\n            Entries of xcat corresponding to totals in the binding network need to come first.\n        a_mat (numpy array): Matrix defining totals in terms of xbind in the binding network. Shape is (bn.dim_d, bn.dim_n).\n            Correspond to conserved quantities at the binding timescale.\n            The default choice should be bn.l_mat.\n            Can be modified from bn.l_mat to describe restrictions or asymptotic limits of the system.\n    \"\"\"\n    cn=self.cn\n    bn=self.bn\n    logtk=np.zeros(bn.dim_n)\n    n_contained=len(self.xcat_in_total_idx)\n    logtk[self.xcat_in_total_idx]=logxcat[:n_contained] # totals come first in logtk\n    #   and only n_contained number of xcat are contained in totals.\n    # Then the last r are kbin.\n    logtk[self.total_const_idx]=self.logtotal_const\n    # IS IT TRUE that all totals are contained in xcat? No. Some are constant...\n    logtk[bn.dim_d:]=self.logkbind\n    logxbind=bn.tk2x_num(logtk, a_mat=a_mat)\n    # print('logxbind', logxbind)\n    vcat=self.kcat.T @ 10**logxbind[self.cat_active_in_xbind_idx]  # 2024/08/08 added transposition of kcat\n    vcat = np.expand_dims(vcat, axis=0)  # 2024/08/08 added\n    new_logxcat = (cn.s_mat@vcat) / 10**logxcat / np.log(10) # divide by xcat so that this kinetics of logxcat.\n    return new_logxcat\n\n  def get_traj(self,logxcat_init,t_init,t_end,npts,a_mat=np.array([]),get_logder_xbind=True):\n    if not np.any(a_mat): #if a_mat is not specified, use l_mat by default.\n      a_mat=self.bn.l_mat\n    func_int=lambda t,y:self.dlogxcatdt(y,a_mat)\n    y0=logxcat_init\n    t_span=(t_init,t_end)\n    t_eval=np.linspace(t_init,t_end,npts)\n\n    def events(t, y):\n      return y[0] &gt; -10  # S in solution less than 1e-8 is not considable.\n\n    events.terminal = True\n\n    sol=solve_ivp(func_int,t_span,y0,t_eval=t_eval, events=events, method='BDF')  # BDF more suitalbe for stiff ODE\n    logxcat_traj=sol.y.T # transpose so time points come in the first dim.\n\n    if get_logder_xbind:\n      logder_traj,logxbind_traj=self.get_logder_xbind_from_traj(logxcat_traj,a_mat=a_mat)\n      return sol.t,logxcat_traj,logxbind_traj,logder_traj\n    else:\n      return sol.t,logxcat_traj\n\n  def get_logder_xbind_from_traj(self,logxcat_traj,a_mat=np.array([])):\n    if not np.any(a_mat): #if a_mat is not specified, use l_mat by default.\n      a_mat=self.bn.l_mat\n    cn=self.cn\n    bn=self.bn\n    npts=logxcat_traj.shape[0]\n    logtk_traj=np.zeros((npts,bn.dim_n))\n    n_contained=len(self.xcat_in_total_idx)\n    logtk_traj[:,self.xcat_in_total_idx]=logxcat_traj[:,:n_contained] # totals come first in logtk\n    logtk_traj[:,self.total_const_idx]=self.logtotal_const\n    logtk_traj[:,bn.dim_d:]=self.logkbind\n    logder_traj,logxbind_traj=bn.logder_num(logtk_traj,chart='tk')\n    return logder_traj,logxbind_traj\n</code></pre>"},{"location":"#bcn.catalysis_network.binding_and_catalysis.__init__","title":"<code>__init__(bn, cn, kbind, kcat, total_const, total_const_idx, xcat_in_total_idx, cat_active_in_xbind_idx)</code>","text":"<p>Initiate a binding_and_catalysis object, which contains a binding network and a catalysis network, together with links between them. On the catalysis time scale, the binding constants kbind don't change.</p> <p>Parameters:</p> Name Type Description Default <code>bn</code> <code>binding_network object</code> <p>The binding network that specifies how the catalysis fluxes are regulated. It defines the map from xcat (catalysis variables) to concentrations of catalytic active species responsible for the catalysis fluxes. Flux v = kcat * cat_active. It has to contain all the catalytic active species of the catalysis reactions, even if there are reactions that have constant rates. (That corresponds to a binding reaction that is just one atomic entry with constant total.)</p> required <code>cn</code> <code>catalysis_network object</code> <p>The catalysis network that specifies how the fluxes change molecular concentrations.</p> required <code>xcat_in_total_idx</code> <code>tuple of integers</code> <p>Indices for xcat as totals in the binding network bn. Length is &lt;= self.dim_ncat. Length could be less than self.dim_ncat, since not necessarily all xcat are contained in totals. The xcat contained in totals NEED TO COME FIRST in the ordering of xcat. xcat = np.concatenate((total[xcat_in_total_idx], xcat[...])).</p> required <code>cat_active_in_xbind_idx</code> <code>tuple of integers</code> <p>Indices that the active species for the catalysis reactions correspond to in the xbind species in the binding network bn. Length is self.dim_mcat.</p> required Source code in <code>src/bcn/catalysis_network.py</code> <pre><code>def __init__(self,bn,cn,kbind,kcat,total_const,total_const_idx,xcat_in_total_idx,cat_active_in_xbind_idx):\n  \"\"\"\n  Initiate a binding_and_catalysis object, which contains a binding network and a catalysis network, together with links between them.\n  On the catalysis time scale, the binding constants kbind don't change.\n\n  Args:\n      bn (binding_network object): The binding network that specifies how the catalysis fluxes are regulated.\n          It defines the map from xcat (catalysis variables) to concentrations of catalytic active species responsible for the catalysis fluxes.\n          Flux v = kcat * cat_active.\n          It has to contain all the catalytic active species of the catalysis reactions, even if there are reactions that have constant rates. (That corresponds to a binding reaction that is just one atomic entry with constant total.)\n      cn (catalysis_network object): The catalysis network that specifies how the fluxes change molecular concentrations.\n      xcat_in_total_idx (tuple of integers): Indices for xcat as totals in the binding network bn. Length is &lt;= self.dim_ncat.\n          Length could be less than self.dim_ncat, since not necessarily all xcat are contained in totals.\n          The xcat contained in totals NEED TO COME FIRST in the ordering of xcat.\n          xcat = np.concatenate((total[xcat_in_total_idx], xcat[...])).\n      cat_active_in_xbind_idx (tuple of integers): Indices that the active species for the catalysis reactions correspond to in the xbind species in the binding network bn. Length is self.dim_mcat.\n  \"\"\"\n  self.bn=bn\n  self.kbind=kbind # binding network's binding constants are fixed at the catalysis timescale\n  self.kcat=kcat\n  self.logkbind=np.log10(kbind)\n  self.total_const=total_const\n  self.logtotal_const=np.log10(total_const)\n  self.total_const_idx=total_const_idx\n  self.cn=cn\n  self.xcat_in_total_idx=xcat_in_total_idx\n  self.cat_active_in_xbind_idx=cat_active_in_xbind_idx\n</code></pre>"},{"location":"#bcn.catalysis_network.binding_and_catalysis.dlogxcatdt","title":"<code>dlogxcatdt(logxcat, a_mat)</code>","text":"<p>Calculate dlogxcat/dt for at a given logxcat point.</p> <p>Parameters:</p> Name Type Description Default <code>logxcat</code> <code>numpy array</code> <p>The vector of xcat in log10 indicating the current state of catalysis dynamics. Length is dim_ncat. Entries of xcat corresponding to totals in the binding network need to come first.</p> required <code>a_mat</code> <code>numpy array</code> <p>Matrix defining totals in terms of xbind in the binding network. Shape is (bn.dim_d, bn.dim_n). Correspond to conserved quantities at the binding timescale. The default choice should be bn.l_mat. Can be modified from bn.l_mat to describe restrictions or asymptotic limits of the system.</p> required Source code in <code>src/bcn/catalysis_network.py</code> <pre><code>def dlogxcatdt(self,logxcat,a_mat):\n  \"\"\"\n  Calculate dlogxcat/dt for at a given logxcat point.\n\n  Args:\n      logxcat (numpy array): The vector of xcat in log10 indicating the current state of catalysis dynamics. Length is dim_ncat.\n          Entries of xcat corresponding to totals in the binding network need to come first.\n      a_mat (numpy array): Matrix defining totals in terms of xbind in the binding network. Shape is (bn.dim_d, bn.dim_n).\n          Correspond to conserved quantities at the binding timescale.\n          The default choice should be bn.l_mat.\n          Can be modified from bn.l_mat to describe restrictions or asymptotic limits of the system.\n  \"\"\"\n  cn=self.cn\n  bn=self.bn\n  logtk=np.zeros(bn.dim_n)\n  n_contained=len(self.xcat_in_total_idx)\n  logtk[self.xcat_in_total_idx]=logxcat[:n_contained] # totals come first in logtk\n  #   and only n_contained number of xcat are contained in totals.\n  # Then the last r are kbin.\n  logtk[self.total_const_idx]=self.logtotal_const\n  # IS IT TRUE that all totals are contained in xcat? No. Some are constant...\n  logtk[bn.dim_d:]=self.logkbind\n  logxbind=bn.tk2x_num(logtk, a_mat=a_mat)\n  # print('logxbind', logxbind)\n  vcat=self.kcat.T @ 10**logxbind[self.cat_active_in_xbind_idx]  # 2024/08/08 added transposition of kcat\n  vcat = np.expand_dims(vcat, axis=0)  # 2024/08/08 added\n  new_logxcat = (cn.s_mat@vcat) / 10**logxcat / np.log(10) # divide by xcat so that this kinetics of logxcat.\n  return new_logxcat\n</code></pre>"},{"location":"#bcn.catalysis_network.catalysis_network","title":"<code>catalysis_network</code>","text":"Source code in <code>src/bcn/catalysis_network.py</code> <pre><code>class catalysis_network:\n  def __init__(self,\n            s_mat,\n            xcat_sym=np.array([]),\n            vcat_sym=np.array([])):\n    \"\"\"\n    Initiate a catalysis_network object.\n\n    Args:\n        s_mat (numpy array): The stoichiometry matrix defining the catalysis network. Shape is (n_cat, m_cat).\n            Not necessarily full rank.\n            n_cat is the number of rows, i.e. the number of variables for catalysis dynamics, same as length of xcat.\n            m_cat is the number of columns, i.e. the number of catalysis reactions, same as length of kcat.\n        xcat_sym (numpy array of sympy symbols, optional): Symbols for xcat variables. Length n_cat.\n        vcat_sym (numpy array of sympy symbols, optional): Symbols for vcat variables, fluxes of catalysis reactions. Length m_cat.\n    \"\"\"\n    self.s_mat=s_mat\n    self.dim_ncat,self.dim_mcat=s_mat.shape\n</code></pre>"},{"location":"#bcn.catalysis_network.catalysis_network.__init__","title":"<code>__init__(s_mat, xcat_sym=np.array([]), vcat_sym=np.array([]))</code>","text":"<p>Initiate a catalysis_network object.</p> <p>Parameters:</p> Name Type Description Default <code>s_mat</code> <code>numpy array</code> <p>The stoichiometry matrix defining the catalysis network. Shape is (n_cat, m_cat). Not necessarily full rank. n_cat is the number of rows, i.e. the number of variables for catalysis dynamics, same as length of xcat. m_cat is the number of columns, i.e. the number of catalysis reactions, same as length of kcat.</p> required <code>xcat_sym</code> <code>numpy array of sympy symbols</code> <p>Symbols for xcat variables. Length n_cat.</p> <code>array([])</code> <code>vcat_sym</code> <code>numpy array of sympy symbols</code> <p>Symbols for vcat variables, fluxes of catalysis reactions. Length m_cat.</p> <code>array([])</code> Source code in <code>src/bcn/catalysis_network.py</code> <pre><code>def __init__(self,\n          s_mat,\n          xcat_sym=np.array([]),\n          vcat_sym=np.array([])):\n  \"\"\"\n  Initiate a catalysis_network object.\n\n  Args:\n      s_mat (numpy array): The stoichiometry matrix defining the catalysis network. Shape is (n_cat, m_cat).\n          Not necessarily full rank.\n          n_cat is the number of rows, i.e. the number of variables for catalysis dynamics, same as length of xcat.\n          m_cat is the number of columns, i.e. the number of catalysis reactions, same as length of kcat.\n      xcat_sym (numpy array of sympy symbols, optional): Symbols for xcat variables. Length n_cat.\n      vcat_sym (numpy array of sympy symbols, optional): Symbols for vcat variables, fluxes of catalysis reactions. Length m_cat.\n  \"\"\"\n  self.s_mat=s_mat\n  self.dim_ncat,self.dim_mcat=s_mat.shape\n</code></pre>"},{"location":"tutorials/","title":"How to install <code>BCN</code> package","text":"<p>\u26a0\ufe0f Currently, this python package only can be installed from GitHub by running command: <code>pip install git+https://github.com/chemaoxfz/bnc.git</code>.</p>"},{"location":"tutorials/#first-starting","title":"First starting","text":""},{"location":"tutorials/#build-up-a-binding-netwrok","title":"Build up a binding netwrok","text":"<p>The simplest binding network consists of a single binding reaction $$ E + S \\leftrightharpoons C $$ representing the complexing of two species.</p> <p>While it is possible to obtain a simple network (from the point of view of the number of unique species) by asserting, for example, that \\(E = S\\), we will keep the number of species to \\(3\\) to preserve generality. $$ \\begin{aligned} x &amp;= (E, S, C) \\\\ q &amp;= (q_E, q_S) \\\\ N &amp;= \\begin{bmatrix}1\\ 1\\ -1\\end{bmatrix} \\\\ L &amp;= \\begin{bmatrix}1\\ 0\\ 1 \\\\ 0\\ 1\\ 1\\end{bmatrix} \\end{aligned} $$ Then, we obtain a binding network,</p> example.py<pre><code>import numpy as np\nfrom BCN.binding_network import binding_network as BN\n\n\nl_mat = np.array([\n  [1, 0, 1],\n  [0, 1, 1]\n])\n\nn_mat = np.array([\n  [1, 1, -1]\n])\n\nbn = binding_network(n_mat=n_mat, l_mat=l_mat)\n</code></pre>"},{"location":"tutorials/#build-up-a-catalysis-network","title":"Build up a catalysis network","text":""}]}