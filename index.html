
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.7">
    
    
      
        <title>Binding and Catalysis Networks (BCN) Docs</title>
      
    
    
      <link rel="stylesheet" href="assets/stylesheets/main.8608ea7d.min.css">
      
        
        <link rel="stylesheet" href="assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="assets/_mkdocstrings.css">
    
    <script>__md_scope=new URL(".",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#welcome-to-binding-and-catalysis-networks-bcn-docs" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="." title="Binding and Catalysis Networks (BCN) Docs" class="md-header__button md-logo" aria-label="Binding and Catalysis Networks (BCN) Docs" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Binding and Catalysis Networks (BCN) Docs
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Index
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2a7 7 0 0 0-7 7c0 2.38 1.19 4.47 3 5.74V17a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1v-2.26c1.81-1.27 3-3.36 3-5.74a7 7 0 0 0-7-7M9 21a1 1 0 0 0 1 1h4a1 1 0 0 0 1-1v-1H9z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2a7 7 0 0 1 7 7c0 2.38-1.19 4.47-3 5.74V17a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1v-2.26C6.19 13.47 5 11.38 5 9a7 7 0 0 1 7-7M9 21v-1h6v1a1 1 0 0 1-1 1h-4a1 1 0 0 1-1-1m3-17a5 5 0 0 0-5 5c0 2.05 1.23 3.81 3 4.58V16h4v-2.42c1.77-.77 3-2.53 3-4.58a5 5 0 0 0-5-5"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
    
  
  
    <li class="md-tabs__item md-tabs__item--active">
      <a href="." class="md-tabs__link">
        
  
    
  
  Index

      </a>
    </li>
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="." title="Binding and Catalysis Networks (BCN) Docs" class="md-nav__button md-logo" aria-label="Binding and Catalysis Networks (BCN) Docs" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    Binding and Catalysis Networks (BCN) Docs
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    Index
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="." class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    Index
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#project-overview" class="md-nav__link">
    <span class="md-ellipsis">
      Project overview
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bcn.binding_network" class="md-nav__link">
    <span class="md-ellipsis">
      binding_network
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bcn.binding_network.binding_network" class="md-nav__link">
    <span class="md-ellipsis">
      binding_network
    </span>
  </a>
  
    <nav class="md-nav" aria-label="binding_network">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.binding_network.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.binding_network.l_from_n" class="md-nav__link">
    <span class="md-ellipsis">
      l_from_n
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.binding_network.logder_activity_num" class="md-nav__link">
    <span class="md-ellipsis">
      logder_activity_num
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.binding_network.logder_num" class="md-nav__link">
    <span class="md-ellipsis">
      logder_num
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.binding_network.logder_sym" class="md-nav__link">
    <span class="md-ellipsis">
      logder_sym
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.binding_network.logder_sym_activity" class="md-nav__link">
    <span class="md-ellipsis">
      logder_sym_activity
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.binding_network.logder_tk2x_num" class="md-nav__link">
    <span class="md-ellipsis">
      logder_tk2x_num
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.binding_network.logder_tk2x_x_num" class="md-nav__link">
    <span class="md-ellipsis">
      logder_tk2x_x_num
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.binding_network.logder_tk_num" class="md-nav__link">
    <span class="md-ellipsis">
      logder_tk_num
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.binding_network.logder_x_num" class="md-nav__link">
    <span class="md-ellipsis">
      logder_x_num
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.binding_network.logder_xak_num" class="md-nav__link">
    <span class="md-ellipsis">
      logder_xak_num
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.binding_network.sampling_over_activity_regime_hull" class="md-nav__link">
    <span class="md-ellipsis">
      sampling_over_activity_regime_hull
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.binding_network.sampling_over_vertex_hull" class="md-nav__link">
    <span class="md-ellipsis">
      sampling_over_vertex_hull
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.binding_network.t2x_sym" class="md-nav__link">
    <span class="md-ellipsis">
      t2x_sym
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.binding_network.tk2x_num" class="md-nav__link">
    <span class="md-ellipsis">
      tk2x_num
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.binding_network.vertex_constrained_construct" class="md-nav__link">
    <span class="md-ellipsis">
      vertex_constrained_construct
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.binding_network.vertex_construct" class="md-nav__link">
    <span class="md-ellipsis">
      vertex_construct
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.binding_network.vertex_construct_direct" class="md-nav__link">
    <span class="md-ellipsis">
      vertex_construct_direct
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.binding_network.vertex_list_feasibility_test" class="md-nav__link">
    <span class="md-ellipsis">
      vertex_list_feasibility_test
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.binding_network.x2tk_num" class="md-nav__link">
    <span class="md-ellipsis">
      x2tk_num
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.binding_network.xak2x_num" class="md-nav__link">
    <span class="md-ellipsis">
      xak2x_num
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.binding_network.xc2xak_sym" class="md-nav__link">
    <span class="md-ellipsis">
      xc2xak_sym
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bcn.binding_network.rop_dom_regime" class="md-nav__link">
    <span class="md-ellipsis">
      rop_dom_regime
    </span>
  </a>
  
    <nav class="md-nav" aria-label="rop_dom_regime">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.rop_dom_regime.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.rop_dom_regime.hull_sampling" class="md-nav__link">
    <span class="md-ellipsis">
      hull_sampling
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bcn.binding_network.rop_ld_regime" class="md-nav__link">
    <span class="md-ellipsis">
      rop_ld_regime
    </span>
  </a>
  
    <nav class="md-nav" aria-label="rop_ld_regime">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.rop_ld_regime.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bcn.binding_network.rop_vertex" class="md-nav__link">
    <span class="md-ellipsis">
      rop_vertex
    </span>
  </a>
  
    <nav class="md-nav" aria-label="rop_vertex">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.rop_vertex.__dist_in_hull" class="md-nav__link">
    <span class="md-ellipsis">
      __dist_in_hull
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.rop_vertex.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.rop_vertex.chart_check" class="md-nav__link">
    <span class="md-ellipsis">
      chart_check
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.rop_vertex.j_func" class="md-nav__link">
    <span class="md-ellipsis">
      j_func
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.rop_vertex.vertex_feasibility_test" class="md-nav__link">
    <span class="md-ellipsis">
      vertex_feasibility_test
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.rop_vertex.vertex_hull_of_validity" class="md-nav__link">
    <span class="md-ellipsis">
      vertex_hull_of_validity
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.rop_vertex.vertex_hull_sampling" class="md-nav__link">
    <span class="md-ellipsis">
      vertex_hull_sampling
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.rop_vertex.vertex_print_validity_condition" class="md-nav__link">
    <span class="md-ellipsis">
      vertex_print_validity_condition
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bcn.catalysis_network" class="md-nav__link">
    <span class="md-ellipsis">
      catalysis_network
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bcn.catalysis_network.binding_and_catalysis" class="md-nav__link">
    <span class="md-ellipsis">
      binding_and_catalysis
    </span>
  </a>
  
    <nav class="md-nav" aria-label="binding_and_catalysis">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bcn.catalysis_network.binding_and_catalysis.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.catalysis_network.binding_and_catalysis.dlogxcatdt" class="md-nav__link">
    <span class="md-ellipsis">
      dlogxcatdt
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bcn.catalysis_network.catalysis_network" class="md-nav__link">
    <span class="md-ellipsis">
      catalysis_network
    </span>
  </a>
  
    <nav class="md-nav" aria-label="catalysis_network">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bcn.catalysis_network.catalysis_network.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#project-overview" class="md-nav__link">
    <span class="md-ellipsis">
      Project overview
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bcn.binding_network" class="md-nav__link">
    <span class="md-ellipsis">
      binding_network
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bcn.binding_network.binding_network" class="md-nav__link">
    <span class="md-ellipsis">
      binding_network
    </span>
  </a>
  
    <nav class="md-nav" aria-label="binding_network">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.binding_network.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.binding_network.l_from_n" class="md-nav__link">
    <span class="md-ellipsis">
      l_from_n
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.binding_network.logder_activity_num" class="md-nav__link">
    <span class="md-ellipsis">
      logder_activity_num
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.binding_network.logder_num" class="md-nav__link">
    <span class="md-ellipsis">
      logder_num
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.binding_network.logder_sym" class="md-nav__link">
    <span class="md-ellipsis">
      logder_sym
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.binding_network.logder_sym_activity" class="md-nav__link">
    <span class="md-ellipsis">
      logder_sym_activity
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.binding_network.logder_tk2x_num" class="md-nav__link">
    <span class="md-ellipsis">
      logder_tk2x_num
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.binding_network.logder_tk2x_x_num" class="md-nav__link">
    <span class="md-ellipsis">
      logder_tk2x_x_num
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.binding_network.logder_tk_num" class="md-nav__link">
    <span class="md-ellipsis">
      logder_tk_num
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.binding_network.logder_x_num" class="md-nav__link">
    <span class="md-ellipsis">
      logder_x_num
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.binding_network.logder_xak_num" class="md-nav__link">
    <span class="md-ellipsis">
      logder_xak_num
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.binding_network.sampling_over_activity_regime_hull" class="md-nav__link">
    <span class="md-ellipsis">
      sampling_over_activity_regime_hull
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.binding_network.sampling_over_vertex_hull" class="md-nav__link">
    <span class="md-ellipsis">
      sampling_over_vertex_hull
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.binding_network.t2x_sym" class="md-nav__link">
    <span class="md-ellipsis">
      t2x_sym
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.binding_network.tk2x_num" class="md-nav__link">
    <span class="md-ellipsis">
      tk2x_num
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.binding_network.vertex_constrained_construct" class="md-nav__link">
    <span class="md-ellipsis">
      vertex_constrained_construct
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.binding_network.vertex_construct" class="md-nav__link">
    <span class="md-ellipsis">
      vertex_construct
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.binding_network.vertex_construct_direct" class="md-nav__link">
    <span class="md-ellipsis">
      vertex_construct_direct
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.binding_network.vertex_list_feasibility_test" class="md-nav__link">
    <span class="md-ellipsis">
      vertex_list_feasibility_test
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.binding_network.x2tk_num" class="md-nav__link">
    <span class="md-ellipsis">
      x2tk_num
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.binding_network.xak2x_num" class="md-nav__link">
    <span class="md-ellipsis">
      xak2x_num
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.binding_network.xc2xak_sym" class="md-nav__link">
    <span class="md-ellipsis">
      xc2xak_sym
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bcn.binding_network.rop_dom_regime" class="md-nav__link">
    <span class="md-ellipsis">
      rop_dom_regime
    </span>
  </a>
  
    <nav class="md-nav" aria-label="rop_dom_regime">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.rop_dom_regime.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.rop_dom_regime.hull_sampling" class="md-nav__link">
    <span class="md-ellipsis">
      hull_sampling
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bcn.binding_network.rop_ld_regime" class="md-nav__link">
    <span class="md-ellipsis">
      rop_ld_regime
    </span>
  </a>
  
    <nav class="md-nav" aria-label="rop_ld_regime">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.rop_ld_regime.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bcn.binding_network.rop_vertex" class="md-nav__link">
    <span class="md-ellipsis">
      rop_vertex
    </span>
  </a>
  
    <nav class="md-nav" aria-label="rop_vertex">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.rop_vertex.__dist_in_hull" class="md-nav__link">
    <span class="md-ellipsis">
      __dist_in_hull
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.rop_vertex.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.rop_vertex.chart_check" class="md-nav__link">
    <span class="md-ellipsis">
      chart_check
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.rop_vertex.j_func" class="md-nav__link">
    <span class="md-ellipsis">
      j_func
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.rop_vertex.vertex_feasibility_test" class="md-nav__link">
    <span class="md-ellipsis">
      vertex_feasibility_test
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.rop_vertex.vertex_hull_of_validity" class="md-nav__link">
    <span class="md-ellipsis">
      vertex_hull_of_validity
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.rop_vertex.vertex_hull_sampling" class="md-nav__link">
    <span class="md-ellipsis">
      vertex_hull_sampling
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.binding_network.rop_vertex.vertex_print_validity_condition" class="md-nav__link">
    <span class="md-ellipsis">
      vertex_print_validity_condition
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bcn.catalysis_network" class="md-nav__link">
    <span class="md-ellipsis">
      catalysis_network
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bcn.catalysis_network.binding_and_catalysis" class="md-nav__link">
    <span class="md-ellipsis">
      binding_and_catalysis
    </span>
  </a>
  
    <nav class="md-nav" aria-label="binding_and_catalysis">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bcn.catalysis_network.binding_and_catalysis.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcn.catalysis_network.binding_and_catalysis.dlogxcatdt" class="md-nav__link">
    <span class="md-ellipsis">
      dlogxcatdt
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bcn.catalysis_network.catalysis_network" class="md-nav__link">
    <span class="md-ellipsis">
      catalysis_network
    </span>
  </a>
  
    <nav class="md-nav" aria-label="catalysis_network">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bcn.catalysis_network.catalysis_network.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="welcome-to-binding-and-catalysis-networks-bcn-docs">Welcome to Binding and Catalysis Networks (BCN) Docs</h1>
<h2 id="project-overview">Project overview</h2>


<div class="doc doc-object doc-module">



<a id="bcn.binding_network"></a>
    <div class="doc doc-contents first">








  <div class="doc doc-children">








<div class="doc doc-object doc-class">



<h2 id="bcn.binding_network.binding_network" class="doc doc-heading">
            <code>binding_network</code>


</h2>


    <div class="doc doc-contents ">







              <details class="quote">
                <summary>Source code in <code>src/bcn/binding_network.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1068</span>
<span class="normal">1069</span>
<span class="normal">1070</span>
<span class="normal">1071</span>
<span class="normal">1072</span>
<span class="normal">1073</span>
<span class="normal">1074</span>
<span class="normal">1075</span>
<span class="normal">1076</span>
<span class="normal">1077</span>
<span class="normal">1078</span>
<span class="normal">1079</span>
<span class="normal">1080</span>
<span class="normal">1081</span>
<span class="normal">1082</span>
<span class="normal">1083</span>
<span class="normal">1084</span>
<span class="normal">1085</span>
<span class="normal">1086</span>
<span class="normal">1087</span>
<span class="normal">1088</span>
<span class="normal">1089</span>
<span class="normal">1090</span>
<span class="normal">1091</span>
<span class="normal">1092</span>
<span class="normal">1093</span>
<span class="normal">1094</span>
<span class="normal">1095</span>
<span class="normal">1096</span>
<span class="normal">1097</span>
<span class="normal">1098</span>
<span class="normal">1099</span>
<span class="normal">1100</span>
<span class="normal">1101</span>
<span class="normal">1102</span>
<span class="normal">1103</span>
<span class="normal">1104</span>
<span class="normal">1105</span>
<span class="normal">1106</span>
<span class="normal">1107</span>
<span class="normal">1108</span>
<span class="normal">1109</span>
<span class="normal">1110</span>
<span class="normal">1111</span>
<span class="normal">1112</span>
<span class="normal">1113</span>
<span class="normal">1114</span>
<span class="normal">1115</span>
<span class="normal">1116</span>
<span class="normal">1117</span>
<span class="normal">1118</span>
<span class="normal">1119</span>
<span class="normal">1120</span>
<span class="normal">1121</span>
<span class="normal">1122</span>
<span class="normal">1123</span>
<span class="normal">1124</span>
<span class="normal">1125</span>
<span class="normal">1126</span>
<span class="normal">1127</span>
<span class="normal">1128</span>
<span class="normal">1129</span>
<span class="normal">1130</span>
<span class="normal">1131</span>
<span class="normal">1132</span>
<span class="normal">1133</span>
<span class="normal">1134</span>
<span class="normal">1135</span>
<span class="normal">1136</span>
<span class="normal">1137</span>
<span class="normal">1138</span>
<span class="normal">1139</span>
<span class="normal">1140</span>
<span class="normal">1141</span>
<span class="normal">1142</span>
<span class="normal">1143</span>
<span class="normal">1144</span>
<span class="normal">1145</span>
<span class="normal">1146</span>
<span class="normal">1147</span>
<span class="normal">1148</span>
<span class="normal">1149</span>
<span class="normal">1150</span>
<span class="normal">1151</span>
<span class="normal">1152</span>
<span class="normal">1153</span>
<span class="normal">1154</span>
<span class="normal">1155</span>
<span class="normal">1156</span>
<span class="normal">1157</span>
<span class="normal">1158</span>
<span class="normal">1159</span>
<span class="normal">1160</span>
<span class="normal">1161</span>
<span class="normal">1162</span>
<span class="normal">1163</span>
<span class="normal">1164</span>
<span class="normal">1165</span>
<span class="normal">1166</span>
<span class="normal">1167</span>
<span class="normal">1168</span>
<span class="normal">1169</span>
<span class="normal">1170</span>
<span class="normal">1171</span>
<span class="normal">1172</span>
<span class="normal">1173</span>
<span class="normal">1174</span>
<span class="normal">1175</span>
<span class="normal">1176</span>
<span class="normal">1177</span>
<span class="normal">1178</span>
<span class="normal">1179</span>
<span class="normal">1180</span>
<span class="normal">1181</span>
<span class="normal">1182</span>
<span class="normal">1183</span>
<span class="normal">1184</span>
<span class="normal">1185</span>
<span class="normal">1186</span>
<span class="normal">1187</span>
<span class="normal">1188</span>
<span class="normal">1189</span>
<span class="normal">1190</span>
<span class="normal">1191</span>
<span class="normal">1192</span>
<span class="normal">1193</span>
<span class="normal">1194</span>
<span class="normal">1195</span>
<span class="normal">1196</span>
<span class="normal">1197</span>
<span class="normal">1198</span>
<span class="normal">1199</span>
<span class="normal">1200</span>
<span class="normal">1201</span>
<span class="normal">1202</span>
<span class="normal">1203</span>
<span class="normal">1204</span>
<span class="normal">1205</span>
<span class="normal">1206</span>
<span class="normal">1207</span>
<span class="normal">1208</span>
<span class="normal">1209</span>
<span class="normal">1210</span>
<span class="normal">1211</span>
<span class="normal">1212</span>
<span class="normal">1213</span>
<span class="normal">1214</span>
<span class="normal">1215</span>
<span class="normal">1216</span>
<span class="normal">1217</span>
<span class="normal">1218</span>
<span class="normal">1219</span>
<span class="normal">1220</span>
<span class="normal">1221</span>
<span class="normal">1222</span>
<span class="normal">1223</span>
<span class="normal">1224</span>
<span class="normal">1225</span>
<span class="normal">1226</span>
<span class="normal">1227</span>
<span class="normal">1228</span>
<span class="normal">1229</span>
<span class="normal">1230</span>
<span class="normal">1231</span>
<span class="normal">1232</span>
<span class="normal">1233</span>
<span class="normal">1234</span>
<span class="normal">1235</span>
<span class="normal">1236</span>
<span class="normal">1237</span>
<span class="normal">1238</span>
<span class="normal">1239</span>
<span class="normal">1240</span>
<span class="normal">1241</span>
<span class="normal">1242</span>
<span class="normal">1243</span>
<span class="normal">1244</span>
<span class="normal">1245</span>
<span class="normal">1246</span>
<span class="normal">1247</span>
<span class="normal">1248</span>
<span class="normal">1249</span>
<span class="normal">1250</span>
<span class="normal">1251</span>
<span class="normal">1252</span>
<span class="normal">1253</span>
<span class="normal">1254</span>
<span class="normal">1255</span>
<span class="normal">1256</span>
<span class="normal">1257</span>
<span class="normal">1258</span>
<span class="normal">1259</span>
<span class="normal">1260</span>
<span class="normal">1261</span>
<span class="normal">1262</span>
<span class="normal">1263</span>
<span class="normal">1264</span>
<span class="normal">1265</span>
<span class="normal">1266</span>
<span class="normal">1267</span>
<span class="normal">1268</span>
<span class="normal">1269</span>
<span class="normal">1270</span>
<span class="normal">1271</span>
<span class="normal">1272</span>
<span class="normal">1273</span>
<span class="normal">1274</span>
<span class="normal">1275</span>
<span class="normal">1276</span>
<span class="normal">1277</span>
<span class="normal">1278</span>
<span class="normal">1279</span>
<span class="normal">1280</span>
<span class="normal">1281</span>
<span class="normal">1282</span>
<span class="normal">1283</span>
<span class="normal">1284</span>
<span class="normal">1285</span>
<span class="normal">1286</span>
<span class="normal">1287</span>
<span class="normal">1288</span>
<span class="normal">1289</span>
<span class="normal">1290</span>
<span class="normal">1291</span>
<span class="normal">1292</span>
<span class="normal">1293</span>
<span class="normal">1294</span>
<span class="normal">1295</span>
<span class="normal">1296</span>
<span class="normal">1297</span>
<span class="normal">1298</span>
<span class="normal">1299</span>
<span class="normal">1300</span>
<span class="normal">1301</span>
<span class="normal">1302</span>
<span class="normal">1303</span>
<span class="normal">1304</span>
<span class="normal">1305</span>
<span class="normal">1306</span>
<span class="normal">1307</span>
<span class="normal">1308</span>
<span class="normal">1309</span>
<span class="normal">1310</span>
<span class="normal">1311</span>
<span class="normal">1312</span>
<span class="normal">1313</span>
<span class="normal">1314</span>
<span class="normal">1315</span>
<span class="normal">1316</span>
<span class="normal">1317</span>
<span class="normal">1318</span>
<span class="normal">1319</span>
<span class="normal">1320</span>
<span class="normal">1321</span>
<span class="normal">1322</span>
<span class="normal">1323</span>
<span class="normal">1324</span>
<span class="normal">1325</span>
<span class="normal">1326</span>
<span class="normal">1327</span>
<span class="normal">1328</span>
<span class="normal">1329</span>
<span class="normal">1330</span>
<span class="normal">1331</span>
<span class="normal">1332</span>
<span class="normal">1333</span>
<span class="normal">1334</span>
<span class="normal">1335</span>
<span class="normal">1336</span>
<span class="normal">1337</span>
<span class="normal">1338</span>
<span class="normal">1339</span>
<span class="normal">1340</span>
<span class="normal">1341</span>
<span class="normal">1342</span>
<span class="normal">1343</span>
<span class="normal">1344</span>
<span class="normal">1345</span>
<span class="normal">1346</span>
<span class="normal">1347</span>
<span class="normal">1348</span>
<span class="normal">1349</span>
<span class="normal">1350</span>
<span class="normal">1351</span>
<span class="normal">1352</span>
<span class="normal">1353</span>
<span class="normal">1354</span>
<span class="normal">1355</span>
<span class="normal">1356</span>
<span class="normal">1357</span>
<span class="normal">1358</span>
<span class="normal">1359</span>
<span class="normal">1360</span>
<span class="normal">1361</span>
<span class="normal">1362</span>
<span class="normal">1363</span>
<span class="normal">1364</span>
<span class="normal">1365</span>
<span class="normal">1366</span>
<span class="normal">1367</span>
<span class="normal">1368</span>
<span class="normal">1369</span>
<span class="normal">1370</span>
<span class="normal">1371</span>
<span class="normal">1372</span>
<span class="normal">1373</span>
<span class="normal">1374</span>
<span class="normal">1375</span>
<span class="normal">1376</span>
<span class="normal">1377</span>
<span class="normal">1378</span>
<span class="normal">1379</span>
<span class="normal">1380</span>
<span class="normal">1381</span>
<span class="normal">1382</span>
<span class="normal">1383</span>
<span class="normal">1384</span>
<span class="normal">1385</span>
<span class="normal">1386</span>
<span class="normal">1387</span>
<span class="normal">1388</span>
<span class="normal">1389</span>
<span class="normal">1390</span>
<span class="normal">1391</span>
<span class="normal">1392</span>
<span class="normal">1393</span>
<span class="normal">1394</span>
<span class="normal">1395</span>
<span class="normal">1396</span>
<span class="normal">1397</span>
<span class="normal">1398</span>
<span class="normal">1399</span>
<span class="normal">1400</span>
<span class="normal">1401</span>
<span class="normal">1402</span>
<span class="normal">1403</span>
<span class="normal">1404</span>
<span class="normal">1405</span>
<span class="normal">1406</span>
<span class="normal">1407</span>
<span class="normal">1408</span>
<span class="normal">1409</span>
<span class="normal">1410</span>
<span class="normal">1411</span>
<span class="normal">1412</span>
<span class="normal">1413</span>
<span class="normal">1414</span>
<span class="normal">1415</span>
<span class="normal">1416</span>
<span class="normal">1417</span>
<span class="normal">1418</span>
<span class="normal">1419</span>
<span class="normal">1420</span>
<span class="normal">1421</span>
<span class="normal">1422</span>
<span class="normal">1423</span>
<span class="normal">1424</span>
<span class="normal">1425</span>
<span class="normal">1426</span>
<span class="normal">1427</span>
<span class="normal">1428</span>
<span class="normal">1429</span>
<span class="normal">1430</span>
<span class="normal">1431</span>
<span class="normal">1432</span>
<span class="normal">1433</span>
<span class="normal">1434</span>
<span class="normal">1435</span>
<span class="normal">1436</span>
<span class="normal">1437</span>
<span class="normal">1438</span>
<span class="normal">1439</span>
<span class="normal">1440</span>
<span class="normal">1441</span>
<span class="normal">1442</span>
<span class="normal">1443</span>
<span class="normal">1444</span>
<span class="normal">1445</span>
<span class="normal">1446</span>
<span class="normal">1447</span>
<span class="normal">1448</span>
<span class="normal">1449</span>
<span class="normal">1450</span>
<span class="normal">1451</span>
<span class="normal">1452</span>
<span class="normal">1453</span>
<span class="normal">1454</span>
<span class="normal">1455</span>
<span class="normal">1456</span>
<span class="normal">1457</span>
<span class="normal">1458</span>
<span class="normal">1459</span>
<span class="normal">1460</span>
<span class="normal">1461</span>
<span class="normal">1462</span>
<span class="normal">1463</span>
<span class="normal">1464</span>
<span class="normal">1465</span>
<span class="normal">1466</span>
<span class="normal">1467</span>
<span class="normal">1468</span>
<span class="normal">1469</span>
<span class="normal">1470</span>
<span class="normal">1471</span>
<span class="normal">1472</span>
<span class="normal">1473</span>
<span class="normal">1474</span>
<span class="normal">1475</span>
<span class="normal">1476</span>
<span class="normal">1477</span>
<span class="normal">1478</span>
<span class="normal">1479</span>
<span class="normal">1480</span>
<span class="normal">1481</span>
<span class="normal">1482</span>
<span class="normal">1483</span>
<span class="normal">1484</span>
<span class="normal">1485</span>
<span class="normal">1486</span>
<span class="normal">1487</span>
<span class="normal">1488</span>
<span class="normal">1489</span>
<span class="normal">1490</span>
<span class="normal">1491</span>
<span class="normal">1492</span>
<span class="normal">1493</span>
<span class="normal">1494</span>
<span class="normal">1495</span>
<span class="normal">1496</span>
<span class="normal">1497</span>
<span class="normal">1498</span>
<span class="normal">1499</span>
<span class="normal">1500</span>
<span class="normal">1501</span>
<span class="normal">1502</span>
<span class="normal">1503</span>
<span class="normal">1504</span>
<span class="normal">1505</span>
<span class="normal">1506</span>
<span class="normal">1507</span>
<span class="normal">1508</span>
<span class="normal">1509</span>
<span class="normal">1510</span>
<span class="normal">1511</span>
<span class="normal">1512</span>
<span class="normal">1513</span>
<span class="normal">1514</span>
<span class="normal">1515</span>
<span class="normal">1516</span>
<span class="normal">1517</span>
<span class="normal">1518</span>
<span class="normal">1519</span>
<span class="normal">1520</span>
<span class="normal">1521</span>
<span class="normal">1522</span>
<span class="normal">1523</span>
<span class="normal">1524</span>
<span class="normal">1525</span>
<span class="normal">1526</span>
<span class="normal">1527</span>
<span class="normal">1528</span>
<span class="normal">1529</span>
<span class="normal">1530</span>
<span class="normal">1531</span>
<span class="normal">1532</span>
<span class="normal">1533</span>
<span class="normal">1534</span>
<span class="normal">1535</span>
<span class="normal">1536</span>
<span class="normal">1537</span>
<span class="normal">1538</span>
<span class="normal">1539</span>
<span class="normal">1540</span>
<span class="normal">1541</span>
<span class="normal">1542</span>
<span class="normal">1543</span>
<span class="normal">1544</span>
<span class="normal">1545</span>
<span class="normal">1546</span>
<span class="normal">1547</span>
<span class="normal">1548</span>
<span class="normal">1549</span>
<span class="normal">1550</span>
<span class="normal">1551</span>
<span class="normal">1552</span>
<span class="normal">1553</span>
<span class="normal">1554</span>
<span class="normal">1555</span>
<span class="normal">1556</span>
<span class="normal">1557</span>
<span class="normal">1558</span>
<span class="normal">1559</span>
<span class="normal">1560</span>
<span class="normal">1561</span>
<span class="normal">1562</span>
<span class="normal">1563</span>
<span class="normal">1564</span>
<span class="normal">1565</span>
<span class="normal">1566</span>
<span class="normal">1567</span>
<span class="normal">1568</span>
<span class="normal">1569</span>
<span class="normal">1570</span>
<span class="normal">1571</span>
<span class="normal">1572</span>
<span class="normal">1573</span>
<span class="normal">1574</span>
<span class="normal">1575</span>
<span class="normal">1576</span>
<span class="normal">1577</span>
<span class="normal">1578</span>
<span class="normal">1579</span>
<span class="normal">1580</span>
<span class="normal">1581</span>
<span class="normal">1582</span>
<span class="normal">1583</span>
<span class="normal">1584</span>
<span class="normal">1585</span>
<span class="normal">1586</span>
<span class="normal">1587</span>
<span class="normal">1588</span>
<span class="normal">1589</span>
<span class="normal">1590</span>
<span class="normal">1591</span>
<span class="normal">1592</span>
<span class="normal">1593</span>
<span class="normal">1594</span>
<span class="normal">1595</span>
<span class="normal">1596</span>
<span class="normal">1597</span>
<span class="normal">1598</span>
<span class="normal">1599</span>
<span class="normal">1600</span>
<span class="normal">1601</span>
<span class="normal">1602</span>
<span class="normal">1603</span>
<span class="normal">1604</span>
<span class="normal">1605</span>
<span class="normal">1606</span>
<span class="normal">1607</span>
<span class="normal">1608</span>
<span class="normal">1609</span>
<span class="normal">1610</span>
<span class="normal">1611</span>
<span class="normal">1612</span>
<span class="normal">1613</span>
<span class="normal">1614</span>
<span class="normal">1615</span>
<span class="normal">1616</span>
<span class="normal">1617</span>
<span class="normal">1618</span>
<span class="normal">1619</span>
<span class="normal">1620</span>
<span class="normal">1621</span>
<span class="normal">1622</span>
<span class="normal">1623</span>
<span class="normal">1624</span>
<span class="normal">1625</span>
<span class="normal">1626</span>
<span class="normal">1627</span>
<span class="normal">1628</span>
<span class="normal">1629</span>
<span class="normal">1630</span>
<span class="normal">1631</span>
<span class="normal">1632</span>
<span class="normal">1633</span>
<span class="normal">1634</span>
<span class="normal">1635</span>
<span class="normal">1636</span>
<span class="normal">1637</span>
<span class="normal">1638</span>
<span class="normal">1639</span>
<span class="normal">1640</span>
<span class="normal">1641</span>
<span class="normal">1642</span>
<span class="normal">1643</span>
<span class="normal">1644</span>
<span class="normal">1645</span>
<span class="normal">1646</span>
<span class="normal">1647</span>
<span class="normal">1648</span>
<span class="normal">1649</span>
<span class="normal">1650</span>
<span class="normal">1651</span>
<span class="normal">1652</span>
<span class="normal">1653</span>
<span class="normal">1654</span>
<span class="normal">1655</span>
<span class="normal">1656</span>
<span class="normal">1657</span>
<span class="normal">1658</span>
<span class="normal">1659</span>
<span class="normal">1660</span>
<span class="normal">1661</span>
<span class="normal">1662</span>
<span class="normal">1663</span>
<span class="normal">1664</span>
<span class="normal">1665</span>
<span class="normal">1666</span>
<span class="normal">1667</span>
<span class="normal">1668</span>
<span class="normal">1669</span>
<span class="normal">1670</span>
<span class="normal">1671</span>
<span class="normal">1672</span>
<span class="normal">1673</span>
<span class="normal">1674</span>
<span class="normal">1675</span>
<span class="normal">1676</span>
<span class="normal">1677</span>
<span class="normal">1678</span>
<span class="normal">1679</span>
<span class="normal">1680</span>
<span class="normal">1681</span>
<span class="normal">1682</span>
<span class="normal">1683</span>
<span class="normal">1684</span>
<span class="normal">1685</span>
<span class="normal">1686</span>
<span class="normal">1687</span>
<span class="normal">1688</span>
<span class="normal">1689</span>
<span class="normal">1690</span>
<span class="normal">1691</span>
<span class="normal">1692</span>
<span class="normal">1693</span>
<span class="normal">1694</span>
<span class="normal">1695</span>
<span class="normal">1696</span>
<span class="normal">1697</span>
<span class="normal">1698</span>
<span class="normal">1699</span>
<span class="normal">1700</span>
<span class="normal">1701</span>
<span class="normal">1702</span>
<span class="normal">1703</span>
<span class="normal">1704</span>
<span class="normal">1705</span>
<span class="normal">1706</span>
<span class="normal">1707</span>
<span class="normal">1708</span>
<span class="normal">1709</span>
<span class="normal">1710</span>
<span class="normal">1711</span>
<span class="normal">1712</span>
<span class="normal">1713</span>
<span class="normal">1714</span>
<span class="normal">1715</span>
<span class="normal">1716</span>
<span class="normal">1717</span>
<span class="normal">1718</span>
<span class="normal">1719</span>
<span class="normal">1720</span>
<span class="normal">1721</span>
<span class="normal">1722</span>
<span class="normal">1723</span>
<span class="normal">1724</span>
<span class="normal">1725</span>
<span class="normal">1726</span>
<span class="normal">1727</span>
<span class="normal">1728</span>
<span class="normal">1729</span>
<span class="normal">1730</span>
<span class="normal">1731</span>
<span class="normal">1732</span>
<span class="normal">1733</span>
<span class="normal">1734</span>
<span class="normal">1735</span>
<span class="normal">1736</span>
<span class="normal">1737</span>
<span class="normal">1738</span>
<span class="normal">1739</span>
<span class="normal">1740</span>
<span class="normal">1741</span>
<span class="normal">1742</span>
<span class="normal">1743</span>
<span class="normal">1744</span>
<span class="normal">1745</span>
<span class="normal">1746</span>
<span class="normal">1747</span>
<span class="normal">1748</span>
<span class="normal">1749</span>
<span class="normal">1750</span>
<span class="normal">1751</span>
<span class="normal">1752</span>
<span class="normal">1753</span>
<span class="normal">1754</span>
<span class="normal">1755</span>
<span class="normal">1756</span>
<span class="normal">1757</span>
<span class="normal">1758</span>
<span class="normal">1759</span>
<span class="normal">1760</span>
<span class="normal">1761</span>
<span class="normal">1762</span>
<span class="normal">1763</span>
<span class="normal">1764</span>
<span class="normal">1765</span>
<span class="normal">1766</span>
<span class="normal">1767</span>
<span class="normal">1768</span>
<span class="normal">1769</span>
<span class="normal">1770</span>
<span class="normal">1771</span>
<span class="normal">1772</span>
<span class="normal">1773</span>
<span class="normal">1774</span>
<span class="normal">1775</span>
<span class="normal">1776</span>
<span class="normal">1777</span>
<span class="normal">1778</span>
<span class="normal">1779</span>
<span class="normal">1780</span>
<span class="normal">1781</span>
<span class="normal">1782</span>
<span class="normal">1783</span>
<span class="normal">1784</span>
<span class="normal">1785</span>
<span class="normal">1786</span>
<span class="normal">1787</span>
<span class="normal">1788</span>
<span class="normal">1789</span>
<span class="normal">1790</span>
<span class="normal">1791</span>
<span class="normal">1792</span>
<span class="normal">1793</span>
<span class="normal">1794</span>
<span class="normal">1795</span>
<span class="normal">1796</span>
<span class="normal">1797</span>
<span class="normal">1798</span>
<span class="normal">1799</span>
<span class="normal">1800</span>
<span class="normal">1801</span>
<span class="normal">1802</span>
<span class="normal">1803</span>
<span class="normal">1804</span>
<span class="normal">1805</span>
<span class="normal">1806</span>
<span class="normal">1807</span>
<span class="normal">1808</span>
<span class="normal">1809</span>
<span class="normal">1810</span>
<span class="normal">1811</span>
<span class="normal">1812</span>
<span class="normal">1813</span>
<span class="normal">1814</span>
<span class="normal">1815</span>
<span class="normal">1816</span>
<span class="normal">1817</span>
<span class="normal">1818</span>
<span class="normal">1819</span>
<span class="normal">1820</span>
<span class="normal">1821</span>
<span class="normal">1822</span>
<span class="normal">1823</span>
<span class="normal">1824</span>
<span class="normal">1825</span>
<span class="normal">1826</span>
<span class="normal">1827</span>
<span class="normal">1828</span>
<span class="normal">1829</span>
<span class="normal">1830</span>
<span class="normal">1831</span>
<span class="normal">1832</span>
<span class="normal">1833</span>
<span class="normal">1834</span>
<span class="normal">1835</span>
<span class="normal">1836</span>
<span class="normal">1837</span>
<span class="normal">1838</span>
<span class="normal">1839</span>
<span class="normal">1840</span>
<span class="normal">1841</span>
<span class="normal">1842</span>
<span class="normal">1843</span>
<span class="normal">1844</span>
<span class="normal">1845</span>
<span class="normal">1846</span>
<span class="normal">1847</span>
<span class="normal">1848</span>
<span class="normal">1849</span>
<span class="normal">1850</span>
<span class="normal">1851</span>
<span class="normal">1852</span>
<span class="normal">1853</span>
<span class="normal">1854</span>
<span class="normal">1855</span>
<span class="normal">1856</span>
<span class="normal">1857</span>
<span class="normal">1858</span>
<span class="normal">1859</span>
<span class="normal">1860</span>
<span class="normal">1861</span>
<span class="normal">1862</span>
<span class="normal">1863</span>
<span class="normal">1864</span>
<span class="normal">1865</span>
<span class="normal">1866</span>
<span class="normal">1867</span>
<span class="normal">1868</span>
<span class="normal">1869</span>
<span class="normal">1870</span>
<span class="normal">1871</span>
<span class="normal">1872</span>
<span class="normal">1873</span>
<span class="normal">1874</span>
<span class="normal">1875</span>
<span class="normal">1876</span>
<span class="normal">1877</span>
<span class="normal">1878</span>
<span class="normal">1879</span>
<span class="normal">1880</span>
<span class="normal">1881</span>
<span class="normal">1882</span>
<span class="normal">1883</span>
<span class="normal">1884</span>
<span class="normal">1885</span>
<span class="normal">1886</span>
<span class="normal">1887</span>
<span class="normal">1888</span>
<span class="normal">1889</span>
<span class="normal">1890</span>
<span class="normal">1891</span>
<span class="normal">1892</span>
<span class="normal">1893</span>
<span class="normal">1894</span>
<span class="normal">1895</span>
<span class="normal">1896</span>
<span class="normal">1897</span>
<span class="normal">1898</span>
<span class="normal">1899</span>
<span class="normal">1900</span>
<span class="normal">1901</span>
<span class="normal">1902</span>
<span class="normal">1903</span>
<span class="normal">1904</span>
<span class="normal">1905</span>
<span class="normal">1906</span>
<span class="normal">1907</span>
<span class="normal">1908</span>
<span class="normal">1909</span>
<span class="normal">1910</span>
<span class="normal">1911</span>
<span class="normal">1912</span>
<span class="normal">1913</span>
<span class="normal">1914</span>
<span class="normal">1915</span>
<span class="normal">1916</span>
<span class="normal">1917</span>
<span class="normal">1918</span>
<span class="normal">1919</span>
<span class="normal">1920</span>
<span class="normal">1921</span>
<span class="normal">1922</span>
<span class="normal">1923</span>
<span class="normal">1924</span>
<span class="normal">1925</span>
<span class="normal">1926</span>
<span class="normal">1927</span>
<span class="normal">1928</span>
<span class="normal">1929</span>
<span class="normal">1930</span>
<span class="normal">1931</span>
<span class="normal">1932</span>
<span class="normal">1933</span>
<span class="normal">1934</span>
<span class="normal">1935</span>
<span class="normal">1936</span>
<span class="normal">1937</span>
<span class="normal">1938</span>
<span class="normal">1939</span>
<span class="normal">1940</span>
<span class="normal">1941</span>
<span class="normal">1942</span>
<span class="normal">1943</span>
<span class="normal">1944</span>
<span class="normal">1945</span>
<span class="normal">1946</span>
<span class="normal">1947</span>
<span class="normal">1948</span>
<span class="normal">1949</span>
<span class="normal">1950</span>
<span class="normal">1951</span>
<span class="normal">1952</span>
<span class="normal">1953</span>
<span class="normal">1954</span>
<span class="normal">1955</span>
<span class="normal">1956</span>
<span class="normal">1957</span>
<span class="normal">1958</span>
<span class="normal">1959</span>
<span class="normal">1960</span>
<span class="normal">1961</span>
<span class="normal">1962</span>
<span class="normal">1963</span>
<span class="normal">1964</span>
<span class="normal">1965</span>
<span class="normal">1966</span>
<span class="normal">1967</span>
<span class="normal">1968</span>
<span class="normal">1969</span>
<span class="normal">1970</span>
<span class="normal">1971</span>
<span class="normal">1972</span>
<span class="normal">1973</span>
<span class="normal">1974</span>
<span class="normal">1975</span>
<span class="normal">1976</span>
<span class="normal">1977</span>
<span class="normal">1978</span>
<span class="normal">1979</span>
<span class="normal">1980</span>
<span class="normal">1981</span>
<span class="normal">1982</span>
<span class="normal">1983</span>
<span class="normal">1984</span>
<span class="normal">1985</span>
<span class="normal">1986</span>
<span class="normal">1987</span>
<span class="normal">1988</span>
<span class="normal">1989</span>
<span class="normal">1990</span>
<span class="normal">1991</span>
<span class="normal">1992</span>
<span class="normal">1993</span>
<span class="normal">1994</span>
<span class="normal">1995</span>
<span class="normal">1996</span>
<span class="normal">1997</span>
<span class="normal">1998</span>
<span class="normal">1999</span>
<span class="normal">2000</span>
<span class="normal">2001</span>
<span class="normal">2002</span>
<span class="normal">2003</span>
<span class="normal">2004</span>
<span class="normal">2005</span>
<span class="normal">2006</span>
<span class="normal">2007</span>
<span class="normal">2008</span>
<span class="normal">2009</span>
<span class="normal">2010</span>
<span class="normal">2011</span>
<span class="normal">2012</span>
<span class="normal">2013</span>
<span class="normal">2014</span>
<span class="normal">2015</span>
<span class="normal">2016</span>
<span class="normal">2017</span>
<span class="normal">2018</span>
<span class="normal">2019</span>
<span class="normal">2020</span>
<span class="normal">2021</span>
<span class="normal">2022</span>
<span class="normal">2023</span>
<span class="normal">2024</span>
<span class="normal">2025</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">binding_network</span><span class="p">:</span>
  <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
               <span class="n">n_mat</span><span class="p">,</span>
               <span class="n">l_mat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span>
               <span class="n">is_atomic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">x_sym</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span>
               <span class="n">t_sym</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span>
               <span class="n">k_sym</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initiate a binding network.</span>

<span class="sd">    Args:</span>
<span class="sd">        n_mat (numpy array): The stoichiometry matrix defining the binding network.</span>
<span class="sd">        is_atomic (bool, optional): Is the binding network atomic or not. Defaults to None.</span>
<span class="sd">        l_mat (numpy array, optional): The conservation law matrix defining the conserved total quantities.</span>
<span class="sd">            If not given, and is_atomic is True, then it will be computed from n_mat. Defaults to None.</span>
<span class="sd">        x_sym (list of symbols, optional): An ordered list of symbols for the chemical species, denoting columns of the n_mat and l_mat. Defaults to None.</span>
<span class="sd">        t_sym (list of symbols, optional): An ordered list of symbols for the total or conserved quantities, denoting rows of the l_mat. Defaults to None.</span>
<span class="sd">        k_sym (list of symbols, optional): An ordered list of symbols for the binding constants in the dissociation direction, denoting rows of the n_mat. Defaults to None.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">is_atomic</span><span class="o">=</span><span class="n">is_atomic</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">n_mat</span><span class="o">=</span><span class="n">n_mat</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">n_mat_sym</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">n_mat</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dim_r</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_n</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_mat</span><span class="o">.</span><span class="n">shape</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dim_d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim_n</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim_r</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">l_mat</span><span class="p">):</span> <span class="c1">#no input l_mat</span>
      <span class="n">l_mat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">l_from_n</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_mat</span><span class="p">)</span>
      <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">l_mat</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># if no input symbols for the x,t,k variables then give them default numerically ordered ones.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">x_sym</span><span class="p">):</span>
      <span class="n">x_sym</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;x:&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_n</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">t_sym</span><span class="p">):</span>
      <span class="n">t_sym</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;t:&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_d</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">k_sym</span><span class="p">):</span>
      <span class="n">k_sym</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;k:&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_r</span><span class="p">))</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">l_mat</span><span class="o">=</span><span class="n">l_mat</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">l_mat_sym</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">l_mat</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">x_sym</span><span class="o">=</span><span class="n">x_sym</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">t_sym</span><span class="o">=</span><span class="n">t_sym</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">k_sym</span><span class="o">=</span><span class="n">k_sym</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">tk_sym</span><span class="o">=</span><span class="n">t_sym</span><span class="o">+</span><span class="n">k_sym</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">opt_var</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_n</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">m_mat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">l_mat</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">n_mat</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">orientation</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m_mat</span><span class="p">))</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">ld_sym_dict</span><span class="o">=</span><span class="p">{}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">activity_regime_dict</span><span class="o">=</span><span class="p">{}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">activity_ld_regime_dict</span><span class="o">=</span><span class="p">{}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">activity_regime_constrained_dict</span><span class="o">=</span><span class="p">{}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">activity_ld_regime_constrained_dict</span><span class="o">=</span><span class="p">{}</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">l_from_n</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n_mat</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    If the network is atomic, compute the L matrix from the N matrix.</span>

<span class="sd">    Args:</span>
<span class="sd">        n_mat (numpy array): The stoichiometry matrix defining the binding network.</span>
<span class="sd">            Assumes the columns are ordered so that the atomic species come first.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy array: The conservation law or totals matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_atomic</span>
    <span class="n">r</span><span class="o">=</span><span class="n">n_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">d</span><span class="o">=</span><span class="n">n_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">r</span>
    <span class="n">n1_mat</span><span class="o">=</span><span class="n">n_mat</span><span class="p">[:,:</span><span class="n">d</span><span class="p">]</span>
    <span class="n">n2_mat</span><span class="o">=</span><span class="n">n_mat</span><span class="p">[:,</span><span class="o">-</span><span class="n">r</span><span class="p">:]</span>
    <span class="n">l2_mat</span><span class="o">=-</span><span class="p">(</span><span class="n">n1_mat</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">n2_mat</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="n">l_mat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">d</span><span class="p">),</span><span class="n">l2_mat</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">l_mat</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">logder_num</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">logvar</span><span class="p">,</span><span class="n">chart</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="n">a_mat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the numerical log derivative of the binding network at points specified by logvar in the specified chart and dominance a_mat.</span>

<span class="sd">    Args:</span>
<span class="sd">        logvar (ndarray): Array of the points to evaluate the log derivatives at, in base-10 log. Shape is (n_points, dim_n).</span>
<span class="sd">            In chart &#39;x&#39;, for example, this is logx.</span>
<span class="sd">        chart (str): Specifying the chart that logvar is specified in. Could be &#39;x&#39;, &#39;xak&#39;, or &#39;tk&#39;.</span>
<span class="sd">        a_mat (numpy array, optional): Matrix defining the variables log derivative is taken in terms of.</span>
<span class="sd">            Assumes all entries are non-negative, and each row has at least one positive entry.</span>
<span class="sd">            Optional, defaults to l_mat of the binding network.</span>

<span class="sd">    Returns:</span>
<span class="sd">        logder (ndarray): Array of n-by-n matrix of log derivative of x to (t, k), where t = a_mat @ x, and n is the number of species.</span>
<span class="sd">            Shape is (n_points, dim_n, dim_n).</span>
<span class="sd">        logx (ndarray): Array of logx that the logvar points correspond to. Shape is (n_points, dim_n).</span>
<span class="sd">            This is returned since all input variables, regardless of chart, are mapped to the logx chart first.</span>
<span class="sd">            Returned for convenience.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># first check a_mat makes sense.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">a_mat</span><span class="p">):</span> <span class="c1"># no a_mat argument is given</span>
      <span class="n">a_mat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">l_mat</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">assert</span> <span class="n">a_mat</span><span class="o">.</span><span class="n">shape</span><span class="o">==</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_d</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_n</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;the shape of L matrix should be </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_d</span><span class="si">}</span><span class="s2"> by </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_n</span><span class="si">}</span><span class="s2">.&quot;</span>
      <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">a_mat</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">),</span> <span class="s2">&quot;all entries of A matrix should be non-negative.&quot;</span>
      <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">a_mat</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_n</span><span class="p">))</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">),</span> <span class="s2">&quot;each row of A matrix should have at least one positive entry.&quot;</span>
    <span class="c1"># for different charts, use different functions to evaluate</span>
    <span class="n">npts</span><span class="o">=</span><span class="n">logvar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">logvar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_n</span><span class="p">,</span> <span class="s1">&#39;shape of logvar should be num_points-by-dim_n&#39;</span>
    <span class="n">logders</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">logvar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_n</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_n</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">chart</span><span class="o">==</span><span class="s1">&#39;x&#39;</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npts</span><span class="p">):</span>
        <span class="n">logders</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logder_x_num</span><span class="p">(</span><span class="n">logvar</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">a_mat</span><span class="p">)</span>
      <span class="n">logx</span><span class="o">=</span><span class="n">logvar</span>
    <span class="k">elif</span> <span class="n">chart</span><span class="o">==</span><span class="s1">&#39;xak&#39;</span><span class="p">:</span>
      <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_atomic</span><span class="p">,</span> <span class="s1">&#39;the binding network is not atomic, cannot use xak chart&#39;</span>
      <span class="n">logx</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">logvar</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npts</span><span class="p">):</span>
        <span class="n">logders</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">logx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logder_xak_num</span><span class="p">(</span><span class="n">logvar</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">a_mat</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">chart</span><span class="o">==</span><span class="s1">&#39;tk&#39;</span><span class="p">:</span>
      <span class="n">logx</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">logvar</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npts</span><span class="p">):</span>
        <span class="n">logders</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">logx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logder_tk_num</span><span class="p">(</span><span class="n">logvar</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">a_mat</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> 
      <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;chart that is not one of &quot;x,xak,tk&quot; is not implemented yet&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">logders</span><span class="p">,</span><span class="n">logx</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">logder_x_num</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">logx</span><span class="p">,</span><span class="n">a_mat</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the numerical log derivative of the binding network at one point in chart x.</span>

<span class="sd">    Args:</span>
<span class="sd">        logx (numpy vector): Vector of concentrations for all the species in log, base-10.</span>
<span class="sd">        a_mat (numpy array): Matrix defining the variables log derivative is taken in terms of.</span>
<span class="sd">            Assumes all entries are non-negative, and each row has at least one positive entry.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray: Array of n-by-n matrix of log derivative of x to (t, k), where t = a_mat @ x, and n is the number of species.</span>
<span class="sd">            Shape is (n_points, dim_n, dim_n).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span><span class="o">=</span><span class="mi">10</span><span class="o">**</span><span class="n">logx</span>
    <span class="n">t_inv</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">a_mat</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="n">temp</span><span class="o">=</span><span class="n">a_mat</span><span class="o">*</span><span class="n">x</span>
    <span class="n">upper</span><span class="o">=</span><span class="p">(</span><span class="n">temp</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">t_inv</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="n">logder_inv</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">upper</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">n_mat</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">logder_inv</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
      <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
      <span class="nb">print</span><span class="p">(</span><span class="n">t_inv</span><span class="p">)</span>
      <span class="nb">print</span><span class="p">(</span><span class="n">logder_inv</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">logder_inv</span><span class="p">)</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">logder_xak_num</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">logxak</span><span class="p">,</span><span class="n">a_mat</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the numerical log derivative of dlog(x)/dlog(a_mat * x, k) at a point specified by log(xa, k), where xa is the concentration of atomic species, and k is the binding constants. log is base 10.</span>
<span class="sd">        Assumes the network is atomic, and n_mat, a_mat have atomic species coming first.</span>

<span class="sd">    Args:</span>
<span class="sd">        logxak (numpy vector): Vector numerical value for atomic species concentration (first dim_d entries) and binding reaction constants (last dim_r entries). Shape is (dim_n,).</span>
<span class="sd">            log is base 10.</span>
<span class="sd">        a_mat (numpy array): Matrix defining the variables log derivative is taken in terms of.</span>
<span class="sd">            Assumes all entries are non-negative, and each row has at least one positive entry.</span>

<span class="sd">    Returns:</span>
<span class="sd">        logder (ndarray): Array of n-by-n matrix of log derivative of x to (t, k), where t = a_mat @ x, and n is the number of species.</span>
<span class="sd">            Shape is (n_points, dim_n, dim_n).</span>
<span class="sd">        logx (ndarray): Array of logx that the logvar points correspond to. Shape is (n_points, dim_n).</span>
<span class="sd">            This is returned since all input variables, regardless of chart, are mapped to the logx chart first.</span>
<span class="sd">            Returned for convenience.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">## commented out are old code that directly calculate logx, now we use stored map.</span>
    <span class="c1"># d=self.dim_d</span>
    <span class="c1"># logxa=logxak[:d]</span>
    <span class="c1"># logk=logxak[d:]</span>
    <span class="c1"># temp1=(a_mat.T).dot(logxa)</span>
    <span class="c1"># n2_mat=self.n_mat[:,d:]</span>
    <span class="c1"># temp2=np.linalg.inv(n2_mat).dot(logk)</span>
    <span class="c1"># logx=temp1 + np.pad(temp2,(d,0),mode=&#39;constant&#39;,constant_values=(0,0))</span>

    <span class="n">logx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xak2x_num</span><span class="p">(</span><span class="n">logxak</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">logder_x_num</span><span class="p">(</span><span class="n">logx</span><span class="p">,</span><span class="n">a_mat</span><span class="p">),</span><span class="n">logx</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">logder_tk_num</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">logtk</span><span class="p">,</span><span class="n">a_mat</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the numerical log derivative of dlog(x)/dlog(a_mat @ x, k) at a point specified by log(t, k), where t = a_mat @ x is the concentration of atomic species, and k is the binding constants. log is base 10.</span>

<span class="sd">    Args:</span>
<span class="sd">        logtk (numpy vector): Vector numerical value for total concentration (first dim_d entries) and binding reaction constants (last dim_r entries). Shape is (dim_n,).</span>
<span class="sd">            log is base 10.</span>
<span class="sd">        a_mat (numpy array): Matrix defining the variables log derivative is taken in terms of.</span>
<span class="sd">            Assumes all entries are non-negative, and each row has at least one positive entry.</span>

<span class="sd">    Returns:</span>
<span class="sd">        logder (ndarray): Array of n-by-n matrix of log derivative of x to (t, k), where t = a_mat @ x, and n is the number of species.</span>
<span class="sd">            Shape is (n_points, dim_n, dim_n).</span>
<span class="sd">        logx (ndarray): Array of logx that the logvar points correspond to. Shape is (n_points, dim_n).</span>
<span class="sd">            This is returned since all input variables, regardless of chart, are mapped to the logx chart first.</span>
<span class="sd">            Returned for convenience.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">logx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tk2x_num</span><span class="p">(</span><span class="n">logtk</span><span class="p">,</span><span class="n">a_mat</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">logder_x_num</span><span class="p">(</span><span class="n">logx</span><span class="p">,</span><span class="n">a_mat</span><span class="p">),</span><span class="n">logx</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">logder_activity_num</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">b_vec</span><span class="p">,</span><span class="n">logx_array</span><span class="p">,</span><span class="n">ld_mat_array</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a logder matrix, compute the logder of b^T x.</span>

<span class="sd">    Args:</span>
<span class="sd">        b_vec (numpy vector): Vector indicating which species are included in the catalytic activity. Shape is (dim_n,).</span>
<span class="sd">            All entries are non-negative, with at least one nonzero.</span>
<span class="sd">        logx_array (ndarray): Array of logx-vector indicating the point at which the logder is evaluated. Shape is (n_points, dim_n).</span>
<span class="sd">            log is base 10.</span>
<span class="sd">        ld_mat_array (ndarray): Array of n x n matrix for dlogx/dlog(t, k) at point x on the manifold. Shape is (n_points, dim_n, dim_n).</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray: Array of vectors for dlog(b^T x)/dlog(t, k). Shape is (n_points, dim_n).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">b_vec</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">),</span> <span class="s2">&quot;all entries of b_vec should be non-negative.&quot;</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">b_vec</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;there should be at least one nonzero entry in b_vec.&quot;</span>
    <span class="n">x_array</span><span class="o">=</span><span class="mi">10</span><span class="o">**</span><span class="n">logx_array</span> <span class="c1"># shape (n_points,dim_n)</span>
    <span class="n">bx_array</span><span class="o">=</span><span class="n">x_array</span><span class="o">*</span><span class="n">b_vec</span> <span class="c1"># each row element-wise product with b_vec</span>
    <span class="c1"># so bx_array has shape (n_points,dim_n)</span>
    <span class="n">coeff</span><span class="o">=</span><span class="p">(</span><span class="n">bx_array</span><span class="o">.</span><span class="n">T</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bx_array</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">T</span> <span class="c1"># shape (n_points,dim_n)</span>
    <span class="n">npts</span><span class="o">=</span><span class="n">logx_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># One implementation is iterate and sum, this is slow (not really?).</span>
    <span class="n">ld_activity</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">npts</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_n</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npts</span><span class="p">):</span>
      <span class="n">ld_activity</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">coeff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ld_mat_array</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="c1"># Another implementation is directly writing out the product</span>
    <span class="c1"># coeff_temp=np.repeat(coeff[:,:,np.newaxis],self.dim_n,axis=2)</span>
    <span class="c1"># ld_activity=(ld_mat_array*coeff_temp).sum(-1)</span>

    <span class="c1"># Yet another way is to use einsum. Will do these if speed is a problem.</span>

    <span class="k">return</span> <span class="n">ld_activity</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">x2tk_num</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">logx</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the (logt, logk) value given logx.</span>

<span class="sd">    Args:</span>
<span class="sd">        logx (numpy vector): Vector numerical value for total variables that define the x point.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing two numpy vectors:</span>
<span class="sd">            - logt: The numerical value of total concentration at this point. log is base 10.</span>
<span class="sd">            - logk: The numerical value of binding constants at this point. log is base 10.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">logt</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l_mat</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="n">logx</span><span class="p">))</span>
    <span class="n">logk</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_mat</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">logx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">logt</span><span class="p">,</span><span class="n">logk</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">xak2x_num</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">logxak</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the logx value given logxak = (logxa, logk).</span>

<span class="sd">    Args:</span>
<span class="sd">        logxak (numpy vector): Vector numerical value for atomic species concentration (first dim_d entries) and binding reaction constants (last dim_r entries). Shape is (dim_n,).</span>
<span class="sd">            log is base 10.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy vector: The numerical value of logx at this point.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span> <span class="n">xak2x_map</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xak2x_map</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">calc_xak2x_map</span><span class="p">()</span> <span class="c1"># if doesn&#39;t exist, calculate it</span>
      <span class="n">xak2x_map</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xak2x_map</span>
    <span class="k">return</span> <span class="n">xak2x_map</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">logxak</span><span class="p">)</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">calc_xak2x_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># Defines the matrix (linear map) that takes log(xa,k) to log(x)</span>
    <span class="c1"># and stores it in self.xak2x_map</span>
    <span class="n">d</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_d</span>
    <span class="n">r</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_r</span>
    <span class="n">l2_mat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">l_mat</span><span class="p">[:,</span><span class="n">d</span><span class="p">:]</span>
    <span class="n">n2_mat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_mat</span><span class="p">[:,</span><span class="n">d</span><span class="p">:]</span>
    <span class="n">upper</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">d</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">d</span><span class="p">,</span><span class="n">r</span><span class="p">))),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">lower</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">l2_mat</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">n2_mat</span><span class="p">)),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">temp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">upper</span><span class="p">,</span><span class="n">lower</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">xak2x_map</span><span class="o">=</span><span class="n">temp</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">tk2x_num</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">logtk</span><span class="p">,</span><span class="n">a_mat</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the logx value by numerical integration along the equilibrium manifold using log derivatives. The point on the manifold defined by logtk = (logt, logk) is the same as that defined by logx.</span>

<span class="sd">    Args:</span>
<span class="sd">        logtk (numpy vector): Vector numerical value for total variables (in first dim_d entries) and the binding reaction constants (in last dim_r entries) that define the point. </span>
<span class="sd">            p_(logx) = p_(logt, logk). Shape is (dim_n,). log is base 10.</span>
<span class="sd">        a_mat (numpy array): The matrix defining the total variables t = a_mat @ x that the log derivatives are taken with respect to.</span>
<span class="sd">            Default should be specified to be self.l_mat.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy vector: The numerical value of x at this point. log is base 10.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># the initial point is always x=1, (t,k) = (A*1, 1)</span>
    <span class="c1"># or, in log, logx=0, (logt,logk) = (log(A*1),0)</span>

    <span class="n">logt0</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a_mat</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">logk0</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_r</span><span class="p">)</span>
    <span class="n">y0</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">logt0</span><span class="p">,</span><span class="n">logk0</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">y1</span><span class="o">=</span><span class="n">logtk</span>
    <span class="n">logx0</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_n</span><span class="p">)</span>
    <span class="c1"># The time is pseudo time, parameterizing trajectory from y0 to y1,</span>
    <span class="c1"># where y0=(logt0,logk0) = (log(A*1),0), and y1=(logt,logk) the input.</span>
    <span class="c1"># So a point on the trajectory is gamma(tau) = tau*(y1-y0)+y0, 0&lt;=tau&lt;=1.</span>
    <span class="c1"># The time derivative is therefore</span>
    <span class="c1"># dlogx/dtau (x0) = dlogx/dlog(t,k) (x0) * dlog(t,k)/dtau (x0)</span>
    <span class="c1">#                 = dlogx/dlog(t,k) (x0) * (y1-y0)</span>
    <span class="c1"># dlogx/dlog(t,k) (x0) is log derivative matrix evaluated at x0.</span>
    <span class="n">time_derivative_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">tau</span><span class="p">,</span><span class="n">logx</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">logder_x_num</span><span class="p">(</span><span class="n">logx</span><span class="p">,</span><span class="n">a_mat</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">y1</span><span class="o">-</span><span class="n">y0</span><span class="p">)</span>
    <span class="n">sol</span><span class="o">=</span><span class="n">solve_ivp</span><span class="p">(</span><span class="n">time_derivative_func</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">logx0</span><span class="p">)</span>
    <span class="n">logx</span><span class="o">=</span><span class="n">sol</span><span class="o">.</span><span class="n">y</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">logx</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">logder_tk2x_num</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">logvar</span><span class="p">,</span><span class="n">chart</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="n">a_mat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the numerical dlog(t, k)/dlog(x) log derivative of the binding network at points specified by logvar in the specified chart and dominance a_mat.</span>

<span class="sd">    Args:</span>
<span class="sd">        logvar (ndarray): Array of the points to evaluate the log derivatives at, in base-10 log. Shape is (n_points, dim_n).</span>
<span class="sd">            In chart &#39;x&#39;, for example, this is logx.</span>
<span class="sd">        chart (str): Specifying the chart that logvar is specified in. Could be &#39;x&#39;, &#39;xak&#39;, or &#39;tk&#39;.</span>
<span class="sd">        a_mat (numpy array, optional): Matrix defining the variables log derivative is taken in terms of.</span>
<span class="sd">            Assumes all entries are non-negative, and each row has at least one positive entry.</span>
<span class="sd">            Optional, defaults to l_mat of the binding network.</span>

<span class="sd">    Returns:</span>
<span class="sd">        logder (ndarray): Array of n-by-n matrix of log derivative of (t, k) to x, where t = a_mat @ x, and n is the number of species.</span>
<span class="sd">            Shape is (n_points, dim_n, dim_n).</span>
<span class="sd">        logx (ndarray): Array of logx that the logvar points correspond to. Shape is (n_points, dim_n).</span>
<span class="sd">            This is returned since all input variables, regardless of chart, are mapped to the logx chart first.</span>
<span class="sd">            Returned for convenience.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># first check a_mat makes sense.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">a_mat</span><span class="p">):</span> <span class="c1"># no a_mat argument is given</span>
      <span class="n">a_mat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">l_mat</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">assert</span> <span class="n">a_mat</span><span class="o">.</span><span class="n">shape</span><span class="o">==</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_d</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_n</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;the shape of L matrix should be </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_d</span><span class="si">}</span><span class="s2"> by </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_n</span><span class="si">}</span><span class="s2">.&quot;</span>
      <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">a_mat</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">),</span> <span class="s2">&quot;all entries of A matrix should be non-negative.&quot;</span>
      <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">a_mat</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_n</span><span class="p">))</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">),</span> <span class="s2">&quot;each row of A matrix should have at least one positive entry.&quot;</span>
    <span class="c1"># for different charts, use different functions to evaluate</span>
    <span class="n">npts</span><span class="o">=</span><span class="n">logvar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">logvar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_n</span><span class="p">,</span> <span class="s1">&#39;shape of logvar should be num_points-by-dim_n&#39;</span>
    <span class="n">logders</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">logvar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_n</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_n</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">chart</span><span class="o">==</span><span class="s1">&#39;x&#39;</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npts</span><span class="p">):</span>
        <span class="n">logders</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logder_tk2x_x_num</span><span class="p">(</span><span class="n">logvar</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">a_mat</span><span class="p">)</span>
      <span class="n">logx</span><span class="o">=</span><span class="n">logvar</span>
    <span class="k">elif</span> <span class="n">chart</span><span class="o">==</span><span class="s1">&#39;xak&#39;</span><span class="p">:</span>
      <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_atomic</span><span class="p">,</span> <span class="s1">&#39;the binding network is not atomic, cannot use xak chart&#39;</span>
      <span class="n">logx</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">logvar</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npts</span><span class="p">):</span>
        <span class="n">logx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xak2x_num</span><span class="p">(</span><span class="n">logvar</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">logders</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logder_tk2x_x_num</span><span class="p">(</span><span class="n">logx</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">a_mat</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">chart</span><span class="o">==</span><span class="s1">&#39;tk&#39;</span><span class="p">:</span>
      <span class="n">logx</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">logvar</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npts</span><span class="p">):</span>
        <span class="n">logx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tk2x_num</span><span class="p">(</span><span class="n">logvar</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">a_mat</span><span class="p">)</span>
        <span class="n">logders</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logder_tk2x_x_num</span><span class="p">(</span><span class="n">logvar</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">a_mat</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> 
      <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;chart that is not one of &quot;x,xak,tk&quot; is not implemented yet&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">logders</span><span class="p">,</span><span class="n">logx</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">logder_tk2x_x_num</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">logx</span><span class="p">,</span><span class="n">a_mat</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the numerical dlog(t, k)/dlog(x) log derivative of the binding network at one point in chart x.</span>

<span class="sd">    Args:</span>
<span class="sd">        logx (numpy vector): Vector of concentrations for all the species in log, base-10.</span>
<span class="sd">        a_mat (numpy array): Matrix defining the variables log derivative is taken in terms of.</span>
<span class="sd">            Assumes all entries are non-negative, and each row has at least one positive entry.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray: Array of n-by-n matrix of log derivative of (t, k) to x, where t = a_mat @ x, and n is the number of species.</span>
<span class="sd">            Shape is (n_points, dim_n, dim_n).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span><span class="o">=</span><span class="mi">10</span><span class="o">**</span><span class="n">logx</span>
    <span class="n">t_inv</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">a_mat</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="n">temp</span><span class="o">=</span><span class="n">a_mat</span><span class="o">*</span><span class="n">x</span>
    <span class="n">upper</span><span class="o">=</span><span class="p">(</span><span class="n">temp</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">t_inv</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="n">logder</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">upper</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">n_mat</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">logder</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">get_complex_ss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logk</span><span class="p">,</span> <span class="n">logx</span><span class="p">):</span>
    <span class="n">n1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_mat</span><span class="p">[:,</span> <span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">logx</span><span class="p">)]</span>
    <span class="n">n2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_mat</span><span class="p">[:,</span> <span class="nb">len</span><span class="p">(</span><span class="n">logx</span><span class="p">):</span> <span class="p">]</span>
    <span class="n">n2_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">n2</span><span class="p">)</span>
    <span class="n">logx_complex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">n2_inv</span><span class="p">,</span> <span class="p">(</span><span class="n">logk</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">logx</span><span class="p">)))</span>

    <span class="k">return</span> <span class="mi">10</span> <span class="o">**</span> <span class="n">logx_complex</span>



<span class="c1"># BELOW ARE VERTEX RELATED METHODS</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">vertex_construct</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct the rop_vertex objects that this binding network can have, compute their orientation and feasibility (without additional constraints), and store them in self.vertex_dict.</span>
<span class="sd">    Then the vertices&#39; neighbors, log derivative, and c_mat_xak are computed and stored in these objects.</span>

<span class="sd">    Args:</span>
<span class="sd">        None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None. The vertices are recorded in self.vertex_dict and by updating the vertex objects.</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="c1"># Construct a dictionary of reachable vertices.</span>
    <span class="c1"># because l_mat tends to be sparse, we iterate through its rows to get nonzero indices,</span>
    <span class="c1"># then each vertex&#39;s dominance condition a_mat is choosen from the nonezro indices.</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Constructing vertex objects and test for feasibility...&#39;</span><span class="p">)</span>
    <span class="n">d</span><span class="p">,</span><span class="n">n</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">l_mat</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">orientation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">orientation</span>
    <span class="n">nnz_list</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
      <span class="n">nnz_list</span><span class="o">=</span><span class="n">nnz_list</span><span class="o">+</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l_mat</span><span class="p">[</span><span class="n">i</span><span class="p">,:])[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">vertex_inf_dict</span><span class="o">=</span><span class="p">{}</span>
    <span class="n">vertex_fin_dict</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">perm</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">nnz_list</span><span class="p">):</span>
      <span class="n">vertex</span><span class="o">=</span><span class="n">rop_vertex</span><span class="p">(</span><span class="n">perm</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">vertex</span><span class="o">.</span><span class="n">orientation</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="c1"># this is possibly an infinite vertex</span>
        <span class="c1"># check for rank =1, meaning perm has exactly one repeat</span>
        <span class="n">perm_count</span><span class="o">=</span><span class="p">[</span><span class="n">perm</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">)]</span>
        <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">perm_count</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">perm_count</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span> <span class="c1"># because that same value shows up twice, each with count 2.</span>
            <span class="c1"># after all that check, there still can be infinite vertices that are not reachable</span>
            <span class="c1"># so we do feasibility test.</span>
            <span class="n">is_feasible</span><span class="o">=</span><span class="n">vertex</span><span class="o">.</span><span class="n">vertex_feasibility_test</span><span class="p">(</span><span class="n">chart</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="n">opt_constraints</span><span class="o">=</span><span class="p">[])</span>
            <span class="c1"># and then add to vertex_inf_dict.</span>
            <span class="k">if</span> <span class="n">is_feasible</span><span class="p">:</span>
              <span class="n">vertex_inf_dict</span><span class="p">[</span><span class="n">perm</span><span class="p">]</span><span class="o">=</span><span class="n">vertex</span>
      <span class="k">elif</span> <span class="n">vertex</span><span class="o">.</span><span class="n">orientation</span><span class="o">==</span><span class="n">orientation</span><span class="p">:</span>
        <span class="c1"># this is a finite vertex with the right orientation</span>
        <span class="c1"># we test for feasibility</span>
        <span class="n">is_feasible</span><span class="o">=</span><span class="n">vertex</span><span class="o">.</span><span class="n">vertex_feasibility_test</span><span class="p">(</span><span class="n">chart</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="n">opt_constraints</span><span class="o">=</span><span class="p">[])</span>
        <span class="c1"># and then add to vertex_fin_dict.</span>
        <span class="k">if</span> <span class="n">is_feasible</span><span class="p">:</span>
          <span class="n">vertex_fin_dict</span><span class="p">[</span><span class="n">perm</span><span class="p">]</span><span class="o">=</span><span class="n">vertex</span>
    <span class="n">vertex_dict</span><span class="o">=</span><span class="p">{</span><span class="o">**</span><span class="n">vertex_fin_dict</span><span class="p">,</span><span class="o">**</span><span class="n">vertex_inf_dict</span><span class="p">}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">vertex_dict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;all&#39;</span><span class="p">:</span><span class="n">vertex_dict</span><span class="p">,</span><span class="s1">&#39;finite&#39;</span><span class="p">:</span><span class="n">vertex_fin_dict</span><span class="p">,</span><span class="s1">&#39;infinite&#39;</span><span class="p">:</span><span class="n">vertex_inf_dict</span><span class="p">}</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Finished vertex construction, now computing neighbors of vertices...&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">perm</span><span class="p">,</span><span class="n">vv</span> <span class="ow">in</span> <span class="n">vertex_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
      <span class="n">vv</span><span class="o">.</span><span class="n">vertex_find_neighbors</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Finished neighbors, now computing log derivatives...&#39;</span><span class="p">)</span>
    <span class="c1"># first compute log der for finite vertices, since infinite ones rely on</span>
    <span class="c1"># finite neighbors to find orientation.</span>
    <span class="k">for</span> <span class="n">perm</span><span class="p">,</span><span class="n">vv</span> <span class="ow">in</span> <span class="n">vertex_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
      <span class="n">vv</span><span class="o">.</span><span class="n">vertex_ld_calc</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Finished log derivatives, now computing c_mat_xak&#39;</span><span class="p">)</span>
    <span class="c1"># compute c_mat_xak for each vertex in preparation for feasibility tests.</span>
    <span class="k">for</span> <span class="n">perm</span><span class="p">,</span><span class="n">vv</span> <span class="ow">in</span> <span class="n">vertex_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
      <span class="n">vv</span><span class="o">.</span><span class="n">vertex_c_mat_xak_calc</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Done.&#39;</span><span class="p">)</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">__get_dom_vec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">a_mat</span><span class="p">,</span><span class="n">not_dominated_col_idx</span><span class="p">,</span><span class="n">dominated_row_vec_prev</span><span class="p">,</span><span class="n">dom_tuple_prev</span><span class="p">):</span>
    <span class="n">perm_dict_add</span><span class="o">=</span><span class="p">{}</span> <span class="c1"># use dictionary to make sure repeated ones are combined.</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">not_dominated_col_idx</span><span class="p">:</span>
      <span class="n">dominated_row_j</span> <span class="o">=</span> <span class="n">a_mat</span><span class="p">[:,</span><span class="n">j</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span>
      <span class="n">dominated_row_vec_new</span> <span class="o">=</span> <span class="n">dominated_row_j</span> <span class="o">-</span> <span class="n">dominated_row_j</span> <span class="o">*</span> <span class="n">dominated_row_vec_prev</span>
      <span class="n">dominated_row_idx_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dominated_row_vec_new</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
      <span class="n">dom_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dom_tuple_prev</span><span class="p">)</span>
      <span class="n">dom_vec</span><span class="p">[</span><span class="n">dominated_row_idx_new</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
      <span class="n">dominated_row_vec_now</span> <span class="o">=</span> <span class="n">dominated_row_vec_prev</span> <span class="o">+</span> <span class="n">dominated_row_vec_new</span>
      <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dominated_row_vec_now</span><span class="p">)</span><span class="o">&lt;</span><span class="n">a_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="c1"># there are rows not yet dominated</span>
        <span class="n">not_dominated_row_idx_next</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">dominated_row_vec_now</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># then we combine all the rows not yet dominated to find the </span>
        <span class="c1">#   columns not yet dominated. This could result in previously </span>
        <span class="c1">#   already discovered dominance regimes to be counted again.</span>
        <span class="n">not_dominated_col_idx_next</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a_mat</span><span class="p">[</span><span class="n">not_dominated_row_idx_next</span><span class="p">,:],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">perm_dict_add_next</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_dom_vec</span><span class="p">(</span><span class="n">a_mat</span><span class="p">,</span><span class="n">not_dominated_col_idx_next</span><span class="p">,</span><span class="n">dominated_row_vec_now</span><span class="p">,</span><span class="nb">tuple</span><span class="p">(</span><span class="n">dom_vec</span><span class="p">))</span>
        <span class="n">perm_dict_add</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">perm_dict_add_next</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span> <span class="c1"># all rows are dominated</span>
        <span class="n">perm_dict_add</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">dom_vec</span><span class="p">)]</span><span class="o">=</span><span class="kc">True</span>
    <span class="k">return</span> <span class="n">perm_dict_add</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">vertex_construct_direct</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct the rop_vertex objects that this binding network can have, directly, without feasibility test.</span>

<span class="sd">    Args:</span>
<span class="sd">        None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None. The vertices are recorded in self.vertex_dict and by updating the vertex objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># We construct the vertices by iteratively construct all the possible</span>
    <span class="c1"># dominance vector (perm).</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Constructing vertex objects DIRECTLY...&#39;</span><span class="p">)</span>
    <span class="n">a_mat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">l_mat</span>
    <span class="n">d</span><span class="p">,</span><span class="n">n</span><span class="o">=</span><span class="n">a_mat</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">not_dominated_col_idx</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="n">dominated_row_vec_prev</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="n">dom_tuple_prev</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
    <span class="n">perm_dict</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__get_dom_vec</span><span class="p">(</span><span class="n">a_mat</span><span class="p">,</span><span class="n">not_dominated_col_idx</span><span class="p">,</span><span class="n">dominated_row_vec_prev</span><span class="p">,</span><span class="n">dom_tuple_prev</span><span class="p">)</span>
    <span class="n">vertex_fin_dict</span><span class="o">=</span><span class="p">{}</span>
    <span class="n">vertex_inf_dict</span><span class="o">=</span><span class="p">{}</span>
    <span class="n">vertex_infHO_dict</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">perm</span> <span class="ow">in</span> <span class="n">perm_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
      <span class="n">vertex</span><span class="o">=</span><span class="n">rop_vertex</span><span class="p">(</span><span class="n">perm</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span>
      <span class="n">repeat_vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">vertex</span><span class="o">.</span><span class="n">p_mat</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">vertex</span><span class="o">.</span><span class="n">orientation</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">vertex_fin_dict</span><span class="p">[</span><span class="n">perm</span><span class="p">]</span><span class="o">=</span><span class="n">vertex</span>
      <span class="c1"># elif np.max(repeat_vec)&gt;2 or np.sum(repeat_vec&gt;1) &gt;=2:</span>
        <span class="c1"># there is an index repeated 3 or more times, OR there are more than two indices repeated twice or above;</span>
        <span class="c1"># So this is an infinite vertex of higher order.</span>
      <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">repeat_vec</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">repeat_vec</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]])</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">:</span>
        <span class="c1"># another way to test for higher order is the sum of repeated indices&#39; total repeated times is &gt;2.</span>
        <span class="n">vertex_infHO_dict</span><span class="p">[</span><span class="n">perm</span><span class="p">]</span><span class="o">=</span><span class="n">vertex</span>
      <span class="k">else</span><span class="p">:</span> <span class="c1">#infinite vertex of order one</span>
        <span class="n">vertex_inf_dict</span><span class="p">[</span><span class="n">perm</span><span class="p">]</span><span class="o">=</span><span class="n">vertex</span>
    <span class="n">vertex_dict</span><span class="o">=</span><span class="p">{</span><span class="o">**</span><span class="n">vertex_fin_dict</span><span class="p">,</span><span class="o">**</span><span class="n">vertex_inf_dict</span><span class="p">}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">vertex_dict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;all&#39;</span><span class="p">:</span><span class="n">vertex_dict</span><span class="p">,</span><span class="s1">&#39;finite&#39;</span><span class="p">:</span><span class="n">vertex_fin_dict</span><span class="p">,</span><span class="s1">&#39;infinite&#39;</span><span class="p">:</span><span class="n">vertex_inf_dict</span><span class="p">,</span><span class="s1">&#39;infiniteHO&#39;</span><span class="p">:</span><span class="n">vertex_infHO_dict</span><span class="p">}</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Finished vertex construction, now computing neighbors of vertices...&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">perm</span><span class="p">,</span><span class="n">vv</span> <span class="ow">in</span> <span class="n">vertex_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
      <span class="n">vv</span><span class="o">.</span><span class="n">vertex_find_neighbors</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Finished neighbors, now computing log derivatives...&#39;</span><span class="p">)</span>
    <span class="c1"># first compute log der for finite vertices, since infinite ones rely on</span>
    <span class="c1"># finite neighbors to find orientation.</span>
    <span class="k">for</span> <span class="n">perm</span><span class="p">,</span><span class="n">vv</span> <span class="ow">in</span> <span class="n">vertex_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
      <span class="n">vv</span><span class="o">.</span><span class="n">vertex_ld_calc</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Finished log derivatives, now computing c_mat_xak&#39;</span><span class="p">)</span>
    <span class="c1"># compute c_mat_xak for each vertex in preparation for feasibility tests.</span>
    <span class="k">for</span> <span class="n">perm</span><span class="p">,</span><span class="n">vv</span> <span class="ow">in</span> <span class="n">vertex_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
      <span class="n">vv</span><span class="o">.</span><span class="n">vertex_c_mat_xak_calc</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Done.&#39;</span><span class="p">)</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">vertex_constrained_construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">opt_constraints</span><span class="p">,</span><span class="n">chart</span><span class="o">=</span><span class="s1">&#39;xak&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assuming self.vertex_dict is already computed, for given opt_constraints, this function computes whether the vertices are feasible under these constraints, updates rop_vertex.is_feasible for each vertex, and updates each vertex&#39;s feasible neighbors (stored in vertex.neighbors_constrained_dict). It returns is_feasible_dict, a dictionary of {perm: is_feasible} pairs.</span>
<span class="sd">    This function calls vertex_list_feasibility_test.</span>

<span class="sd">    Args:</span>
<span class="sd">        opt_constraints (list of cvxpy inequalities): List of constraints under which vertices are tested for feasibility.</span>
<span class="sd">        chart (str, optional): A string with value from {&#39;x&#39;, &#39;xak&#39;, &#39;tk&#39;} that specifies the chart that the opt_constraints are described in. Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: A dictionary of {perm: is_feasible} pairs indicating whether a vertex is feasible.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># for the given opt_constraints, test for each vertex whether it is feasible</span>
    <span class="c1"># under opt_constraints, and create a vertex dictionary for feasible vertices</span>
    <span class="c1"># under opt_constraints, stored in self.vertex_constrained_dict.</span>
    <span class="c1"># Also update each vertex&#39;s neighbors under constraints,</span>
    <span class="c1"># stored in each vertex.neighbors_constrained_dict.</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Compute feasible vertices...&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">perm</span><span class="p">,</span><span class="n">vv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_dict</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
      <span class="n">is_feasible</span><span class="o">=</span><span class="n">vv</span><span class="o">.</span><span class="n">vertex_feasibility_test</span><span class="p">(</span><span class="n">chart</span><span class="o">=</span><span class="n">chart</span><span class="p">,</span><span class="n">opt_constraints</span><span class="o">=</span><span class="n">opt_constraints</span><span class="p">)</span>
      <span class="n">vv</span><span class="o">.</span><span class="n">is_feasible</span><span class="o">=</span><span class="n">is_feasible</span>
    <span class="n">vertex_feasible_all</span><span class="o">=</span><span class="p">{</span><span class="n">perm</span><span class="p">:</span><span class="n">vv</span> <span class="k">for</span> <span class="n">perm</span><span class="p">,</span><span class="n">vv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_dict</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">vv</span><span class="o">.</span><span class="n">is_feasible</span><span class="p">}</span>
    <span class="n">vertex_feasible_fin</span><span class="o">=</span><span class="p">{</span><span class="n">perm</span><span class="p">:</span><span class="n">vv</span> <span class="k">for</span> <span class="n">perm</span><span class="p">,</span><span class="n">vv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_dict</span><span class="p">[</span><span class="s1">&#39;finite&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">vv</span><span class="o">.</span><span class="n">is_feasible</span><span class="p">}</span>
    <span class="n">vertex_feasible_inf</span><span class="o">=</span><span class="p">{</span><span class="n">perm</span><span class="p">:</span><span class="n">vv</span> <span class="k">for</span> <span class="n">perm</span><span class="p">,</span><span class="n">vv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_dict</span><span class="p">[</span><span class="s1">&#39;infinite&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">vv</span><span class="o">.</span><span class="n">is_feasible</span><span class="p">}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">vertex_constrained_dict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;all&#39;</span><span class="p">:</span><span class="n">vertex_feasible_all</span><span class="p">,</span><span class="s1">&#39;finite&#39;</span><span class="p">:</span><span class="n">vertex_feasible_fin</span><span class="p">,</span><span class="s1">&#39;infinite&#39;</span><span class="p">:</span><span class="n">vertex_feasible_inf</span><span class="p">}</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Compute neighbors under opt_constraints...&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">perm</span><span class="p">,</span><span class="n">vv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_dict</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
      <span class="k">if</span> <span class="n">vv</span><span class="o">.</span><span class="n">is_feasible</span><span class="p">:</span>
        <span class="c1"># if it is feasible, we want to look at its neighbors.</span>
        <span class="c1"># if a neighbor is feasible, it is still a neighbor under constraint.</span>
        <span class="c1"># if a neighbor is infeasible, we look at its neighbors to see whether</span>
        <span class="c1"># they are feasible. This recurses.</span>
        <span class="n">vv</span><span class="o">.</span><span class="n">vertex_update_constrained_neighbors</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Done.&#39;</span><span class="p">)</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">vertex_list_feasibility_test</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">opt_constraints</span><span class="p">,</span><span class="n">chart</span><span class="o">=</span><span class="s1">&#39;xak&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given opt_constraints, test all the vertices for their feasibility and return is_feasible_dict.</span>
<span class="sd">    This function is called by vertex_constrained_construct.</span>
<span class="sd">    It can also be directly called to test for feasibility without storing or finding feasible neighbors.</span>

<span class="sd">    Args:</span>
<span class="sd">        opt_constraints (list of cvxpy inequalities): List of constraints under which vertices are tested for feasibility.</span>
<span class="sd">        chart (str, optional): A string with value from {&#39;x&#39;, &#39;xak&#39;, &#39;tk&#39;} that specifies the chart that the opt_constraints are described in. Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: A dictionary of {perm: is_feasible} pairs indicating whether a vertex is feasible.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># for the given opt_constraints, test each of the vertex whether it is feasible</span>
    <span class="n">is_feasible_fin</span><span class="o">=</span><span class="p">{}</span>
    <span class="n">is_feasible_inf</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">perm</span><span class="p">,</span><span class="n">vv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_dict</span><span class="p">[</span><span class="s1">&#39;finite&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
      <span class="n">is_feasible</span><span class="o">=</span><span class="n">vv</span><span class="o">.</span><span class="n">vertex_feasibility_test</span><span class="p">(</span><span class="n">chart</span><span class="o">=</span><span class="n">chart</span><span class="p">,</span><span class="n">opt_constraints</span><span class="o">=</span><span class="n">opt_constraints</span><span class="p">)</span>
      <span class="n">is_feasible_fin</span><span class="p">[</span><span class="n">perm</span><span class="p">]</span><span class="o">=</span><span class="n">is_feasible</span>
    <span class="k">for</span> <span class="n">perm</span><span class="p">,</span><span class="n">vv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_dict</span><span class="p">[</span><span class="s1">&#39;infinite&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
      <span class="n">is_feasible</span><span class="o">=</span><span class="n">vv</span><span class="o">.</span><span class="n">vertex_feasibility_test</span><span class="p">(</span><span class="n">chart</span><span class="o">=</span><span class="n">chart</span><span class="p">,</span><span class="n">opt_constraints</span><span class="o">=</span><span class="n">opt_constraints</span><span class="p">)</span>
      <span class="n">is_feasible_inf</span><span class="p">[</span><span class="n">perm</span><span class="p">]</span><span class="o">=</span><span class="n">is_feasible</span>

    <span class="n">is_feasible_all</span><span class="o">=</span><span class="p">{</span><span class="o">**</span><span class="n">is_feasible_fin</span><span class="p">,</span><span class="o">**</span><span class="n">is_feasible_inf</span><span class="p">}</span>
    <span class="n">is_feasible_dict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;all&#39;</span><span class="p">:</span><span class="n">is_feasible_all</span><span class="p">,</span><span class="s1">&#39;finite&#39;</span><span class="p">:</span><span class="n">is_feasible_fin</span><span class="p">,</span><span class="s1">&#39;infinite&#39;</span><span class="p">:</span><span class="n">is_feasible_inf</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">is_feasible_dict</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">sampling_over_vertex_hull</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">nsample</span><span class="p">,</span><span class="n">vertex_perm_list</span><span class="o">=</span><span class="p">[],</span><span class="n">is_finite_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">chart</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="n">logmin</span><span class="o">=-</span><span class="mi">6</span><span class="p">,</span><span class="n">logmax</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span><span class="n">margin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">c_mat_extra</span><span class="o">=</span><span class="p">[],</span><span class="n">c0_vec_extra</span><span class="o">=</span><span class="p">[]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Randomly sample points in the log space of chart variables, but instead of log-uniform, we first assign points to each vertex in an even fashion, then sample uniformly within each vertex.</span>

<span class="sd">    Args:</span>
<span class="sd">        nsample (int): The number of points to be sampled in the space of chart variables.</span>
<span class="sd">            This is divided evenly to all the vertices of this binding network.</span>
<span class="sd">        is_finite_only (bool, optional): Useful only when vertex_perm_list=[], so that all vertices are sampled.</span>
<span class="sd">            If True, only finite vertices are sampled. This also allows chart &#39;tk&#39; to work.</span>
<span class="sd">            If False, both finite and infinite vertices are sampled. Defaults to False.</span>
<span class="sd">        vertex_perm_list (list of vertex&#39;s perm tuples, optional): The list of perms indexing the vertices to be sampled.</span>
<span class="sd">            e.g. [(0,1,2), (0,1,3)]. Defaults to empty list []. If empty, sample all vertices.</span>
<span class="sd">        chart (str, optional): A string indicating the chart that the opt_constraints are specified in.</span>
<span class="sd">            Choices are &#39;x&#39;, &#39;xak&#39;, and &#39;tk&#39;. Defaults to &#39;x&#39;.</span>
<span class="sd">        margin (float, optional): The vertex&#39;s feasibility conditions are inequalities,</span>
<span class="sd">            of the form c_mat * logx + c0_vec &gt; margin (e.g. in &#39;x&#39; chart),</span>
<span class="sd">            where margin is the positive threshold used here. Defaults to 0.</span>
<span class="sd">            This can be adjusted to be stronger/weaker requirements on dominance.</span>
<span class="sd">        logmin (float or ndarray vector): logmin, logmax could be scalars, then it&#39;s the same value applied to every variable.</span>
<span class="sd">            They could also be vectors of length dim_n.</span>
<span class="sd">        logmax (float or ndarray vector): logmin, logmax could be scalars, then it&#39;s the same value applied to every variable.</span>
<span class="sd">            They could also be vectors of length dim_n.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: A dictionary of ndarray with shape (nsample, dim_n).</span>
<span class="sd">            Key is the perm of each vertex. Value is the sample for that vertex.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># calculate number of vertex to be plotted and the dictionary of vertices.</span>
    <span class="n">vertex_plot_dict</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">if</span> <span class="n">vertex_perm_list</span><span class="p">:</span> <span class="c1"># vertex_perm_list is not empty</span>
      <span class="n">nvertex</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">vertex_perm_list</span><span class="p">)</span>
      <span class="k">for</span> <span class="n">perm</span> <span class="ow">in</span> <span class="n">vertex_perm_list</span><span class="p">:</span>
        <span class="n">vertex_plot_dict</span><span class="p">[</span><span class="n">perm</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex_dict</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">][</span><span class="n">perm</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1"># plot all vertices</span>
      <span class="k">if</span> <span class="n">is_finite_only</span><span class="p">:</span> 
        <span class="n">finite_key</span><span class="o">=</span><span class="s1">&#39;finite&#39;</span>
      <span class="k">else</span><span class="p">:</span> 
        <span class="n">finite_key</span><span class="o">=</span><span class="s1">&#39;all&#39;</span>
      <span class="n">nvertex</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex_dict</span><span class="p">[</span><span class="n">finite_key</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
      <span class="n">vertex_plot_dict</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex_dict</span><span class="p">[</span><span class="n">finite_key</span><span class="p">]</span>
    <span class="c1"># now sample each vertex.</span>
    <span class="n">nsample_per_vertex</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">nsample</span><span class="o">/</span><span class="n">nvertex</span><span class="p">)</span> <span class="c1"># take the floor for number of sample per vertex</span>
    <span class="n">sample_vertex_dict</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">vv</span> <span class="ow">in</span> <span class="n">vertex_plot_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
      <span class="nb">print</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
      <span class="n">sample_vertex_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="n">vv</span><span class="o">.</span><span class="n">vertex_hull_sampling</span><span class="p">(</span><span class="n">nsample_per_vertex</span><span class="p">,</span><span class="n">chart</span><span class="o">=</span><span class="n">chart</span><span class="p">,</span><span class="n">margin</span><span class="o">=</span><span class="n">margin</span><span class="p">,</span><span class="n">logmin</span><span class="o">=</span><span class="n">logmin</span><span class="p">,</span><span class="n">logmax</span><span class="o">=</span><span class="n">logmax</span><span class="p">,</span><span class="n">c_mat_extra</span><span class="o">=</span><span class="n">c_mat_extra</span><span class="p">,</span><span class="n">c0_vec_extra</span><span class="o">=</span><span class="n">c0_vec_extra</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sample_vertex_dict</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">sampling_over_activity_regime_hull</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">nsample</span><span class="p">,</span><span class="n">b_tuple</span><span class="p">,</span><span class="n">regime_key_list</span><span class="o">=</span><span class="p">[],</span><span class="n">is_finite_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">is_feasible_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">chart</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="n">logmin</span><span class="o">=-</span><span class="mi">6</span><span class="p">,</span><span class="n">logmax</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span><span class="n">margin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">c_mat_extra</span><span class="o">=</span><span class="p">[],</span><span class="n">c0_vec_extra</span><span class="o">=</span><span class="p">[]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Randomly sample points in the log space of chart variables for each dom_regime for a given activity, but instead of log-uniform, we first assign points to each vertex in an even fashion, then sample uniformly within each vertex.</span>

<span class="sd">    Args:</span>
<span class="sd">        nsample (int): The number of points to be sampled in the space of chart variables.</span>
<span class="sd">            This is divided evenly to all the vertices of this binding network.</span>
<span class="sd">        b_tuple (tuple of length dim_n): The b_tuple indicating the activity whose dom_regimes we are interested in sampling.</span>
<span class="sd">        is_finite_only (bool, optional): If True, only finite dom_regimes are sampled.</span>
<span class="sd">            If False, both finite and infinite dom_regimes are sampled. Defaults to False.</span>
<span class="sd">        regime_key_list (list of dominance regime&#39;s keys, optional): The list of keys for dom_regimes indexing the dom_regimes to be sampled.</span>
<span class="sd">            e.g. [((0,1,2),7), ((0,1,3),7)]. If empty, sample all dom_regimes. Defaults to empty list [].</span>
<span class="sd">        is_feasible_only (bool, optional): If True, only feasible dom_regimes are sampled.</span>
<span class="sd">            If False, all dom_regimes in regime_key_list (or all in this activity) are sampled.</span>
<span class="sd">            Each dom_regime&#39;s is_feasible tag comes from results of the most recent feasibility test.</span>
<span class="sd">        chart (str, optional): A string indicating the chart that the opt_constraints are specified in.</span>
<span class="sd">            Choices are &#39;x&#39;, &#39;xak&#39;, and &#39;tk&#39;. Defaults to &#39;x&#39;.</span>
<span class="sd">        margin (float, optional): The vertex&#39;s feasibility conditions are inequalities,</span>
<span class="sd">            of the form c_mat * logx + c0_vec &gt; margin (e.g. in &#39;x&#39; chart),</span>
<span class="sd">            where margin is the positive threshold used here. Defaults to 0.</span>
<span class="sd">            This can be adjusted to be stronger/weaker requirements on dominance.</span>
<span class="sd">        logmin (float or ndarray vector): logmin, logmax could be scalars, then it&#39;s the same value applied to every variable.</span>
<span class="sd">            They could also be vectors of length dim_n.</span>
<span class="sd">        logmax (float or ndarray vector): logmin, logmax could be scalars, then it&#39;s the same value applied to every variable.</span>
<span class="sd">            They could also be vectors of length dim_n.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: A dictionary of ndarray with shape (nsample, dim_n).</span>
<span class="sd">            Key is the perm of each vertex. Value is the sample for that vertex.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>
    <span class="c1"># # calculate number of vertex to be plotted and the dictionary of vertices.</span>
    <span class="c1"># vertex_plot_dict={}</span>
    <span class="c1"># if vertex_perm_list: # vertex_perm_list is not empty</span>
    <span class="c1">#   nvertex=len(vertex_perm_list)</span>
    <span class="c1">#   for perm in vertex_perm_list:</span>
    <span class="c1">#     vertex_plot_dict[perm]=self.vertex_dict[&#39;all&#39;][perm]</span>
    <span class="c1"># else: # plot all vertices</span>
    <span class="c1">#   if is_finite_only: </span>
    <span class="c1">#     finite_key=&#39;finite&#39;</span>
    <span class="c1">#   else: </span>
    <span class="c1">#     finite_key=&#39;all&#39;</span>
    <span class="c1">#   nvertex=len(self.vertex_dict[finite_key].keys())</span>
    <span class="c1">#   vertex_plot_dict=self.vertex_dict[finite_key]</span>
    <span class="c1"># # now sample each vertex.</span>
    <span class="c1"># nsample_per_vertex=int(nsample/nvertex) # take the floor for number of sample per vertex</span>
    <span class="c1"># sample_vertex_dict={}</span>
    <span class="c1"># for key,vv in vertex_plot_dict.items():</span>
    <span class="c1">#   sample_vertex_dict[key]=vv.vertex_hull_sampling(nsample_per_vertex,chart=chart,margin=margin,logmin=logmin,logmax=logmax)</span>
    <span class="c1"># return sample_vertex_dict</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">activity_regime_construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">b_vec</span><span class="p">):</span>
    <span class="c1"># given b_vec, go through all vertices and their possible regimes</span>
    <span class="c1"># test for basic feasibility, and return a dictionary of regimes</span>
    <span class="c1"># {(perm,row):regime}; perm is vertex, row is dominant species in activity (b_vec)</span>
    <span class="c1"># regime is an rop_dom_regime object.</span>
    <span class="n">b_vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">b_vec</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Computing feasible regimes...&#39;</span><span class="p">)</span>
    <span class="n">nnz_b</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">b_vec</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">regime_fin_dict</span><span class="o">=</span><span class="p">{}</span>
    <span class="n">regime_inf_dict</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">perm</span><span class="p">,</span><span class="n">vv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_dict</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
      <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">nnz_b</span><span class="p">:</span>
        <span class="n">regime</span><span class="o">=</span><span class="n">rop_dom_regime</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">b_vec</span><span class="p">,</span><span class="n">perm</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># if vv.orientation == 0 and np.all(regime.ld==0): #this is an infinite vertex in direction not relevant for this activity</span>
        <span class="c1">#   continue</span>
        <span class="n">is_feasible</span><span class="o">=</span><span class="n">regime</span><span class="o">.</span><span class="n">feasibility_test</span><span class="p">(</span><span class="n">chart</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="n">opt_constraints</span><span class="o">=</span><span class="p">[])</span>
        <span class="k">if</span> <span class="n">is_feasible</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">vv</span><span class="o">.</span><span class="n">orientation</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">regime_inf_dict</span><span class="p">[(</span><span class="n">perm</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span><span class="o">=</span><span class="n">regime</span>
          <span class="k">else</span><span class="p">:</span> <span class="n">regime_fin_dict</span><span class="p">[(</span><span class="n">perm</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span><span class="o">=</span><span class="n">regime</span>

    <span class="n">regime_all_dict</span><span class="o">=</span><span class="p">{</span><span class="o">**</span><span class="n">regime_fin_dict</span><span class="p">,</span><span class="o">**</span><span class="n">regime_inf_dict</span><span class="p">}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">activity_regime_dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">b_vec</span><span class="p">)]</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;finite&#39;</span><span class="p">:</span><span class="n">regime_fin_dict</span><span class="p">,</span>
                                            <span class="s1">&#39;infinite&#39;</span><span class="p">:</span><span class="n">regime_inf_dict</span><span class="p">,</span>
                                            <span class="s1">&#39;all&#39;</span><span class="p">:</span><span class="n">regime_all_dict</span><span class="p">}</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Feasible regime computed, computing their neighboring regimes...&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">regime</span> <span class="ow">in</span> <span class="n">regime_all_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
      <span class="n">regime</span><span class="o">.</span><span class="n">find_neighbors</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">regime</span> <span class="ow">in</span> <span class="n">regime_all_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
      <span class="n">regime</span><span class="o">.</span><span class="n">find_neighbors_zero</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Computing activity logder regimes dictionary... &#39;</span><span class="p">)</span>
    <span class="c1"># since several regimes will have the same log derivative, we use log derivative as key, rather than regimes.</span>
    <span class="n">ld_regime_fin_key_dict</span><span class="o">=</span><span class="p">{}</span>
    <span class="n">ld_regime_inf_key_dict</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">regime</span> <span class="ow">in</span> <span class="n">regime_fin_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
      <span class="k">try</span><span class="p">:</span> <span class="n">ld_regime_fin_key_dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">regime</span><span class="o">.</span><span class="n">ld</span><span class="p">)]</span><span class="o">+=</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="c1">#add regime to ld</span>
      <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span> <span class="n">ld_regime_fin_key_dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">regime</span><span class="o">.</span><span class="n">ld</span><span class="p">)]</span><span class="o">=</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="c1">#no regimes yet, initiate.</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">regime</span> <span class="ow">in</span> <span class="n">regime_inf_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
      <span class="k">try</span><span class="p">:</span> <span class="n">ld_regime_inf_key_dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">regime</span><span class="o">.</span><span class="n">ld</span><span class="p">)]</span><span class="o">+=</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="c1">#add regime to ld</span>
      <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span> <span class="n">ld_regime_inf_key_dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">regime</span><span class="o">.</span><span class="n">ld</span><span class="p">)]</span><span class="o">=</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="c1">#no regimes yet, initiate.</span>
    <span class="c1"># convert into dictionary of ld_regime objects</span>
    <span class="n">ld_regime_fin_dict</span><span class="o">=</span><span class="p">{}</span>
    <span class="n">ld_regime_inf_dict</span><span class="o">=</span><span class="p">{}</span>
    <span class="n">is_ray</span><span class="o">=</span><span class="kc">False</span>
    <span class="k">for</span> <span class="n">ld</span><span class="p">,</span><span class="n">regime_keys</span> <span class="ow">in</span> <span class="n">ld_regime_fin_key_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
      <span class="n">ld_regime</span><span class="o">=</span><span class="n">rop_ld_regime</span><span class="p">(</span><span class="n">ld</span><span class="p">,</span><span class="n">is_ray</span><span class="p">,</span><span class="n">b_vec</span><span class="p">,</span><span class="n">regime_keys</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span>
      <span class="n">ld_regime_fin_dict</span><span class="p">[</span><span class="n">ld</span><span class="p">]</span><span class="o">=</span><span class="n">ld_regime</span>
    <span class="n">is_ray</span><span class="o">=</span><span class="kc">True</span>
    <span class="k">for</span> <span class="n">ld</span><span class="p">,</span><span class="n">regime_keys</span> <span class="ow">in</span> <span class="n">ld_regime_inf_key_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
      <span class="n">ld_regime</span><span class="o">=</span><span class="n">rop_ld_regime</span><span class="p">(</span><span class="n">ld</span><span class="p">,</span><span class="n">is_ray</span><span class="p">,</span><span class="n">b_vec</span><span class="p">,</span><span class="n">regime_keys</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span>
      <span class="n">ld_regime_inf_dict</span><span class="p">[</span><span class="n">ld</span><span class="p">]</span><span class="o">=</span><span class="n">ld_regime</span>

    <span class="n">ld_regime_all_dict</span><span class="o">=</span><span class="p">{</span><span class="o">**</span><span class="n">ld_regime_fin_dict</span><span class="p">,</span><span class="o">**</span><span class="n">ld_regime_inf_dict</span><span class="p">}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">activity_ld_regime_dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">b_vec</span><span class="p">)]</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;finite&#39;</span><span class="p">:</span><span class="n">ld_regime_fin_dict</span><span class="p">,</span>
                                               <span class="s1">&#39;infinite&#39;</span><span class="p">:</span><span class="n">ld_regime_inf_dict</span><span class="p">,</span>
                                               <span class="s1">&#39;all&#39;</span><span class="p">:</span><span class="n">ld_regime_all_dict</span><span class="p">}</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Computing activity logder regimes neighbors... &#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">ld_regime</span> <span class="ow">in</span> <span class="n">ld_regime_all_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
      <span class="n">ld_regime</span><span class="o">.</span><span class="n">find_neighbors</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Done&#39;</span><span class="p">)</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">activity_regime_constrained_construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">b_vec</span><span class="p">,</span><span class="n">opt_constraints</span><span class="p">,</span><span class="n">chart</span><span class="o">=</span><span class="s1">&#39;xak&#39;</span><span class="p">):</span>
    <span class="c1"># For the given opt_constraints, test for each dom_regime whether it is</span>
    <span class="c1"># feasible, update their neighbors under constraint,</span>
    <span class="c1"># and create a dictionary for feasible dom_regimes, stored in</span>
    <span class="c1"># self.activity_regime_contrained_dict[b_vec].</span>
    <span class="c1"># and create a dictionary for feasible ld_regimes, stored in</span>
    <span class="c1"># self.activity_ld_regime_constrained_dict[b_vec].</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Compute dominance regimes&#39; feasibility...&quot;</span><span class="p">)</span>
    <span class="n">regime_constrained_fin</span><span class="o">=</span><span class="p">{}</span>
    <span class="n">regime_constrained_inf</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">regime</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">activity_regime_dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">b_vec</span><span class="p">)][</span><span class="s1">&#39;all&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
      <span class="n">is_feasible</span><span class="o">=</span><span class="n">regime</span><span class="o">.</span><span class="n">feasibility_test</span><span class="p">(</span><span class="n">chart</span><span class="o">=</span><span class="n">chart</span><span class="p">,</span><span class="n">opt_constraints</span><span class="o">=</span><span class="n">opt_constraints</span><span class="p">)</span>
      <span class="n">regime</span><span class="o">.</span><span class="n">is_feasible</span><span class="o">=</span><span class="n">is_feasible</span>
      <span class="k">if</span> <span class="n">is_feasible</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">regime</span><span class="o">.</span><span class="n">vertex</span><span class="o">.</span><span class="n">orientation</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
          <span class="n">regime_constrained_inf</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="n">regime</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">regime_constrained_fin</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="n">regime</span>
    <span class="n">regime_constrained_all</span><span class="o">=</span><span class="p">{</span><span class="o">**</span><span class="n">regime_constrained_fin</span><span class="p">,</span><span class="o">**</span><span class="n">regime_constrained_inf</span><span class="p">}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">activity_regime_constrained_dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">b_vec</span><span class="p">)]</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;all&#39;</span><span class="p">:</span><span class="n">regime_constrained_all</span><span class="p">,</span><span class="s1">&#39;finite&#39;</span><span class="p">:</span><span class="n">regime_constrained_fin</span><span class="p">,</span><span class="s1">&#39;infinite&#39;</span><span class="p">:</span><span class="n">regime_constrained_inf</span><span class="p">}</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Compute regimes&#39; neighboring regimes under opt_constraints...&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">regime</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">activity_regime_dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">b_vec</span><span class="p">)][</span><span class="s1">&#39;all&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
      <span class="k">if</span> <span class="n">regime</span><span class="o">.</span><span class="n">is_feasible</span><span class="p">:</span>
        <span class="c1"># if it is feasible, we want to look at its neighbors.</span>
        <span class="c1"># if a neighbor is feasible, it is still a neighbor.</span>
        <span class="c1"># if a neighbor is infeasible, we look at its neighbors to see whether</span>
        <span class="c1"># they are feasible.</span>
        <span class="n">regime</span><span class="o">.</span><span class="n">update_constrained_neighbors</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Compute ld regimes&#39; feasibility and compute neighbors under opt_constraints...&quot;</span><span class="p">)</span>
    <span class="n">ld_regime_constrained_fin</span><span class="o">=</span><span class="p">{}</span>
    <span class="n">ld_regime_constrained_inf</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">ld</span><span class="p">,</span><span class="n">ld_regime</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">activity_ld_regime_dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">b_vec</span><span class="p">)][</span><span class="s1">&#39;all&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
      <span class="n">ld_regime</span><span class="o">.</span><span class="n">update_feasibility</span><span class="p">()</span>
      <span class="k">if</span> <span class="n">ld_regime</span><span class="o">.</span><span class="n">is_feasible</span><span class="p">:</span>
        <span class="n">ld_regime</span><span class="o">.</span><span class="n">update_constrained_neighbors</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">ld_regime</span><span class="o">.</span><span class="n">is_ray</span><span class="p">:</span>
          <span class="n">ld_regime_constrained_inf</span><span class="p">[</span><span class="n">ld</span><span class="p">]</span><span class="o">=</span><span class="n">ld_regime</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">ld_regime_constrained_fin</span><span class="p">[</span><span class="n">ld</span><span class="p">]</span><span class="o">=</span><span class="n">ld_regime</span>
    <span class="n">ld_regime_constrained_all</span><span class="o">=</span><span class="p">{</span><span class="o">**</span><span class="n">ld_regime_constrained_fin</span><span class="p">,</span><span class="o">**</span><span class="n">ld_regime_constrained_inf</span><span class="p">}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">activity_ld_regime_constrained_dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">b_vec</span><span class="p">)]</span><span class="o">=</span><span class="p">{</span>
        <span class="s1">&#39;all&#39;</span><span class="p">:</span><span class="n">ld_regime_constrained_all</span><span class="p">,</span>
        <span class="s1">&#39;finite&#39;</span><span class="p">:</span><span class="n">ld_regime_constrained_fin</span><span class="p">,</span>
        <span class="s1">&#39;infinite&#39;</span><span class="p">:</span><span class="n">ld_regime_constrained_inf</span>
        <span class="p">}</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Done&#39;</span><span class="p">)</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">activity_list_feasibility_test</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">b_vec</span><span class="p">,</span><span class="n">opt_constraints</span><span class="p">,</span><span class="n">chart</span><span class="o">=</span><span class="s1">&#39;xak&#39;</span><span class="p">):</span>
    <span class="c1"># for the activity defined by b_vec (b_vec*x), and constraints given in</span>
    <span class="c1"># opt_constraints in chart (default xak), test each of the ld_regime</span>
    <span class="c1"># whether it is feasible.</span>
    <span class="c1"># A ld_regime is feasible if one of its dom_regime is feasible.</span>
    <span class="n">is_feasible_fin</span><span class="o">=</span><span class="p">{}</span>
    <span class="n">is_feasible_inf</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">ld</span><span class="p">,</span><span class="n">ld_regime</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">activity_ld_regime_dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">b_vec</span><span class="p">)][</span><span class="s1">&#39;finite&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
      <span class="n">is_feasible_dom_regime_list</span><span class="o">=</span><span class="p">[</span><span class="n">dom_regime</span><span class="o">.</span><span class="n">feasibility_test</span><span class="p">(</span><span class="n">chart</span><span class="o">=</span><span class="n">chart</span><span class="p">,</span><span class="n">opt_constraints</span><span class="o">=</span><span class="n">opt_constraints</span><span class="p">)</span> <span class="k">for</span> <span class="n">dom_regime</span> <span class="ow">in</span> <span class="n">ld_regime</span><span class="o">.</span><span class="n">dom_regime_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
      <span class="n">is_feasible</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">is_feasible_dom_regime_list</span><span class="p">)</span>
      <span class="n">is_feasible_fin</span><span class="p">[</span><span class="n">ld</span><span class="p">]</span><span class="o">=</span><span class="n">is_feasible</span>
    <span class="k">for</span> <span class="n">ld</span><span class="p">,</span><span class="n">ld_regime</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">activity_ld_regime_dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">b_vec</span><span class="p">)][</span><span class="s1">&#39;infinite&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
      <span class="n">is_feasible_dom_regime_list</span><span class="o">=</span><span class="p">[</span><span class="n">dom_regime</span><span class="o">.</span><span class="n">feasibility_test</span><span class="p">(</span><span class="n">chart</span><span class="o">=</span><span class="n">chart</span><span class="p">,</span><span class="n">opt_constraints</span><span class="o">=</span><span class="n">opt_constraints</span><span class="p">)</span> <span class="k">for</span> <span class="n">dom_regime</span> <span class="ow">in</span> <span class="n">ld_regime</span><span class="o">.</span><span class="n">dom_regime_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
      <span class="n">is_feasible</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">is_feasible_dom_regime_list</span><span class="p">)</span>
      <span class="n">is_feasible_inf</span><span class="p">[</span><span class="n">ld</span><span class="p">]</span><span class="o">=</span><span class="n">is_feasible</span>
    <span class="n">is_feasible_all</span><span class="o">=</span><span class="p">{</span><span class="o">**</span><span class="n">is_feasible_fin</span><span class="p">,</span><span class="o">**</span><span class="n">is_feasible_inf</span><span class="p">}</span>
    <span class="n">is_feasible_dict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;all&#39;</span><span class="p">:</span><span class="n">is_feasible_all</span><span class="p">,</span><span class="s1">&#39;finite&#39;</span><span class="p">:</span><span class="n">is_feasible_fin</span><span class="p">,</span><span class="s1">&#39;infinite&#39;</span><span class="p">:</span><span class="n">is_feasible_inf</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">is_feasible_dict</span>

<span class="c1"># BELOW ARE SYMBOLIC METHODS for the binding network</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">logder_sym</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">a_mat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span><span class="n">is_saved</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the symbolic log derivative matrix of dlog(x)/dlog(a_mat @ x, k).</span>

<span class="sd">    Args:</span>
<span class="sd">        a_mat (numpy array, optional): Matrix defining the variables log derivative is taken in terms of.</span>
<span class="sd">            Assumes all entries are non-negative, and each row has at least one positive entry.</span>
<span class="sd">            Optional, defaults to l_mat of the binding network.</span>
<span class="sd">        is_saved (bool, optional): To save the resulting logdermat as parameter ld_sym of the binding network or not.</span>
<span class="sd">            Defaults to True.</span>

<span class="sd">    Returns:</span>
<span class="sd">        sympy.Matrix: Symbolic log derivative matrix for x to (t_sym_temp, k_sym) expressed in terms of x.</span>

<span class="sd">    Note:</span>
<span class="sd">        If the provided a_mat yields a noninvertible matrix, then the function will return logdermat as a matrix of zeros (with the appropriate size).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">a_mat</span><span class="p">):</span> <span class="c1"># no a_mat argument is given</span>
      <span class="n">a_mat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">l_mat</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">assert</span> <span class="n">a_mat</span><span class="o">.</span><span class="n">shape</span><span class="o">==</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_d</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_n</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;the shape of L matrix should be </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_d</span><span class="si">}</span><span class="s2"> by </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_n</span><span class="si">}</span><span class="s2">.&quot;</span>
      <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">a_mat</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">),</span> <span class="s2">&quot;all entries of A matrix should be non-negative.&quot;</span>
      <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">a_mat</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_n</span><span class="p">))</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">),</span> <span class="s2">&quot;each row of A matrix should have at least one positive entry.&quot;</span>

    <span class="n">a_mat_sym</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">a_mat</span><span class="p">)</span>
    <span class="n">n_mat_sym</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_mat_sym</span>

    <span class="c1">#it&#39;s much faster (10x) to use a dummy &quot;total&quot; variables to calculate matrix inverse,</span>
    <span class="c1"># and then substitute the expression for the totals in terms of x, rather than</span>
    <span class="c1"># inverting with the totals explicitly expressed in x variables.</span>

    <span class="n">temp_sym</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;t:&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_d</span><span class="p">))</span>

    <span class="n">Lam_t</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="o">*</span><span class="n">temp_sym</span><span class="p">)</span>
    <span class="n">Lam_x</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">x_sym</span><span class="p">)</span>

    <span class="n">topmat</span> <span class="o">=</span> <span class="n">Lam_t</span><span class="o">**-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">a_mat_sym</span> <span class="o">*</span> <span class="n">Lam_x</span>
    <span class="n">fullmat</span> <span class="o">=</span> <span class="n">topmat</span><span class="o">.</span><span class="n">col_join</span><span class="p">(</span><span class="n">n_mat_sym</span><span class="p">)</span>

    <span class="n">logdermat_t</span> <span class="o">=</span> <span class="n">fullmat</span><span class="o">**-</span><span class="mi">1</span>

    <span class="n">temp_expr</span><span class="o">=</span><span class="n">a_mat_sym</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_sym</span><span class="p">)</span>
    <span class="n">temp2x_subs_list</span><span class="o">=</span><span class="p">[(</span><span class="n">temp_sym</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">temp_expr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_d</span><span class="p">)]</span>
    <span class="n">logdermat</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">logdermat_t</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">temp2x_subs_list</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">is_saved</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">ld_sym_dict</span><span class="p">[</span><span class="n">a_mat</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()]</span><span class="o">=</span><span class="n">logdermat</span>
    <span class="k">return</span> <span class="n">logdermat</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">subs_list_t2x</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">total_expr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">l_mat_sym</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_sym</span><span class="p">)</span>
    <span class="n">t2x_subs_list</span><span class="o">=</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">t_sym</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">total_expr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_d</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">t2x_subs_list</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">subs_list_xc2xak</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_atomic</span><span class="p">,</span> <span class="s2">&quot;this operation requires the binding network to be atomic&quot;</span>
    <span class="n">l2_mat_sym</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">l_mat_sym</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_d</span><span class="p">:]</span>
    <span class="n">n2_mat_sym</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_mat_sym</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_d</span><span class="p">:]</span>
    <span class="n">xa_sym_vec</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_sym</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_d</span><span class="p">])</span>
    <span class="n">xa_sym_log</span><span class="o">=</span><span class="n">xa_sym_vec</span><span class="o">.</span><span class="n">applyfunc</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">log</span><span class="p">)</span>
    <span class="n">xc2xak_log_expr</span><span class="o">=</span><span class="n">l2_mat_sym</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">xa_sym_log</span><span class="o">+</span><span class="n">n2_mat_sym</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k_sym</span><span class="p">)</span><span class="o">.</span><span class="n">applyfunc</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">log</span><span class="p">)</span>
    <span class="n">func_exponentiate</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">sp</span><span class="o">.</span><span class="n">E</span><span class="o">**</span><span class="n">x</span>
    <span class="n">xc2xak_expr</span><span class="o">=</span><span class="n">xc2xak_log_expr</span><span class="o">.</span><span class="n">applyfunc</span><span class="p">(</span><span class="n">func_exponentiate</span><span class="p">)</span>
    <span class="n">xc2xak_subs_list</span><span class="o">=</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_sym</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_d</span><span class="o">+</span><span class="n">i</span><span class="p">],</span><span class="n">xc2xak_expr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_r</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">xc2xak_subs_list</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">t2x_sym</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">expr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Input a symbolic expression containing totals t, and map it to x.</span>

<span class="sd">    Args:</span>
<span class="sd">        expr (sympy symbolic expression): A symbolic expression to be converted.</span>

<span class="sd">    Returns:</span>
<span class="sd">        sympy symbolic expression: The symbolic expression after conversion.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># calculate the substitutions map for totals to species</span>
    <span class="k">try</span><span class="p">:</span> <span class="n">expr_x</span><span class="o">=</span><span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t2x</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
      <span class="n">t2x_subs_list</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">subs_list_t2x</span><span class="p">()</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">t2x</span><span class="o">=</span><span class="n">t2x_subs_list</span>
      <span class="n">expr_x</span><span class="o">=</span><span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t2x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">expr_x</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">xc2xak_sym</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">expr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Input a symbolic expression containing complex species x^c, and map it to x^a and k.</span>

<span class="sd">    Args:</span>
<span class="sd">        expr (sympy symbolic expression): A symbolic expression to be converted.</span>

<span class="sd">    Returns:</span>
<span class="sd">        sympy symbolic expression: The symbolic expression after conversion.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_atomic</span><span class="p">,</span> <span class="s2">&quot;this operation requires the binding network to be atomic&quot;</span>
    <span class="c1"># calculate the substitutions map for complex species to atomic species and k&#39;s, if it does not exist.</span>
    <span class="k">try</span><span class="p">:</span> <span class="n">expr_xak</span><span class="o">=</span><span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xc2xak</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
      <span class="n">xc2xak_subs_list</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">subs_list_xc2xak</span><span class="p">()</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">xc2xak</span><span class="o">=</span><span class="n">xc2xak_subs_list</span>
      <span class="n">expr_xak</span><span class="o">=</span><span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xc2xak</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">expr_xak</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">logder_sym_activity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">b_vec_sym</span><span class="p">,</span><span class="n">a_mat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the log derivative of a linear sum of x, i.e. dlog(b_vec_sym * x)/dlog(tp, k), where tp = a_mat * x.</span>

<span class="sd">    Args:</span>
<span class="sd">        b_vec_sym (sympy symbolic vector): A vector of symbolic expressions corresponding to coefficients to be summed. Shape is (n, 1).</span>
<span class="sd">        a_mat (numpy array, optional): The matrix denoting the variables a_mat * x that the log derivative is taken with respect to.</span>
<span class="sd">            Defaults to self.l_mat.</span>

<span class="sd">    Returns:</span>
<span class="sd">        sympy vector: The symbolic log derivative dlog(b_vec_sym * x)/dlog(tp, k), where tp = a_mat * x.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">a_mat</span><span class="p">):</span> <span class="c1"># no a_mat argument is given</span>
      <span class="n">a_mat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">l_mat</span>
    <span class="c1"># check if logder is already calculated with respect to this a_mat.</span>
    <span class="k">try</span><span class="p">:</span> <span class="n">ld_sym</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ld_sym_dict</span><span class="p">[</span><span class="n">a_mat</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span> <span class="c1"># not calculated yet</span>
      <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Symbolic logder for this chart coordinate does not exist, calculating...&#39;</span><span class="p">)</span>
      <span class="n">ld_sym</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logder_sym</span><span class="p">(</span><span class="n">a_mat</span><span class="o">=</span><span class="n">a_mat</span><span class="p">)</span>
    <span class="n">coeff_vec_sym</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">b_vec_sym</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="n">bx</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">matrix_multiply_elementwise</span><span class="p">(</span><span class="n">b_vec_sym</span><span class="p">,</span><span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_sym</span><span class="p">))</span> <span class="c1">#b multiply x element-wise</span>
    <span class="n">bx_sum</span> <span class="o">=</span> <span class="n">bx</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="o">*</span><span class="n">bx</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">coeff_vec_sym</span><span class="o">=</span><span class="n">bx</span><span class="o">*</span><span class="n">bx_sum</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># convex coefficients for the log derivative sum</span>
    <span class="n">ld_sym_sum</span><span class="o">=</span><span class="p">(</span><span class="n">ld_sym</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">coeff_vec_sym</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="c1"># for logder matrix ld_sym, rows are species, columns are variables.</span>
    <span class="k">return</span> <span class="n">ld_sym_sum</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h3 id="bcn.binding_network.binding_network.__init__" class="doc doc-heading">
            <code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="n">n_mat</span><span class="p">,</span> <span class="n">l_mat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span> <span class="n">is_atomic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">x_sym</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span> <span class="n">t_sym</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span> <span class="n">k_sym</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Initiate a binding network.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>n_mat</code>
            </td>
            <td>
                  <code>numpy array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The stoichiometry matrix defining the binding network.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>is_atomic</code>
            </td>
            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Is the binding network atomic or not. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>l_mat</code>
            </td>
            <td>
                  <code>numpy array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The conservation law matrix defining the conserved total quantities.
If not given, and is_atomic is True, then it will be computed from n_mat. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code><span title="numpy.array">array</span>([])</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>x_sym</code>
            </td>
            <td>
                  <code>list of symbols</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>An ordered list of symbols for the chemical species, denoting columns of the n_mat and l_mat. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code><span title="numpy.array">array</span>([])</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>t_sym</code>
            </td>
            <td>
                  <code>list of symbols</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>An ordered list of symbols for the total or conserved quantities, denoting rows of the l_mat. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code><span title="numpy.array">array</span>([])</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>k_sym</code>
            </td>
            <td>
                  <code>list of symbols</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>An ordered list of symbols for the binding constants in the dissociation direction, denoting rows of the n_mat. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code><span title="numpy.array">array</span>([])</code>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/bcn/binding_network.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1069</span>
<span class="normal">1070</span>
<span class="normal">1071</span>
<span class="normal">1072</span>
<span class="normal">1073</span>
<span class="normal">1074</span>
<span class="normal">1075</span>
<span class="normal">1076</span>
<span class="normal">1077</span>
<span class="normal">1078</span>
<span class="normal">1079</span>
<span class="normal">1080</span>
<span class="normal">1081</span>
<span class="normal">1082</span>
<span class="normal">1083</span>
<span class="normal">1084</span>
<span class="normal">1085</span>
<span class="normal">1086</span>
<span class="normal">1087</span>
<span class="normal">1088</span>
<span class="normal">1089</span>
<span class="normal">1090</span>
<span class="normal">1091</span>
<span class="normal">1092</span>
<span class="normal">1093</span>
<span class="normal">1094</span>
<span class="normal">1095</span>
<span class="normal">1096</span>
<span class="normal">1097</span>
<span class="normal">1098</span>
<span class="normal">1099</span>
<span class="normal">1100</span>
<span class="normal">1101</span>
<span class="normal">1102</span>
<span class="normal">1103</span>
<span class="normal">1104</span>
<span class="normal">1105</span>
<span class="normal">1106</span>
<span class="normal">1107</span>
<span class="normal">1108</span>
<span class="normal">1109</span>
<span class="normal">1110</span>
<span class="normal">1111</span>
<span class="normal">1112</span>
<span class="normal">1113</span>
<span class="normal">1114</span>
<span class="normal">1115</span>
<span class="normal">1116</span>
<span class="normal">1117</span>
<span class="normal">1118</span>
<span class="normal">1119</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
             <span class="n">n_mat</span><span class="p">,</span>
             <span class="n">l_mat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span>
             <span class="n">is_atomic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">x_sym</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span>
             <span class="n">t_sym</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span>
             <span class="n">k_sym</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Initiate a binding network.</span>

<span class="sd">  Args:</span>
<span class="sd">      n_mat (numpy array): The stoichiometry matrix defining the binding network.</span>
<span class="sd">      is_atomic (bool, optional): Is the binding network atomic or not. Defaults to None.</span>
<span class="sd">      l_mat (numpy array, optional): The conservation law matrix defining the conserved total quantities.</span>
<span class="sd">          If not given, and is_atomic is True, then it will be computed from n_mat. Defaults to None.</span>
<span class="sd">      x_sym (list of symbols, optional): An ordered list of symbols for the chemical species, denoting columns of the n_mat and l_mat. Defaults to None.</span>
<span class="sd">      t_sym (list of symbols, optional): An ordered list of symbols for the total or conserved quantities, denoting rows of the l_mat. Defaults to None.</span>
<span class="sd">      k_sym (list of symbols, optional): An ordered list of symbols for the binding constants in the dissociation direction, denoting rows of the n_mat. Defaults to None.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">is_atomic</span><span class="o">=</span><span class="n">is_atomic</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">n_mat</span><span class="o">=</span><span class="n">n_mat</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">n_mat_sym</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">n_mat</span><span class="p">)</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">dim_r</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_n</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_mat</span><span class="o">.</span><span class="n">shape</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">dim_d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim_n</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim_r</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">l_mat</span><span class="p">):</span> <span class="c1">#no input l_mat</span>
    <span class="n">l_mat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">l_from_n</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_mat</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">l_mat</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span>
  <span class="c1"># if no input symbols for the x,t,k variables then give them default numerically ordered ones.</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">x_sym</span><span class="p">):</span>
    <span class="n">x_sym</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;x:&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_n</span><span class="p">))</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">t_sym</span><span class="p">):</span>
    <span class="n">t_sym</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;t:&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_d</span><span class="p">))</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">k_sym</span><span class="p">):</span>
    <span class="n">k_sym</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;k:&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_r</span><span class="p">))</span>

  <span class="bp">self</span><span class="o">.</span><span class="n">l_mat</span><span class="o">=</span><span class="n">l_mat</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">l_mat_sym</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">l_mat</span><span class="p">)</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">x_sym</span><span class="o">=</span><span class="n">x_sym</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">t_sym</span><span class="o">=</span><span class="n">t_sym</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">k_sym</span><span class="o">=</span><span class="n">k_sym</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">tk_sym</span><span class="o">=</span><span class="n">t_sym</span><span class="o">+</span><span class="n">k_sym</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">opt_var</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_n</span><span class="p">)</span>

  <span class="bp">self</span><span class="o">.</span><span class="n">m_mat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">l_mat</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">n_mat</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">orientation</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m_mat</span><span class="p">))</span>

  <span class="bp">self</span><span class="o">.</span><span class="n">ld_sym_dict</span><span class="o">=</span><span class="p">{}</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">activity_regime_dict</span><span class="o">=</span><span class="p">{}</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">activity_ld_regime_dict</span><span class="o">=</span><span class="p">{}</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">activity_regime_constrained_dict</span><span class="o">=</span><span class="p">{}</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">activity_ld_regime_constrained_dict</span><span class="o">=</span><span class="p">{}</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="bcn.binding_network.binding_network.l_from_n" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">l_from_n</span><span class="p">(</span><span class="n">n_mat</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>If the network is atomic, compute the L matrix from the N matrix.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>n_mat</code>
            </td>
            <td>
                  <code>numpy array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The stoichiometry matrix defining the binding network.
Assumes the columns are ordered so that the atomic species come first.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>numpy array: The conservation law or totals matrix.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/bcn/binding_network.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1121</span>
<span class="normal">1122</span>
<span class="normal">1123</span>
<span class="normal">1124</span>
<span class="normal">1125</span>
<span class="normal">1126</span>
<span class="normal">1127</span>
<span class="normal">1128</span>
<span class="normal">1129</span>
<span class="normal">1130</span>
<span class="normal">1131</span>
<span class="normal">1132</span>
<span class="normal">1133</span>
<span class="normal">1134</span>
<span class="normal">1135</span>
<span class="normal">1136</span>
<span class="normal">1137</span>
<span class="normal">1138</span>
<span class="normal">1139</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">l_from_n</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n_mat</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  If the network is atomic, compute the L matrix from the N matrix.</span>

<span class="sd">  Args:</span>
<span class="sd">      n_mat (numpy array): The stoichiometry matrix defining the binding network.</span>
<span class="sd">          Assumes the columns are ordered so that the atomic species come first.</span>

<span class="sd">  Returns:</span>
<span class="sd">      numpy array: The conservation law or totals matrix.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_atomic</span>
  <span class="n">r</span><span class="o">=</span><span class="n">n_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">d</span><span class="o">=</span><span class="n">n_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">r</span>
  <span class="n">n1_mat</span><span class="o">=</span><span class="n">n_mat</span><span class="p">[:,:</span><span class="n">d</span><span class="p">]</span>
  <span class="n">n2_mat</span><span class="o">=</span><span class="n">n_mat</span><span class="p">[:,</span><span class="o">-</span><span class="n">r</span><span class="p">:]</span>
  <span class="n">l2_mat</span><span class="o">=-</span><span class="p">(</span><span class="n">n1_mat</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">n2_mat</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
  <span class="n">l_mat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">d</span><span class="p">),</span><span class="n">l2_mat</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">l_mat</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="bcn.binding_network.binding_network.logder_activity_num" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">logder_activity_num</span><span class="p">(</span><span class="n">b_vec</span><span class="p">,</span> <span class="n">logx_array</span><span class="p">,</span> <span class="n">ld_mat_array</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Given a logder matrix, compute the logder of b^T x.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>b_vec</code>
            </td>
            <td>
                  <code>numpy vector</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Vector indicating which species are included in the catalytic activity. Shape is (dim_n,).
All entries are non-negative, with at least one nonzero.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>logx_array</code>
            </td>
            <td>
                  <code><span title="ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Array of logx-vector indicating the point at which the logder is evaluated. Shape is (n_points, dim_n).
log is base 10.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>ld_mat_array</code>
            </td>
            <td>
                  <code><span title="ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Array of n x n matrix for dlogx/dlog(t, k) at point x on the manifold. Shape is (n_points, dim_n, dim_n).</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>ndarray</code></td>            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Array of vectors for dlog(b^T x)/dlog(t, k). Shape is (n_points, dim_n).</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/bcn/binding_network.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1265</span>
<span class="normal">1266</span>
<span class="normal">1267</span>
<span class="normal">1268</span>
<span class="normal">1269</span>
<span class="normal">1270</span>
<span class="normal">1271</span>
<span class="normal">1272</span>
<span class="normal">1273</span>
<span class="normal">1274</span>
<span class="normal">1275</span>
<span class="normal">1276</span>
<span class="normal">1277</span>
<span class="normal">1278</span>
<span class="normal">1279</span>
<span class="normal">1280</span>
<span class="normal">1281</span>
<span class="normal">1282</span>
<span class="normal">1283</span>
<span class="normal">1284</span>
<span class="normal">1285</span>
<span class="normal">1286</span>
<span class="normal">1287</span>
<span class="normal">1288</span>
<span class="normal">1289</span>
<span class="normal">1290</span>
<span class="normal">1291</span>
<span class="normal">1292</span>
<span class="normal">1293</span>
<span class="normal">1294</span>
<span class="normal">1295</span>
<span class="normal">1296</span>
<span class="normal">1297</span>
<span class="normal">1298</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">logder_activity_num</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">b_vec</span><span class="p">,</span><span class="n">logx_array</span><span class="p">,</span><span class="n">ld_mat_array</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Given a logder matrix, compute the logder of b^T x.</span>

<span class="sd">  Args:</span>
<span class="sd">      b_vec (numpy vector): Vector indicating which species are included in the catalytic activity. Shape is (dim_n,).</span>
<span class="sd">          All entries are non-negative, with at least one nonzero.</span>
<span class="sd">      logx_array (ndarray): Array of logx-vector indicating the point at which the logder is evaluated. Shape is (n_points, dim_n).</span>
<span class="sd">          log is base 10.</span>
<span class="sd">      ld_mat_array (ndarray): Array of n x n matrix for dlogx/dlog(t, k) at point x on the manifold. Shape is (n_points, dim_n, dim_n).</span>

<span class="sd">  Returns:</span>
<span class="sd">      ndarray: Array of vectors for dlog(b^T x)/dlog(t, k). Shape is (n_points, dim_n).</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">b_vec</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">),</span> <span class="s2">&quot;all entries of b_vec should be non-negative.&quot;</span>
  <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">b_vec</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;there should be at least one nonzero entry in b_vec.&quot;</span>
  <span class="n">x_array</span><span class="o">=</span><span class="mi">10</span><span class="o">**</span><span class="n">logx_array</span> <span class="c1"># shape (n_points,dim_n)</span>
  <span class="n">bx_array</span><span class="o">=</span><span class="n">x_array</span><span class="o">*</span><span class="n">b_vec</span> <span class="c1"># each row element-wise product with b_vec</span>
  <span class="c1"># so bx_array has shape (n_points,dim_n)</span>
  <span class="n">coeff</span><span class="o">=</span><span class="p">(</span><span class="n">bx_array</span><span class="o">.</span><span class="n">T</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bx_array</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">T</span> <span class="c1"># shape (n_points,dim_n)</span>
  <span class="n">npts</span><span class="o">=</span><span class="n">logx_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

  <span class="c1"># One implementation is iterate and sum, this is slow (not really?).</span>
  <span class="n">ld_activity</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">npts</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_n</span><span class="p">))</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npts</span><span class="p">):</span>
    <span class="n">ld_activity</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">coeff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ld_mat_array</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

  <span class="c1"># Another implementation is directly writing out the product</span>
  <span class="c1"># coeff_temp=np.repeat(coeff[:,:,np.newaxis],self.dim_n,axis=2)</span>
  <span class="c1"># ld_activity=(ld_mat_array*coeff_temp).sum(-1)</span>

  <span class="c1"># Yet another way is to use einsum. Will do these if speed is a problem.</span>

  <span class="k">return</span> <span class="n">ld_activity</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="bcn.binding_network.binding_network.logder_num" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">logder_num</span><span class="p">(</span><span class="n">logvar</span><span class="p">,</span> <span class="n">chart</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">a_mat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Compute the numerical log derivative of the binding network at points specified by logvar in the specified chart and dominance a_mat.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>logvar</code>
            </td>
            <td>
                  <code><span title="ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Array of the points to evaluate the log derivatives at, in base-10 log. Shape is (n_points, dim_n).
In chart 'x', for example, this is logx.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>chart</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Specifying the chart that logvar is specified in. Could be 'x', 'xak', or 'tk'.</p>
              </div>
            </td>
            <td>
                  <code>&#39;x&#39;</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>a_mat</code>
            </td>
            <td>
                  <code>numpy array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Matrix defining the variables log derivative is taken in terms of.
Assumes all entries are non-negative, and each row has at least one positive entry.
Optional, defaults to l_mat of the binding network.</p>
              </div>
            </td>
            <td>
                  <code><span title="numpy.array">array</span>([])</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>logder</code></td>            <td>
                  <code><span title="ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Array of n-by-n matrix of log derivative of x to (t, k), where t = a_mat @ x, and n is the number of species.
Shape is (n_points, dim_n, dim_n).</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
<td><code>logx</code></td>            <td>
                  <code><span title="ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Array of logx that the logvar points correspond to. Shape is (n_points, dim_n).
This is returned since all input variables, regardless of chart, are mapped to the logx chart first.
Returned for convenience.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/bcn/binding_network.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1141</span>
<span class="normal">1142</span>
<span class="normal">1143</span>
<span class="normal">1144</span>
<span class="normal">1145</span>
<span class="normal">1146</span>
<span class="normal">1147</span>
<span class="normal">1148</span>
<span class="normal">1149</span>
<span class="normal">1150</span>
<span class="normal">1151</span>
<span class="normal">1152</span>
<span class="normal">1153</span>
<span class="normal">1154</span>
<span class="normal">1155</span>
<span class="normal">1156</span>
<span class="normal">1157</span>
<span class="normal">1158</span>
<span class="normal">1159</span>
<span class="normal">1160</span>
<span class="normal">1161</span>
<span class="normal">1162</span>
<span class="normal">1163</span>
<span class="normal">1164</span>
<span class="normal">1165</span>
<span class="normal">1166</span>
<span class="normal">1167</span>
<span class="normal">1168</span>
<span class="normal">1169</span>
<span class="normal">1170</span>
<span class="normal">1171</span>
<span class="normal">1172</span>
<span class="normal">1173</span>
<span class="normal">1174</span>
<span class="normal">1175</span>
<span class="normal">1176</span>
<span class="normal">1177</span>
<span class="normal">1178</span>
<span class="normal">1179</span>
<span class="normal">1180</span>
<span class="normal">1181</span>
<span class="normal">1182</span>
<span class="normal">1183</span>
<span class="normal">1184</span>
<span class="normal">1185</span>
<span class="normal">1186</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">logder_num</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">logvar</span><span class="p">,</span><span class="n">chart</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="n">a_mat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Compute the numerical log derivative of the binding network at points specified by logvar in the specified chart and dominance a_mat.</span>

<span class="sd">  Args:</span>
<span class="sd">      logvar (ndarray): Array of the points to evaluate the log derivatives at, in base-10 log. Shape is (n_points, dim_n).</span>
<span class="sd">          In chart &#39;x&#39;, for example, this is logx.</span>
<span class="sd">      chart (str): Specifying the chart that logvar is specified in. Could be &#39;x&#39;, &#39;xak&#39;, or &#39;tk&#39;.</span>
<span class="sd">      a_mat (numpy array, optional): Matrix defining the variables log derivative is taken in terms of.</span>
<span class="sd">          Assumes all entries are non-negative, and each row has at least one positive entry.</span>
<span class="sd">          Optional, defaults to l_mat of the binding network.</span>

<span class="sd">  Returns:</span>
<span class="sd">      logder (ndarray): Array of n-by-n matrix of log derivative of x to (t, k), where t = a_mat @ x, and n is the number of species.</span>
<span class="sd">          Shape is (n_points, dim_n, dim_n).</span>
<span class="sd">      logx (ndarray): Array of logx that the logvar points correspond to. Shape is (n_points, dim_n).</span>
<span class="sd">          This is returned since all input variables, regardless of chart, are mapped to the logx chart first.</span>
<span class="sd">          Returned for convenience.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="c1"># first check a_mat makes sense.</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">a_mat</span><span class="p">):</span> <span class="c1"># no a_mat argument is given</span>
    <span class="n">a_mat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">l_mat</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">assert</span> <span class="n">a_mat</span><span class="o">.</span><span class="n">shape</span><span class="o">==</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_d</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_n</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;the shape of L matrix should be </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_d</span><span class="si">}</span><span class="s2"> by </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_n</span><span class="si">}</span><span class="s2">.&quot;</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">a_mat</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">),</span> <span class="s2">&quot;all entries of A matrix should be non-negative.&quot;</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">a_mat</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_n</span><span class="p">))</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">),</span> <span class="s2">&quot;each row of A matrix should have at least one positive entry.&quot;</span>
  <span class="c1"># for different charts, use different functions to evaluate</span>
  <span class="n">npts</span><span class="o">=</span><span class="n">logvar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="k">assert</span> <span class="n">logvar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_n</span><span class="p">,</span> <span class="s1">&#39;shape of logvar should be num_points-by-dim_n&#39;</span>
  <span class="n">logders</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">logvar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_n</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_n</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">chart</span><span class="o">==</span><span class="s1">&#39;x&#39;</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npts</span><span class="p">):</span>
      <span class="n">logders</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logder_x_num</span><span class="p">(</span><span class="n">logvar</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">a_mat</span><span class="p">)</span>
    <span class="n">logx</span><span class="o">=</span><span class="n">logvar</span>
  <span class="k">elif</span> <span class="n">chart</span><span class="o">==</span><span class="s1">&#39;xak&#39;</span><span class="p">:</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_atomic</span><span class="p">,</span> <span class="s1">&#39;the binding network is not atomic, cannot use xak chart&#39;</span>
    <span class="n">logx</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">logvar</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npts</span><span class="p">):</span>
      <span class="n">logders</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">logx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logder_xak_num</span><span class="p">(</span><span class="n">logvar</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">a_mat</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">chart</span><span class="o">==</span><span class="s1">&#39;tk&#39;</span><span class="p">:</span>
    <span class="n">logx</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">logvar</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npts</span><span class="p">):</span>
      <span class="n">logders</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">logx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logder_tk_num</span><span class="p">(</span><span class="n">logvar</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">a_mat</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span> 
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;chart that is not one of &quot;x,xak,tk&quot; is not implemented yet&#39;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">logders</span><span class="p">,</span><span class="n">logx</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="bcn.binding_network.binding_network.logder_sym" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">logder_sym</span><span class="p">(</span><span class="n">a_mat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span> <span class="n">is_saved</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Calculate the symbolic log derivative matrix of dlog(x)/dlog(a_mat @ x, k).</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>a_mat</code>
            </td>
            <td>
                  <code>numpy array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Matrix defining the variables log derivative is taken in terms of.
Assumes all entries are non-negative, and each row has at least one positive entry.
Optional, defaults to l_mat of the binding network.</p>
              </div>
            </td>
            <td>
                  <code><span title="numpy.array">array</span>([])</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>is_saved</code>
            </td>
            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>To save the resulting logdermat as parameter ld_sym of the binding network or not.
Defaults to True.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>sympy.Matrix: Symbolic log derivative matrix for x to (t_sym_temp, k_sym) expressed in terms of x.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<details class="note" open>
  <summary>Note</summary>
  <p>If the provided a_mat yields a noninvertible matrix, then the function will return logdermat as a matrix of zeros (with the appropriate size).</p>
</details>
            <details class="quote">
              <summary>Source code in <code>src/bcn/binding_network.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1899</span>
<span class="normal">1900</span>
<span class="normal">1901</span>
<span class="normal">1902</span>
<span class="normal">1903</span>
<span class="normal">1904</span>
<span class="normal">1905</span>
<span class="normal">1906</span>
<span class="normal">1907</span>
<span class="normal">1908</span>
<span class="normal">1909</span>
<span class="normal">1910</span>
<span class="normal">1911</span>
<span class="normal">1912</span>
<span class="normal">1913</span>
<span class="normal">1914</span>
<span class="normal">1915</span>
<span class="normal">1916</span>
<span class="normal">1917</span>
<span class="normal">1918</span>
<span class="normal">1919</span>
<span class="normal">1920</span>
<span class="normal">1921</span>
<span class="normal">1922</span>
<span class="normal">1923</span>
<span class="normal">1924</span>
<span class="normal">1925</span>
<span class="normal">1926</span>
<span class="normal">1927</span>
<span class="normal">1928</span>
<span class="normal">1929</span>
<span class="normal">1930</span>
<span class="normal">1931</span>
<span class="normal">1932</span>
<span class="normal">1933</span>
<span class="normal">1934</span>
<span class="normal">1935</span>
<span class="normal">1936</span>
<span class="normal">1937</span>
<span class="normal">1938</span>
<span class="normal">1939</span>
<span class="normal">1940</span>
<span class="normal">1941</span>
<span class="normal">1942</span>
<span class="normal">1943</span>
<span class="normal">1944</span>
<span class="normal">1945</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">logder_sym</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">a_mat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span><span class="n">is_saved</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Calculate the symbolic log derivative matrix of dlog(x)/dlog(a_mat @ x, k).</span>

<span class="sd">  Args:</span>
<span class="sd">      a_mat (numpy array, optional): Matrix defining the variables log derivative is taken in terms of.</span>
<span class="sd">          Assumes all entries are non-negative, and each row has at least one positive entry.</span>
<span class="sd">          Optional, defaults to l_mat of the binding network.</span>
<span class="sd">      is_saved (bool, optional): To save the resulting logdermat as parameter ld_sym of the binding network or not.</span>
<span class="sd">          Defaults to True.</span>

<span class="sd">  Returns:</span>
<span class="sd">      sympy.Matrix: Symbolic log derivative matrix for x to (t_sym_temp, k_sym) expressed in terms of x.</span>

<span class="sd">  Note:</span>
<span class="sd">      If the provided a_mat yields a noninvertible matrix, then the function will return logdermat as a matrix of zeros (with the appropriate size).</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">a_mat</span><span class="p">):</span> <span class="c1"># no a_mat argument is given</span>
    <span class="n">a_mat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">l_mat</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">assert</span> <span class="n">a_mat</span><span class="o">.</span><span class="n">shape</span><span class="o">==</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_d</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_n</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;the shape of L matrix should be </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_d</span><span class="si">}</span><span class="s2"> by </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_n</span><span class="si">}</span><span class="s2">.&quot;</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">a_mat</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">),</span> <span class="s2">&quot;all entries of A matrix should be non-negative.&quot;</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">a_mat</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_n</span><span class="p">))</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">),</span> <span class="s2">&quot;each row of A matrix should have at least one positive entry.&quot;</span>

  <span class="n">a_mat_sym</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">a_mat</span><span class="p">)</span>
  <span class="n">n_mat_sym</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_mat_sym</span>

  <span class="c1">#it&#39;s much faster (10x) to use a dummy &quot;total&quot; variables to calculate matrix inverse,</span>
  <span class="c1"># and then substitute the expression for the totals in terms of x, rather than</span>
  <span class="c1"># inverting with the totals explicitly expressed in x variables.</span>

  <span class="n">temp_sym</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;t:&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_d</span><span class="p">))</span>

  <span class="n">Lam_t</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="o">*</span><span class="n">temp_sym</span><span class="p">)</span>
  <span class="n">Lam_x</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">x_sym</span><span class="p">)</span>

  <span class="n">topmat</span> <span class="o">=</span> <span class="n">Lam_t</span><span class="o">**-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">a_mat_sym</span> <span class="o">*</span> <span class="n">Lam_x</span>
  <span class="n">fullmat</span> <span class="o">=</span> <span class="n">topmat</span><span class="o">.</span><span class="n">col_join</span><span class="p">(</span><span class="n">n_mat_sym</span><span class="p">)</span>

  <span class="n">logdermat_t</span> <span class="o">=</span> <span class="n">fullmat</span><span class="o">**-</span><span class="mi">1</span>

  <span class="n">temp_expr</span><span class="o">=</span><span class="n">a_mat_sym</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_sym</span><span class="p">)</span>
  <span class="n">temp2x_subs_list</span><span class="o">=</span><span class="p">[(</span><span class="n">temp_sym</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">temp_expr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_d</span><span class="p">)]</span>
  <span class="n">logdermat</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">logdermat_t</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">temp2x_subs_list</span><span class="p">))</span>

  <span class="k">if</span> <span class="n">is_saved</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">ld_sym_dict</span><span class="p">[</span><span class="n">a_mat</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()]</span><span class="o">=</span><span class="n">logdermat</span>
  <span class="k">return</span> <span class="n">logdermat</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="bcn.binding_network.binding_network.logder_sym_activity" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">logder_sym_activity</span><span class="p">(</span><span class="n">b_vec_sym</span><span class="p">,</span> <span class="n">a_mat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Compute the log derivative of a linear sum of x, i.e. dlog(b_vec_sym * x)/dlog(tp, k), where tp = a_mat * x.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>b_vec_sym</code>
            </td>
            <td>
                  <code>sympy symbolic vector</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A vector of symbolic expressions corresponding to coefficients to be summed. Shape is (n, 1).</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>a_mat</code>
            </td>
            <td>
                  <code>numpy array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The matrix denoting the variables a_mat * x that the log derivative is taken with respect to.
Defaults to self.l_mat.</p>
              </div>
            </td>
            <td>
                  <code><span title="numpy.array">array</span>([])</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>sympy vector: The symbolic log derivative dlog(b_vec_sym * x)/dlog(tp, k), where tp = a_mat * x.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/bcn/binding_network.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">2001</span>
<span class="normal">2002</span>
<span class="normal">2003</span>
<span class="normal">2004</span>
<span class="normal">2005</span>
<span class="normal">2006</span>
<span class="normal">2007</span>
<span class="normal">2008</span>
<span class="normal">2009</span>
<span class="normal">2010</span>
<span class="normal">2011</span>
<span class="normal">2012</span>
<span class="normal">2013</span>
<span class="normal">2014</span>
<span class="normal">2015</span>
<span class="normal">2016</span>
<span class="normal">2017</span>
<span class="normal">2018</span>
<span class="normal">2019</span>
<span class="normal">2020</span>
<span class="normal">2021</span>
<span class="normal">2022</span>
<span class="normal">2023</span>
<span class="normal">2024</span>
<span class="normal">2025</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">logder_sym_activity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">b_vec_sym</span><span class="p">,</span><span class="n">a_mat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Compute the log derivative of a linear sum of x, i.e. dlog(b_vec_sym * x)/dlog(tp, k), where tp = a_mat * x.</span>

<span class="sd">  Args:</span>
<span class="sd">      b_vec_sym (sympy symbolic vector): A vector of symbolic expressions corresponding to coefficients to be summed. Shape is (n, 1).</span>
<span class="sd">      a_mat (numpy array, optional): The matrix denoting the variables a_mat * x that the log derivative is taken with respect to.</span>
<span class="sd">          Defaults to self.l_mat.</span>

<span class="sd">  Returns:</span>
<span class="sd">      sympy vector: The symbolic log derivative dlog(b_vec_sym * x)/dlog(tp, k), where tp = a_mat * x.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">a_mat</span><span class="p">):</span> <span class="c1"># no a_mat argument is given</span>
    <span class="n">a_mat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">l_mat</span>
  <span class="c1"># check if logder is already calculated with respect to this a_mat.</span>
  <span class="k">try</span><span class="p">:</span> <span class="n">ld_sym</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ld_sym_dict</span><span class="p">[</span><span class="n">a_mat</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()]</span>
  <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span> <span class="c1"># not calculated yet</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Symbolic logder for this chart coordinate does not exist, calculating...&#39;</span><span class="p">)</span>
    <span class="n">ld_sym</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logder_sym</span><span class="p">(</span><span class="n">a_mat</span><span class="o">=</span><span class="n">a_mat</span><span class="p">)</span>
  <span class="n">coeff_vec_sym</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">b_vec_sym</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
  <span class="n">bx</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">matrix_multiply_elementwise</span><span class="p">(</span><span class="n">b_vec_sym</span><span class="p">,</span><span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_sym</span><span class="p">))</span> <span class="c1">#b multiply x element-wise</span>
  <span class="n">bx_sum</span> <span class="o">=</span> <span class="n">bx</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="o">*</span><span class="n">bx</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
  <span class="n">coeff_vec_sym</span><span class="o">=</span><span class="n">bx</span><span class="o">*</span><span class="n">bx_sum</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># convex coefficients for the log derivative sum</span>
  <span class="n">ld_sym_sum</span><span class="o">=</span><span class="p">(</span><span class="n">ld_sym</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">coeff_vec_sym</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="c1"># for logder matrix ld_sym, rows are species, columns are variables.</span>
  <span class="k">return</span> <span class="n">ld_sym_sum</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="bcn.binding_network.binding_network.logder_tk2x_num" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">logder_tk2x_num</span><span class="p">(</span><span class="n">logvar</span><span class="p">,</span> <span class="n">chart</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">a_mat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Compute the numerical dlog(t, k)/dlog(x) log derivative of the binding network at points specified by logvar in the specified chart and dominance a_mat.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>logvar</code>
            </td>
            <td>
                  <code><span title="ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Array of the points to evaluate the log derivatives at, in base-10 log. Shape is (n_points, dim_n).
In chart 'x', for example, this is logx.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>chart</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Specifying the chart that logvar is specified in. Could be 'x', 'xak', or 'tk'.</p>
              </div>
            </td>
            <td>
                  <code>&#39;x&#39;</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>a_mat</code>
            </td>
            <td>
                  <code>numpy array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Matrix defining the variables log derivative is taken in terms of.
Assumes all entries are non-negative, and each row has at least one positive entry.
Optional, defaults to l_mat of the binding network.</p>
              </div>
            </td>
            <td>
                  <code><span title="numpy.array">array</span>([])</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>logder</code></td>            <td>
                  <code><span title="ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Array of n-by-n matrix of log derivative of (t, k) to x, where t = a_mat @ x, and n is the number of species.
Shape is (n_points, dim_n, dim_n).</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
<td><code>logx</code></td>            <td>
                  <code><span title="ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Array of logx that the logvar points correspond to. Shape is (n_points, dim_n).
This is returned since all input variables, regardless of chart, are mapped to the logx chart first.
Returned for convenience.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/bcn/binding_network.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1379</span>
<span class="normal">1380</span>
<span class="normal">1381</span>
<span class="normal">1382</span>
<span class="normal">1383</span>
<span class="normal">1384</span>
<span class="normal">1385</span>
<span class="normal">1386</span>
<span class="normal">1387</span>
<span class="normal">1388</span>
<span class="normal">1389</span>
<span class="normal">1390</span>
<span class="normal">1391</span>
<span class="normal">1392</span>
<span class="normal">1393</span>
<span class="normal">1394</span>
<span class="normal">1395</span>
<span class="normal">1396</span>
<span class="normal">1397</span>
<span class="normal">1398</span>
<span class="normal">1399</span>
<span class="normal">1400</span>
<span class="normal">1401</span>
<span class="normal">1402</span>
<span class="normal">1403</span>
<span class="normal">1404</span>
<span class="normal">1405</span>
<span class="normal">1406</span>
<span class="normal">1407</span>
<span class="normal">1408</span>
<span class="normal">1409</span>
<span class="normal">1410</span>
<span class="normal">1411</span>
<span class="normal">1412</span>
<span class="normal">1413</span>
<span class="normal">1414</span>
<span class="normal">1415</span>
<span class="normal">1416</span>
<span class="normal">1417</span>
<span class="normal">1418</span>
<span class="normal">1419</span>
<span class="normal">1420</span>
<span class="normal">1421</span>
<span class="normal">1422</span>
<span class="normal">1423</span>
<span class="normal">1424</span>
<span class="normal">1425</span>
<span class="normal">1426</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">logder_tk2x_num</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">logvar</span><span class="p">,</span><span class="n">chart</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="n">a_mat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Compute the numerical dlog(t, k)/dlog(x) log derivative of the binding network at points specified by logvar in the specified chart and dominance a_mat.</span>

<span class="sd">  Args:</span>
<span class="sd">      logvar (ndarray): Array of the points to evaluate the log derivatives at, in base-10 log. Shape is (n_points, dim_n).</span>
<span class="sd">          In chart &#39;x&#39;, for example, this is logx.</span>
<span class="sd">      chart (str): Specifying the chart that logvar is specified in. Could be &#39;x&#39;, &#39;xak&#39;, or &#39;tk&#39;.</span>
<span class="sd">      a_mat (numpy array, optional): Matrix defining the variables log derivative is taken in terms of.</span>
<span class="sd">          Assumes all entries are non-negative, and each row has at least one positive entry.</span>
<span class="sd">          Optional, defaults to l_mat of the binding network.</span>

<span class="sd">  Returns:</span>
<span class="sd">      logder (ndarray): Array of n-by-n matrix of log derivative of (t, k) to x, where t = a_mat @ x, and n is the number of species.</span>
<span class="sd">          Shape is (n_points, dim_n, dim_n).</span>
<span class="sd">      logx (ndarray): Array of logx that the logvar points correspond to. Shape is (n_points, dim_n).</span>
<span class="sd">          This is returned since all input variables, regardless of chart, are mapped to the logx chart first.</span>
<span class="sd">          Returned for convenience.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="c1"># first check a_mat makes sense.</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">a_mat</span><span class="p">):</span> <span class="c1"># no a_mat argument is given</span>
    <span class="n">a_mat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">l_mat</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">assert</span> <span class="n">a_mat</span><span class="o">.</span><span class="n">shape</span><span class="o">==</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_d</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_n</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;the shape of L matrix should be </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_d</span><span class="si">}</span><span class="s2"> by </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_n</span><span class="si">}</span><span class="s2">.&quot;</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">a_mat</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">),</span> <span class="s2">&quot;all entries of A matrix should be non-negative.&quot;</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">a_mat</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_n</span><span class="p">))</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">),</span> <span class="s2">&quot;each row of A matrix should have at least one positive entry.&quot;</span>
  <span class="c1"># for different charts, use different functions to evaluate</span>
  <span class="n">npts</span><span class="o">=</span><span class="n">logvar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="k">assert</span> <span class="n">logvar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_n</span><span class="p">,</span> <span class="s1">&#39;shape of logvar should be num_points-by-dim_n&#39;</span>
  <span class="n">logders</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">logvar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_n</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_n</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">chart</span><span class="o">==</span><span class="s1">&#39;x&#39;</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npts</span><span class="p">):</span>
      <span class="n">logders</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logder_tk2x_x_num</span><span class="p">(</span><span class="n">logvar</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">a_mat</span><span class="p">)</span>
    <span class="n">logx</span><span class="o">=</span><span class="n">logvar</span>
  <span class="k">elif</span> <span class="n">chart</span><span class="o">==</span><span class="s1">&#39;xak&#39;</span><span class="p">:</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_atomic</span><span class="p">,</span> <span class="s1">&#39;the binding network is not atomic, cannot use xak chart&#39;</span>
    <span class="n">logx</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">logvar</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npts</span><span class="p">):</span>
      <span class="n">logx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xak2x_num</span><span class="p">(</span><span class="n">logvar</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
      <span class="n">logders</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logder_tk2x_x_num</span><span class="p">(</span><span class="n">logx</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">a_mat</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">chart</span><span class="o">==</span><span class="s1">&#39;tk&#39;</span><span class="p">:</span>
    <span class="n">logx</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">logvar</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npts</span><span class="p">):</span>
      <span class="n">logx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tk2x_num</span><span class="p">(</span><span class="n">logvar</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">a_mat</span><span class="p">)</span>
      <span class="n">logders</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logder_tk2x_x_num</span><span class="p">(</span><span class="n">logvar</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">a_mat</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span> 
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;chart that is not one of &quot;x,xak,tk&quot; is not implemented yet&#39;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">logders</span><span class="p">,</span><span class="n">logx</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="bcn.binding_network.binding_network.logder_tk2x_x_num" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">logder_tk2x_x_num</span><span class="p">(</span><span class="n">logx</span><span class="p">,</span> <span class="n">a_mat</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Compute the numerical dlog(t, k)/dlog(x) log derivative of the binding network at one point in chart x.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>logx</code>
            </td>
            <td>
                  <code>numpy vector</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Vector of concentrations for all the species in log, base-10.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>a_mat</code>
            </td>
            <td>
                  <code>numpy array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Matrix defining the variables log derivative is taken in terms of.
Assumes all entries are non-negative, and each row has at least one positive entry.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>ndarray</code></td>            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Array of n-by-n matrix of log derivative of (t, k) to x, where t = a_mat @ x, and n is the number of species.
Shape is (n_points, dim_n, dim_n).</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/bcn/binding_network.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1428</span>
<span class="normal">1429</span>
<span class="normal">1430</span>
<span class="normal">1431</span>
<span class="normal">1432</span>
<span class="normal">1433</span>
<span class="normal">1434</span>
<span class="normal">1435</span>
<span class="normal">1436</span>
<span class="normal">1437</span>
<span class="normal">1438</span>
<span class="normal">1439</span>
<span class="normal">1440</span>
<span class="normal">1441</span>
<span class="normal">1442</span>
<span class="normal">1443</span>
<span class="normal">1444</span>
<span class="normal">1445</span>
<span class="normal">1446</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">logder_tk2x_x_num</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">logx</span><span class="p">,</span><span class="n">a_mat</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Compute the numerical dlog(t, k)/dlog(x) log derivative of the binding network at one point in chart x.</span>

<span class="sd">  Args:</span>
<span class="sd">      logx (numpy vector): Vector of concentrations for all the species in log, base-10.</span>
<span class="sd">      a_mat (numpy array): Matrix defining the variables log derivative is taken in terms of.</span>
<span class="sd">          Assumes all entries are non-negative, and each row has at least one positive entry.</span>

<span class="sd">  Returns:</span>
<span class="sd">      ndarray: Array of n-by-n matrix of log derivative of (t, k) to x, where t = a_mat @ x, and n is the number of species.</span>
<span class="sd">          Shape is (n_points, dim_n, dim_n).</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">x</span><span class="o">=</span><span class="mi">10</span><span class="o">**</span><span class="n">logx</span>
  <span class="n">t_inv</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">a_mat</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
  <span class="n">temp</span><span class="o">=</span><span class="n">a_mat</span><span class="o">*</span><span class="n">x</span>
  <span class="n">upper</span><span class="o">=</span><span class="p">(</span><span class="n">temp</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">t_inv</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
  <span class="n">logder</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">upper</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">n_mat</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">logder</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="bcn.binding_network.binding_network.logder_tk_num" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">logder_tk_num</span><span class="p">(</span><span class="n">logtk</span><span class="p">,</span> <span class="n">a_mat</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Compute the numerical log derivative of dlog(x)/dlog(a_mat @ x, k) at a point specified by log(t, k), where t = a_mat @ x is the concentration of atomic species, and k is the binding constants. log is base 10.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>logtk</code>
            </td>
            <td>
                  <code>numpy vector</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Vector numerical value for total concentration (first dim_d entries) and binding reaction constants (last dim_r entries). Shape is (dim_n,).
log is base 10.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>a_mat</code>
            </td>
            <td>
                  <code>numpy array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Matrix defining the variables log derivative is taken in terms of.
Assumes all entries are non-negative, and each row has at least one positive entry.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>logder</code></td>            <td>
                  <code><span title="ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Array of n-by-n matrix of log derivative of x to (t, k), where t = a_mat @ x, and n is the number of species.
Shape is (n_points, dim_n, dim_n).</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
<td><code>logx</code></td>            <td>
                  <code><span title="ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Array of logx that the logvar points correspond to. Shape is (n_points, dim_n).
This is returned since all input variables, regardless of chart, are mapped to the logx chart first.
Returned for convenience.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/bcn/binding_network.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1245</span>
<span class="normal">1246</span>
<span class="normal">1247</span>
<span class="normal">1248</span>
<span class="normal">1249</span>
<span class="normal">1250</span>
<span class="normal">1251</span>
<span class="normal">1252</span>
<span class="normal">1253</span>
<span class="normal">1254</span>
<span class="normal">1255</span>
<span class="normal">1256</span>
<span class="normal">1257</span>
<span class="normal">1258</span>
<span class="normal">1259</span>
<span class="normal">1260</span>
<span class="normal">1261</span>
<span class="normal">1262</span>
<span class="normal">1263</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">logder_tk_num</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">logtk</span><span class="p">,</span><span class="n">a_mat</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Compute the numerical log derivative of dlog(x)/dlog(a_mat @ x, k) at a point specified by log(t, k), where t = a_mat @ x is the concentration of atomic species, and k is the binding constants. log is base 10.</span>

<span class="sd">  Args:</span>
<span class="sd">      logtk (numpy vector): Vector numerical value for total concentration (first dim_d entries) and binding reaction constants (last dim_r entries). Shape is (dim_n,).</span>
<span class="sd">          log is base 10.</span>
<span class="sd">      a_mat (numpy array): Matrix defining the variables log derivative is taken in terms of.</span>
<span class="sd">          Assumes all entries are non-negative, and each row has at least one positive entry.</span>

<span class="sd">  Returns:</span>
<span class="sd">      logder (ndarray): Array of n-by-n matrix of log derivative of x to (t, k), where t = a_mat @ x, and n is the number of species.</span>
<span class="sd">          Shape is (n_points, dim_n, dim_n).</span>
<span class="sd">      logx (ndarray): Array of logx that the logvar points correspond to. Shape is (n_points, dim_n).</span>
<span class="sd">          This is returned since all input variables, regardless of chart, are mapped to the logx chart first.</span>
<span class="sd">          Returned for convenience.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">logx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tk2x_num</span><span class="p">(</span><span class="n">logtk</span><span class="p">,</span><span class="n">a_mat</span><span class="p">)</span>
  <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">logder_x_num</span><span class="p">(</span><span class="n">logx</span><span class="p">,</span><span class="n">a_mat</span><span class="p">),</span><span class="n">logx</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="bcn.binding_network.binding_network.logder_x_num" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">logder_x_num</span><span class="p">(</span><span class="n">logx</span><span class="p">,</span> <span class="n">a_mat</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Compute the numerical log derivative of the binding network at one point in chart x.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>logx</code>
            </td>
            <td>
                  <code>numpy vector</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Vector of concentrations for all the species in log, base-10.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>a_mat</code>
            </td>
            <td>
                  <code>numpy array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Matrix defining the variables log derivative is taken in terms of.
Assumes all entries are non-negative, and each row has at least one positive entry.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>ndarray</code></td>            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Array of n-by-n matrix of log derivative of x to (t, k), where t = a_mat @ x, and n is the number of species.
Shape is (n_points, dim_n, dim_n).</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/bcn/binding_network.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1188</span>
<span class="normal">1189</span>
<span class="normal">1190</span>
<span class="normal">1191</span>
<span class="normal">1192</span>
<span class="normal">1193</span>
<span class="normal">1194</span>
<span class="normal">1195</span>
<span class="normal">1196</span>
<span class="normal">1197</span>
<span class="normal">1198</span>
<span class="normal">1199</span>
<span class="normal">1200</span>
<span class="normal">1201</span>
<span class="normal">1202</span>
<span class="normal">1203</span>
<span class="normal">1204</span>
<span class="normal">1205</span>
<span class="normal">1206</span>
<span class="normal">1207</span>
<span class="normal">1208</span>
<span class="normal">1209</span>
<span class="normal">1210</span>
<span class="normal">1211</span>
<span class="normal">1212</span>
<span class="normal">1213</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">logder_x_num</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">logx</span><span class="p">,</span><span class="n">a_mat</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Compute the numerical log derivative of the binding network at one point in chart x.</span>

<span class="sd">  Args:</span>
<span class="sd">      logx (numpy vector): Vector of concentrations for all the species in log, base-10.</span>
<span class="sd">      a_mat (numpy array): Matrix defining the variables log derivative is taken in terms of.</span>
<span class="sd">          Assumes all entries are non-negative, and each row has at least one positive entry.</span>

<span class="sd">  Returns:</span>
<span class="sd">      ndarray: Array of n-by-n matrix of log derivative of x to (t, k), where t = a_mat @ x, and n is the number of species.</span>
<span class="sd">          Shape is (n_points, dim_n, dim_n).</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">x</span><span class="o">=</span><span class="mi">10</span><span class="o">**</span><span class="n">logx</span>
  <span class="n">t_inv</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">a_mat</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
  <span class="n">temp</span><span class="o">=</span><span class="n">a_mat</span><span class="o">*</span><span class="n">x</span>
  <span class="n">upper</span><span class="o">=</span><span class="p">(</span><span class="n">temp</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">t_inv</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
  <span class="n">logder_inv</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">upper</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">n_mat</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">logder_inv</span><span class="p">)</span>
  <span class="k">except</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">t_inv</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">logder_inv</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">logder_inv</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="bcn.binding_network.binding_network.logder_xak_num" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">logder_xak_num</span><span class="p">(</span><span class="n">logxak</span><span class="p">,</span> <span class="n">a_mat</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Compute the numerical log derivative of dlog(x)/dlog(a_mat * x, k) at a point specified by log(xa, k), where xa is the concentration of atomic species, and k is the binding constants. log is base 10.
    Assumes the network is atomic, and n_mat, a_mat have atomic species coming first.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>logxak</code>
            </td>
            <td>
                  <code>numpy vector</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Vector numerical value for atomic species concentration (first dim_d entries) and binding reaction constants (last dim_r entries). Shape is (dim_n,).
log is base 10.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>a_mat</code>
            </td>
            <td>
                  <code>numpy array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Matrix defining the variables log derivative is taken in terms of.
Assumes all entries are non-negative, and each row has at least one positive entry.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>logder</code></td>            <td>
                  <code><span title="ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Array of n-by-n matrix of log derivative of x to (t, k), where t = a_mat @ x, and n is the number of species.
Shape is (n_points, dim_n, dim_n).</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
<td><code>logx</code></td>            <td>
                  <code><span title="ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Array of logx that the logvar points correspond to. Shape is (n_points, dim_n).
This is returned since all input variables, regardless of chart, are mapped to the logx chart first.
Returned for convenience.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/bcn/binding_network.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1215</span>
<span class="normal">1216</span>
<span class="normal">1217</span>
<span class="normal">1218</span>
<span class="normal">1219</span>
<span class="normal">1220</span>
<span class="normal">1221</span>
<span class="normal">1222</span>
<span class="normal">1223</span>
<span class="normal">1224</span>
<span class="normal">1225</span>
<span class="normal">1226</span>
<span class="normal">1227</span>
<span class="normal">1228</span>
<span class="normal">1229</span>
<span class="normal">1230</span>
<span class="normal">1231</span>
<span class="normal">1232</span>
<span class="normal">1233</span>
<span class="normal">1234</span>
<span class="normal">1235</span>
<span class="normal">1236</span>
<span class="normal">1237</span>
<span class="normal">1238</span>
<span class="normal">1239</span>
<span class="normal">1240</span>
<span class="normal">1241</span>
<span class="normal">1242</span>
<span class="normal">1243</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">logder_xak_num</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">logxak</span><span class="p">,</span><span class="n">a_mat</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Compute the numerical log derivative of dlog(x)/dlog(a_mat * x, k) at a point specified by log(xa, k), where xa is the concentration of atomic species, and k is the binding constants. log is base 10.</span>
<span class="sd">      Assumes the network is atomic, and n_mat, a_mat have atomic species coming first.</span>

<span class="sd">  Args:</span>
<span class="sd">      logxak (numpy vector): Vector numerical value for atomic species concentration (first dim_d entries) and binding reaction constants (last dim_r entries). Shape is (dim_n,).</span>
<span class="sd">          log is base 10.</span>
<span class="sd">      a_mat (numpy array): Matrix defining the variables log derivative is taken in terms of.</span>
<span class="sd">          Assumes all entries are non-negative, and each row has at least one positive entry.</span>

<span class="sd">  Returns:</span>
<span class="sd">      logder (ndarray): Array of n-by-n matrix of log derivative of x to (t, k), where t = a_mat @ x, and n is the number of species.</span>
<span class="sd">          Shape is (n_points, dim_n, dim_n).</span>
<span class="sd">      logx (ndarray): Array of logx that the logvar points correspond to. Shape is (n_points, dim_n).</span>
<span class="sd">          This is returned since all input variables, regardless of chart, are mapped to the logx chart first.</span>
<span class="sd">          Returned for convenience.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="c1">## commented out are old code that directly calculate logx, now we use stored map.</span>
  <span class="c1"># d=self.dim_d</span>
  <span class="c1"># logxa=logxak[:d]</span>
  <span class="c1"># logk=logxak[d:]</span>
  <span class="c1"># temp1=(a_mat.T).dot(logxa)</span>
  <span class="c1"># n2_mat=self.n_mat[:,d:]</span>
  <span class="c1"># temp2=np.linalg.inv(n2_mat).dot(logk)</span>
  <span class="c1"># logx=temp1 + np.pad(temp2,(d,0),mode=&#39;constant&#39;,constant_values=(0,0))</span>

  <span class="n">logx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xak2x_num</span><span class="p">(</span><span class="n">logxak</span><span class="p">)</span>
  <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">logder_x_num</span><span class="p">(</span><span class="n">logx</span><span class="p">,</span><span class="n">a_mat</span><span class="p">),</span><span class="n">logx</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="bcn.binding_network.binding_network.sampling_over_activity_regime_hull" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">sampling_over_activity_regime_hull</span><span class="p">(</span><span class="n">nsample</span><span class="p">,</span> <span class="n">b_tuple</span><span class="p">,</span> <span class="n">regime_key_list</span><span class="o">=</span><span class="p">[],</span> <span class="n">is_finite_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">is_feasible_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">chart</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">logmin</span><span class="o">=-</span><span class="mi">6</span><span class="p">,</span> <span class="n">logmax</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">c_mat_extra</span><span class="o">=</span><span class="p">[],</span> <span class="n">c0_vec_extra</span><span class="o">=</span><span class="p">[])</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Randomly sample points in the log space of chart variables for each dom_regime for a given activity, but instead of log-uniform, we first assign points to each vertex in an even fashion, then sample uniformly within each vertex.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>nsample</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The number of points to be sampled in the space of chart variables.
This is divided evenly to all the vertices of this binding network.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>b_tuple</code>
            </td>
            <td>
                  <code>tuple of length dim_n</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The b_tuple indicating the activity whose dom_regimes we are interested in sampling.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>is_finite_only</code>
            </td>
            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If True, only finite dom_regimes are sampled.
If False, both finite and infinite dom_regimes are sampled. Defaults to False.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>regime_key_list</code>
            </td>
            <td>
                  <code>list of dominance regime&#39;s keys</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The list of keys for dom_regimes indexing the dom_regimes to be sampled.
e.g. [((0,1,2),7), ((0,1,3),7)]. If empty, sample all dom_regimes. Defaults to empty list [].</p>
              </div>
            </td>
            <td>
                  <code>[]</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>is_feasible_only</code>
            </td>
            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If True, only feasible dom_regimes are sampled.
If False, all dom_regimes in regime_key_list (or all in this activity) are sampled.
Each dom_regime's is_feasible tag comes from results of the most recent feasibility test.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>chart</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A string indicating the chart that the opt_constraints are specified in.
Choices are 'x', 'xak', and 'tk'. Defaults to 'x'.</p>
              </div>
            </td>
            <td>
                  <code>&#39;x&#39;</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>margin</code>
            </td>
            <td>
                  <code><span title="float">float</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The vertex's feasibility conditions are inequalities,
of the form c_mat * logx + c0_vec &gt; margin (e.g. in 'x' chart),
where margin is the positive threshold used here. Defaults to 0.
This can be adjusted to be stronger/weaker requirements on dominance.</p>
              </div>
            </td>
            <td>
                  <code>0</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>logmin</code>
            </td>
            <td>
                  <code>float or ndarray vector</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>logmin, logmax could be scalars, then it's the same value applied to every variable.
They could also be vectors of length dim_n.</p>
              </div>
            </td>
            <td>
                  <code>-6</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>logmax</code>
            </td>
            <td>
                  <code>float or ndarray vector</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>logmin, logmax could be scalars, then it's the same value applied to every variable.
They could also be vectors of length dim_n.</p>
              </div>
            </td>
            <td>
                  <code>6</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>dict</code></td>            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A dictionary of ndarray with shape (nsample, dim_n).
Key is the perm of each vertex. Value is the sample for that vertex.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/bcn/binding_network.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1712</span>
<span class="normal">1713</span>
<span class="normal">1714</span>
<span class="normal">1715</span>
<span class="normal">1716</span>
<span class="normal">1717</span>
<span class="normal">1718</span>
<span class="normal">1719</span>
<span class="normal">1720</span>
<span class="normal">1721</span>
<span class="normal">1722</span>
<span class="normal">1723</span>
<span class="normal">1724</span>
<span class="normal">1725</span>
<span class="normal">1726</span>
<span class="normal">1727</span>
<span class="normal">1728</span>
<span class="normal">1729</span>
<span class="normal">1730</span>
<span class="normal">1731</span>
<span class="normal">1732</span>
<span class="normal">1733</span>
<span class="normal">1734</span>
<span class="normal">1735</span>
<span class="normal">1736</span>
<span class="normal">1737</span>
<span class="normal">1738</span>
<span class="normal">1739</span>
<span class="normal">1740</span>
<span class="normal">1741</span>
<span class="normal">1742</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">sampling_over_activity_regime_hull</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">nsample</span><span class="p">,</span><span class="n">b_tuple</span><span class="p">,</span><span class="n">regime_key_list</span><span class="o">=</span><span class="p">[],</span><span class="n">is_finite_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">is_feasible_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">chart</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="n">logmin</span><span class="o">=-</span><span class="mi">6</span><span class="p">,</span><span class="n">logmax</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span><span class="n">margin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">c_mat_extra</span><span class="o">=</span><span class="p">[],</span><span class="n">c0_vec_extra</span><span class="o">=</span><span class="p">[]):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Randomly sample points in the log space of chart variables for each dom_regime for a given activity, but instead of log-uniform, we first assign points to each vertex in an even fashion, then sample uniformly within each vertex.</span>

<span class="sd">  Args:</span>
<span class="sd">      nsample (int): The number of points to be sampled in the space of chart variables.</span>
<span class="sd">          This is divided evenly to all the vertices of this binding network.</span>
<span class="sd">      b_tuple (tuple of length dim_n): The b_tuple indicating the activity whose dom_regimes we are interested in sampling.</span>
<span class="sd">      is_finite_only (bool, optional): If True, only finite dom_regimes are sampled.</span>
<span class="sd">          If False, both finite and infinite dom_regimes are sampled. Defaults to False.</span>
<span class="sd">      regime_key_list (list of dominance regime&#39;s keys, optional): The list of keys for dom_regimes indexing the dom_regimes to be sampled.</span>
<span class="sd">          e.g. [((0,1,2),7), ((0,1,3),7)]. If empty, sample all dom_regimes. Defaults to empty list [].</span>
<span class="sd">      is_feasible_only (bool, optional): If True, only feasible dom_regimes are sampled.</span>
<span class="sd">          If False, all dom_regimes in regime_key_list (or all in this activity) are sampled.</span>
<span class="sd">          Each dom_regime&#39;s is_feasible tag comes from results of the most recent feasibility test.</span>
<span class="sd">      chart (str, optional): A string indicating the chart that the opt_constraints are specified in.</span>
<span class="sd">          Choices are &#39;x&#39;, &#39;xak&#39;, and &#39;tk&#39;. Defaults to &#39;x&#39;.</span>
<span class="sd">      margin (float, optional): The vertex&#39;s feasibility conditions are inequalities,</span>
<span class="sd">          of the form c_mat * logx + c0_vec &gt; margin (e.g. in &#39;x&#39; chart),</span>
<span class="sd">          where margin is the positive threshold used here. Defaults to 0.</span>
<span class="sd">          This can be adjusted to be stronger/weaker requirements on dominance.</span>
<span class="sd">      logmin (float or ndarray vector): logmin, logmax could be scalars, then it&#39;s the same value applied to every variable.</span>
<span class="sd">          They could also be vectors of length dim_n.</span>
<span class="sd">      logmax (float or ndarray vector): logmin, logmax could be scalars, then it&#39;s the same value applied to every variable.</span>
<span class="sd">          They could also be vectors of length dim_n.</span>

<span class="sd">  Returns:</span>
<span class="sd">      dict: A dictionary of ndarray with shape (nsample, dim_n).</span>
<span class="sd">          Key is the perm of each vertex. Value is the sample for that vertex.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">pass</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="bcn.binding_network.binding_network.sampling_over_vertex_hull" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">sampling_over_vertex_hull</span><span class="p">(</span><span class="n">nsample</span><span class="p">,</span> <span class="n">vertex_perm_list</span><span class="o">=</span><span class="p">[],</span> <span class="n">is_finite_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">chart</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">logmin</span><span class="o">=-</span><span class="mi">6</span><span class="p">,</span> <span class="n">logmax</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">c_mat_extra</span><span class="o">=</span><span class="p">[],</span> <span class="n">c0_vec_extra</span><span class="o">=</span><span class="p">[])</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Randomly sample points in the log space of chart variables, but instead of log-uniform, we first assign points to each vertex in an even fashion, then sample uniformly within each vertex.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>nsample</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The number of points to be sampled in the space of chart variables.
This is divided evenly to all the vertices of this binding network.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>is_finite_only</code>
            </td>
            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Useful only when vertex_perm_list=[], so that all vertices are sampled.
If True, only finite vertices are sampled. This also allows chart 'tk' to work.
If False, both finite and infinite vertices are sampled. Defaults to False.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>vertex_perm_list</code>
            </td>
            <td>
                  <code>list of vertex&#39;s perm tuples</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The list of perms indexing the vertices to be sampled.
e.g. [(0,1,2), (0,1,3)]. Defaults to empty list []. If empty, sample all vertices.</p>
              </div>
            </td>
            <td>
                  <code>[]</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>chart</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A string indicating the chart that the opt_constraints are specified in.
Choices are 'x', 'xak', and 'tk'. Defaults to 'x'.</p>
              </div>
            </td>
            <td>
                  <code>&#39;x&#39;</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>margin</code>
            </td>
            <td>
                  <code><span title="float">float</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The vertex's feasibility conditions are inequalities,
of the form c_mat * logx + c0_vec &gt; margin (e.g. in 'x' chart),
where margin is the positive threshold used here. Defaults to 0.
This can be adjusted to be stronger/weaker requirements on dominance.</p>
              </div>
            </td>
            <td>
                  <code>0</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>logmin</code>
            </td>
            <td>
                  <code>float or ndarray vector</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>logmin, logmax could be scalars, then it's the same value applied to every variable.
They could also be vectors of length dim_n.</p>
              </div>
            </td>
            <td>
                  <code>-6</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>logmax</code>
            </td>
            <td>
                  <code>float or ndarray vector</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>logmin, logmax could be scalars, then it's the same value applied to every variable.
They could also be vectors of length dim_n.</p>
              </div>
            </td>
            <td>
                  <code>6</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>dict</code></td>            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A dictionary of ndarray with shape (nsample, dim_n).
Key is the perm of each vertex. Value is the sample for that vertex.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/bcn/binding_network.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1663</span>
<span class="normal">1664</span>
<span class="normal">1665</span>
<span class="normal">1666</span>
<span class="normal">1667</span>
<span class="normal">1668</span>
<span class="normal">1669</span>
<span class="normal">1670</span>
<span class="normal">1671</span>
<span class="normal">1672</span>
<span class="normal">1673</span>
<span class="normal">1674</span>
<span class="normal">1675</span>
<span class="normal">1676</span>
<span class="normal">1677</span>
<span class="normal">1678</span>
<span class="normal">1679</span>
<span class="normal">1680</span>
<span class="normal">1681</span>
<span class="normal">1682</span>
<span class="normal">1683</span>
<span class="normal">1684</span>
<span class="normal">1685</span>
<span class="normal">1686</span>
<span class="normal">1687</span>
<span class="normal">1688</span>
<span class="normal">1689</span>
<span class="normal">1690</span>
<span class="normal">1691</span>
<span class="normal">1692</span>
<span class="normal">1693</span>
<span class="normal">1694</span>
<span class="normal">1695</span>
<span class="normal">1696</span>
<span class="normal">1697</span>
<span class="normal">1698</span>
<span class="normal">1699</span>
<span class="normal">1700</span>
<span class="normal">1701</span>
<span class="normal">1702</span>
<span class="normal">1703</span>
<span class="normal">1704</span>
<span class="normal">1705</span>
<span class="normal">1706</span>
<span class="normal">1707</span>
<span class="normal">1708</span>
<span class="normal">1709</span>
<span class="normal">1710</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">sampling_over_vertex_hull</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">nsample</span><span class="p">,</span><span class="n">vertex_perm_list</span><span class="o">=</span><span class="p">[],</span><span class="n">is_finite_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">chart</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="n">logmin</span><span class="o">=-</span><span class="mi">6</span><span class="p">,</span><span class="n">logmax</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span><span class="n">margin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">c_mat_extra</span><span class="o">=</span><span class="p">[],</span><span class="n">c0_vec_extra</span><span class="o">=</span><span class="p">[]):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Randomly sample points in the log space of chart variables, but instead of log-uniform, we first assign points to each vertex in an even fashion, then sample uniformly within each vertex.</span>

<span class="sd">  Args:</span>
<span class="sd">      nsample (int): The number of points to be sampled in the space of chart variables.</span>
<span class="sd">          This is divided evenly to all the vertices of this binding network.</span>
<span class="sd">      is_finite_only (bool, optional): Useful only when vertex_perm_list=[], so that all vertices are sampled.</span>
<span class="sd">          If True, only finite vertices are sampled. This also allows chart &#39;tk&#39; to work.</span>
<span class="sd">          If False, both finite and infinite vertices are sampled. Defaults to False.</span>
<span class="sd">      vertex_perm_list (list of vertex&#39;s perm tuples, optional): The list of perms indexing the vertices to be sampled.</span>
<span class="sd">          e.g. [(0,1,2), (0,1,3)]. Defaults to empty list []. If empty, sample all vertices.</span>
<span class="sd">      chart (str, optional): A string indicating the chart that the opt_constraints are specified in.</span>
<span class="sd">          Choices are &#39;x&#39;, &#39;xak&#39;, and &#39;tk&#39;. Defaults to &#39;x&#39;.</span>
<span class="sd">      margin (float, optional): The vertex&#39;s feasibility conditions are inequalities,</span>
<span class="sd">          of the form c_mat * logx + c0_vec &gt; margin (e.g. in &#39;x&#39; chart),</span>
<span class="sd">          where margin is the positive threshold used here. Defaults to 0.</span>
<span class="sd">          This can be adjusted to be stronger/weaker requirements on dominance.</span>
<span class="sd">      logmin (float or ndarray vector): logmin, logmax could be scalars, then it&#39;s the same value applied to every variable.</span>
<span class="sd">          They could also be vectors of length dim_n.</span>
<span class="sd">      logmax (float or ndarray vector): logmin, logmax could be scalars, then it&#39;s the same value applied to every variable.</span>
<span class="sd">          They could also be vectors of length dim_n.</span>

<span class="sd">  Returns:</span>
<span class="sd">      dict: A dictionary of ndarray with shape (nsample, dim_n).</span>
<span class="sd">          Key is the perm of each vertex. Value is the sample for that vertex.</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="c1"># calculate number of vertex to be plotted and the dictionary of vertices.</span>
  <span class="n">vertex_plot_dict</span><span class="o">=</span><span class="p">{}</span>
  <span class="k">if</span> <span class="n">vertex_perm_list</span><span class="p">:</span> <span class="c1"># vertex_perm_list is not empty</span>
    <span class="n">nvertex</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">vertex_perm_list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">perm</span> <span class="ow">in</span> <span class="n">vertex_perm_list</span><span class="p">:</span>
      <span class="n">vertex_plot_dict</span><span class="p">[</span><span class="n">perm</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex_dict</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">][</span><span class="n">perm</span><span class="p">]</span>
  <span class="k">else</span><span class="p">:</span> <span class="c1"># plot all vertices</span>
    <span class="k">if</span> <span class="n">is_finite_only</span><span class="p">:</span> 
      <span class="n">finite_key</span><span class="o">=</span><span class="s1">&#39;finite&#39;</span>
    <span class="k">else</span><span class="p">:</span> 
      <span class="n">finite_key</span><span class="o">=</span><span class="s1">&#39;all&#39;</span>
    <span class="n">nvertex</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex_dict</span><span class="p">[</span><span class="n">finite_key</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">vertex_plot_dict</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex_dict</span><span class="p">[</span><span class="n">finite_key</span><span class="p">]</span>
  <span class="c1"># now sample each vertex.</span>
  <span class="n">nsample_per_vertex</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">nsample</span><span class="o">/</span><span class="n">nvertex</span><span class="p">)</span> <span class="c1"># take the floor for number of sample per vertex</span>
  <span class="n">sample_vertex_dict</span><span class="o">=</span><span class="p">{}</span>
  <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">vv</span> <span class="ow">in</span> <span class="n">vertex_plot_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="n">sample_vertex_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="n">vv</span><span class="o">.</span><span class="n">vertex_hull_sampling</span><span class="p">(</span><span class="n">nsample_per_vertex</span><span class="p">,</span><span class="n">chart</span><span class="o">=</span><span class="n">chart</span><span class="p">,</span><span class="n">margin</span><span class="o">=</span><span class="n">margin</span><span class="p">,</span><span class="n">logmin</span><span class="o">=</span><span class="n">logmin</span><span class="p">,</span><span class="n">logmax</span><span class="o">=</span><span class="n">logmax</span><span class="p">,</span><span class="n">c_mat_extra</span><span class="o">=</span><span class="n">c_mat_extra</span><span class="p">,</span><span class="n">c0_vec_extra</span><span class="o">=</span><span class="n">c0_vec_extra</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">sample_vertex_dict</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="bcn.binding_network.binding_network.t2x_sym" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">t2x_sym</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Input a symbolic expression containing totals t, and map it to x.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>expr</code>
            </td>
            <td>
                  <code>sympy symbolic expression</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A symbolic expression to be converted.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>sympy symbolic expression: The symbolic expression after conversion.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/bcn/binding_network.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1964</span>
<span class="normal">1965</span>
<span class="normal">1966</span>
<span class="normal">1967</span>
<span class="normal">1968</span>
<span class="normal">1969</span>
<span class="normal">1970</span>
<span class="normal">1971</span>
<span class="normal">1972</span>
<span class="normal">1973</span>
<span class="normal">1974</span>
<span class="normal">1975</span>
<span class="normal">1976</span>
<span class="normal">1977</span>
<span class="normal">1978</span>
<span class="normal">1979</span>
<span class="normal">1980</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">t2x_sym</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">expr</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Input a symbolic expression containing totals t, and map it to x.</span>

<span class="sd">  Args:</span>
<span class="sd">      expr (sympy symbolic expression): A symbolic expression to be converted.</span>

<span class="sd">  Returns:</span>
<span class="sd">      sympy symbolic expression: The symbolic expression after conversion.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="c1"># calculate the substitutions map for totals to species</span>
  <span class="k">try</span><span class="p">:</span> <span class="n">expr_x</span><span class="o">=</span><span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t2x</span><span class="p">)</span>
  <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
    <span class="n">t2x_subs_list</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">subs_list_t2x</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">t2x</span><span class="o">=</span><span class="n">t2x_subs_list</span>
    <span class="n">expr_x</span><span class="o">=</span><span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t2x</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">expr_x</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="bcn.binding_network.binding_network.tk2x_num" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">tk2x_num</span><span class="p">(</span><span class="n">logtk</span><span class="p">,</span> <span class="n">a_mat</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Compute the logx value by numerical integration along the equilibrium manifold using log derivatives. The point on the manifold defined by logtk = (logt, logk) is the same as that defined by logx.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>logtk</code>
            </td>
            <td>
                  <code>numpy vector</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Vector numerical value for total variables (in first dim_d entries) and the binding reaction constants (in last dim_r entries) that define the point. 
p_(logx) = p_(logt, logk). Shape is (dim_n,). log is base 10.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>a_mat</code>
            </td>
            <td>
                  <code>numpy array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The matrix defining the total variables t = a_mat @ x that the log derivatives are taken with respect to.
Default should be specified to be self.l_mat.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>numpy vector: The numerical value of x at this point. log is base 10.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/bcn/binding_network.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1345</span>
<span class="normal">1346</span>
<span class="normal">1347</span>
<span class="normal">1348</span>
<span class="normal">1349</span>
<span class="normal">1350</span>
<span class="normal">1351</span>
<span class="normal">1352</span>
<span class="normal">1353</span>
<span class="normal">1354</span>
<span class="normal">1355</span>
<span class="normal">1356</span>
<span class="normal">1357</span>
<span class="normal">1358</span>
<span class="normal">1359</span>
<span class="normal">1360</span>
<span class="normal">1361</span>
<span class="normal">1362</span>
<span class="normal">1363</span>
<span class="normal">1364</span>
<span class="normal">1365</span>
<span class="normal">1366</span>
<span class="normal">1367</span>
<span class="normal">1368</span>
<span class="normal">1369</span>
<span class="normal">1370</span>
<span class="normal">1371</span>
<span class="normal">1372</span>
<span class="normal">1373</span>
<span class="normal">1374</span>
<span class="normal">1375</span>
<span class="normal">1376</span>
<span class="normal">1377</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">tk2x_num</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">logtk</span><span class="p">,</span><span class="n">a_mat</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Compute the logx value by numerical integration along the equilibrium manifold using log derivatives. The point on the manifold defined by logtk = (logt, logk) is the same as that defined by logx.</span>

<span class="sd">  Args:</span>
<span class="sd">      logtk (numpy vector): Vector numerical value for total variables (in first dim_d entries) and the binding reaction constants (in last dim_r entries) that define the point. </span>
<span class="sd">          p_(logx) = p_(logt, logk). Shape is (dim_n,). log is base 10.</span>
<span class="sd">      a_mat (numpy array): The matrix defining the total variables t = a_mat @ x that the log derivatives are taken with respect to.</span>
<span class="sd">          Default should be specified to be self.l_mat.</span>

<span class="sd">  Returns:</span>
<span class="sd">      numpy vector: The numerical value of x at this point. log is base 10.</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="c1"># the initial point is always x=1, (t,k) = (A*1, 1)</span>
  <span class="c1"># or, in log, logx=0, (logt,logk) = (log(A*1),0)</span>

  <span class="n">logt0</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a_mat</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
  <span class="n">logk0</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_r</span><span class="p">)</span>
  <span class="n">y0</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">logt0</span><span class="p">,</span><span class="n">logk0</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
  <span class="n">y1</span><span class="o">=</span><span class="n">logtk</span>
  <span class="n">logx0</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_n</span><span class="p">)</span>
  <span class="c1"># The time is pseudo time, parameterizing trajectory from y0 to y1,</span>
  <span class="c1"># where y0=(logt0,logk0) = (log(A*1),0), and y1=(logt,logk) the input.</span>
  <span class="c1"># So a point on the trajectory is gamma(tau) = tau*(y1-y0)+y0, 0&lt;=tau&lt;=1.</span>
  <span class="c1"># The time derivative is therefore</span>
  <span class="c1"># dlogx/dtau (x0) = dlogx/dlog(t,k) (x0) * dlog(t,k)/dtau (x0)</span>
  <span class="c1">#                 = dlogx/dlog(t,k) (x0) * (y1-y0)</span>
  <span class="c1"># dlogx/dlog(t,k) (x0) is log derivative matrix evaluated at x0.</span>
  <span class="n">time_derivative_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">tau</span><span class="p">,</span><span class="n">logx</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">logder_x_num</span><span class="p">(</span><span class="n">logx</span><span class="p">,</span><span class="n">a_mat</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">y1</span><span class="o">-</span><span class="n">y0</span><span class="p">)</span>
  <span class="n">sol</span><span class="o">=</span><span class="n">solve_ivp</span><span class="p">(</span><span class="n">time_derivative_func</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">logx0</span><span class="p">)</span>
  <span class="n">logx</span><span class="o">=</span><span class="n">sol</span><span class="o">.</span><span class="n">y</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">logx</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="bcn.binding_network.binding_network.vertex_constrained_construct" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">vertex_constrained_construct</span><span class="p">(</span><span class="n">opt_constraints</span><span class="p">,</span> <span class="n">chart</span><span class="o">=</span><span class="s1">&#39;xak&#39;</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Assuming self.vertex_dict is already computed, for given opt_constraints, this function computes whether the vertices are feasible under these constraints, updates rop_vertex.is_feasible for each vertex, and updates each vertex's feasible neighbors (stored in vertex.neighbors_constrained_dict). It returns is_feasible_dict, a dictionary of {perm: is_feasible} pairs.
This function calls vertex_list_feasibility_test.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>opt_constraints</code>
            </td>
            <td>
                  <code>list of cvxpy inequalities</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>List of constraints under which vertices are tested for feasibility.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>chart</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A string with value from {'x', 'xak', 'tk'} that specifies the chart that the opt_constraints are described in. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>&#39;xak&#39;</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>dict</code></td>            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A dictionary of {perm: is_feasible} pairs indicating whether a vertex is feasible.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/bcn/binding_network.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1599</span>
<span class="normal">1600</span>
<span class="normal">1601</span>
<span class="normal">1602</span>
<span class="normal">1603</span>
<span class="normal">1604</span>
<span class="normal">1605</span>
<span class="normal">1606</span>
<span class="normal">1607</span>
<span class="normal">1608</span>
<span class="normal">1609</span>
<span class="normal">1610</span>
<span class="normal">1611</span>
<span class="normal">1612</span>
<span class="normal">1613</span>
<span class="normal">1614</span>
<span class="normal">1615</span>
<span class="normal">1616</span>
<span class="normal">1617</span>
<span class="normal">1618</span>
<span class="normal">1619</span>
<span class="normal">1620</span>
<span class="normal">1621</span>
<span class="normal">1622</span>
<span class="normal">1623</span>
<span class="normal">1624</span>
<span class="normal">1625</span>
<span class="normal">1626</span>
<span class="normal">1627</span>
<span class="normal">1628</span>
<span class="normal">1629</span>
<span class="normal">1630</span>
<span class="normal">1631</span>
<span class="normal">1632</span>
<span class="normal">1633</span>
<span class="normal">1634</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">vertex_constrained_construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">opt_constraints</span><span class="p">,</span><span class="n">chart</span><span class="o">=</span><span class="s1">&#39;xak&#39;</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Assuming self.vertex_dict is already computed, for given opt_constraints, this function computes whether the vertices are feasible under these constraints, updates rop_vertex.is_feasible for each vertex, and updates each vertex&#39;s feasible neighbors (stored in vertex.neighbors_constrained_dict). It returns is_feasible_dict, a dictionary of {perm: is_feasible} pairs.</span>
<span class="sd">  This function calls vertex_list_feasibility_test.</span>

<span class="sd">  Args:</span>
<span class="sd">      opt_constraints (list of cvxpy inequalities): List of constraints under which vertices are tested for feasibility.</span>
<span class="sd">      chart (str, optional): A string with value from {&#39;x&#39;, &#39;xak&#39;, &#39;tk&#39;} that specifies the chart that the opt_constraints are described in. Defaults to None.</span>

<span class="sd">  Returns:</span>
<span class="sd">      dict: A dictionary of {perm: is_feasible} pairs indicating whether a vertex is feasible.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="c1"># for the given opt_constraints, test for each vertex whether it is feasible</span>
  <span class="c1"># under opt_constraints, and create a vertex dictionary for feasible vertices</span>
  <span class="c1"># under opt_constraints, stored in self.vertex_constrained_dict.</span>
  <span class="c1"># Also update each vertex&#39;s neighbors under constraints,</span>
  <span class="c1"># stored in each vertex.neighbors_constrained_dict.</span>

  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Compute feasible vertices...&#39;</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">perm</span><span class="p">,</span><span class="n">vv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_dict</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">is_feasible</span><span class="o">=</span><span class="n">vv</span><span class="o">.</span><span class="n">vertex_feasibility_test</span><span class="p">(</span><span class="n">chart</span><span class="o">=</span><span class="n">chart</span><span class="p">,</span><span class="n">opt_constraints</span><span class="o">=</span><span class="n">opt_constraints</span><span class="p">)</span>
    <span class="n">vv</span><span class="o">.</span><span class="n">is_feasible</span><span class="o">=</span><span class="n">is_feasible</span>
  <span class="n">vertex_feasible_all</span><span class="o">=</span><span class="p">{</span><span class="n">perm</span><span class="p">:</span><span class="n">vv</span> <span class="k">for</span> <span class="n">perm</span><span class="p">,</span><span class="n">vv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_dict</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">vv</span><span class="o">.</span><span class="n">is_feasible</span><span class="p">}</span>
  <span class="n">vertex_feasible_fin</span><span class="o">=</span><span class="p">{</span><span class="n">perm</span><span class="p">:</span><span class="n">vv</span> <span class="k">for</span> <span class="n">perm</span><span class="p">,</span><span class="n">vv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_dict</span><span class="p">[</span><span class="s1">&#39;finite&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">vv</span><span class="o">.</span><span class="n">is_feasible</span><span class="p">}</span>
  <span class="n">vertex_feasible_inf</span><span class="o">=</span><span class="p">{</span><span class="n">perm</span><span class="p">:</span><span class="n">vv</span> <span class="k">for</span> <span class="n">perm</span><span class="p">,</span><span class="n">vv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_dict</span><span class="p">[</span><span class="s1">&#39;infinite&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">vv</span><span class="o">.</span><span class="n">is_feasible</span><span class="p">}</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">vertex_constrained_dict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;all&#39;</span><span class="p">:</span><span class="n">vertex_feasible_all</span><span class="p">,</span><span class="s1">&#39;finite&#39;</span><span class="p">:</span><span class="n">vertex_feasible_fin</span><span class="p">,</span><span class="s1">&#39;infinite&#39;</span><span class="p">:</span><span class="n">vertex_feasible_inf</span><span class="p">}</span>

  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Compute neighbors under opt_constraints...&#39;</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">perm</span><span class="p">,</span><span class="n">vv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_dict</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">vv</span><span class="o">.</span><span class="n">is_feasible</span><span class="p">:</span>
      <span class="c1"># if it is feasible, we want to look at its neighbors.</span>
      <span class="c1"># if a neighbor is feasible, it is still a neighbor under constraint.</span>
      <span class="c1"># if a neighbor is infeasible, we look at its neighbors to see whether</span>
      <span class="c1"># they are feasible. This recurses.</span>
      <span class="n">vv</span><span class="o">.</span><span class="n">vertex_update_constrained_neighbors</span><span class="p">()</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Done.&#39;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="bcn.binding_network.binding_network.vertex_construct" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">vertex_construct</span><span class="p">()</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Construct the rop_vertex objects that this binding network can have, compute their orientation and feasibility (without additional constraints), and store them in self.vertex_dict.
Then the vertices' neighbors, log derivative, and c_mat_xak are computed and stored in these objects.</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>None. The vertices are recorded in self.vertex_dict and by updating the vertex objects.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/bcn/binding_network.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1460</span>
<span class="normal">1461</span>
<span class="normal">1462</span>
<span class="normal">1463</span>
<span class="normal">1464</span>
<span class="normal">1465</span>
<span class="normal">1466</span>
<span class="normal">1467</span>
<span class="normal">1468</span>
<span class="normal">1469</span>
<span class="normal">1470</span>
<span class="normal">1471</span>
<span class="normal">1472</span>
<span class="normal">1473</span>
<span class="normal">1474</span>
<span class="normal">1475</span>
<span class="normal">1476</span>
<span class="normal">1477</span>
<span class="normal">1478</span>
<span class="normal">1479</span>
<span class="normal">1480</span>
<span class="normal">1481</span>
<span class="normal">1482</span>
<span class="normal">1483</span>
<span class="normal">1484</span>
<span class="normal">1485</span>
<span class="normal">1486</span>
<span class="normal">1487</span>
<span class="normal">1488</span>
<span class="normal">1489</span>
<span class="normal">1490</span>
<span class="normal">1491</span>
<span class="normal">1492</span>
<span class="normal">1493</span>
<span class="normal">1494</span>
<span class="normal">1495</span>
<span class="normal">1496</span>
<span class="normal">1497</span>
<span class="normal">1498</span>
<span class="normal">1499</span>
<span class="normal">1500</span>
<span class="normal">1501</span>
<span class="normal">1502</span>
<span class="normal">1503</span>
<span class="normal">1504</span>
<span class="normal">1505</span>
<span class="normal">1506</span>
<span class="normal">1507</span>
<span class="normal">1508</span>
<span class="normal">1509</span>
<span class="normal">1510</span>
<span class="normal">1511</span>
<span class="normal">1512</span>
<span class="normal">1513</span>
<span class="normal">1514</span>
<span class="normal">1515</span>
<span class="normal">1516</span>
<span class="normal">1517</span>
<span class="normal">1518</span>
<span class="normal">1519</span>
<span class="normal">1520</span>
<span class="normal">1521</span></pre></div></td><td class="code"><div><pre><span></span><code>  <span class="k">def</span><span class="w"> </span><span class="nf">vertex_construct</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct the rop_vertex objects that this binding network can have, compute their orientation and feasibility (without additional constraints), and store them in self.vertex_dict.</span>
<span class="sd">    Then the vertices&#39; neighbors, log derivative, and c_mat_xak are computed and stored in these objects.</span>

<span class="sd">    Args:</span>
<span class="sd">        None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None. The vertices are recorded in self.vertex_dict and by updating the vertex objects.</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="c1"># Construct a dictionary of reachable vertices.</span>
    <span class="c1"># because l_mat tends to be sparse, we iterate through its rows to get nonzero indices,</span>
    <span class="c1"># then each vertex&#39;s dominance condition a_mat is choosen from the nonezro indices.</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Constructing vertex objects and test for feasibility...&#39;</span><span class="p">)</span>
    <span class="n">d</span><span class="p">,</span><span class="n">n</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">l_mat</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">orientation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">orientation</span>
    <span class="n">nnz_list</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
      <span class="n">nnz_list</span><span class="o">=</span><span class="n">nnz_list</span><span class="o">+</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l_mat</span><span class="p">[</span><span class="n">i</span><span class="p">,:])[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">vertex_inf_dict</span><span class="o">=</span><span class="p">{}</span>
    <span class="n">vertex_fin_dict</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">perm</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">nnz_list</span><span class="p">):</span>
      <span class="n">vertex</span><span class="o">=</span><span class="n">rop_vertex</span><span class="p">(</span><span class="n">perm</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">vertex</span><span class="o">.</span><span class="n">orientation</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="c1"># this is possibly an infinite vertex</span>
        <span class="c1"># check for rank =1, meaning perm has exactly one repeat</span>
        <span class="n">perm_count</span><span class="o">=</span><span class="p">[</span><span class="n">perm</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">)]</span>
        <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">perm_count</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">perm_count</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span> <span class="c1"># because that same value shows up twice, each with count 2.</span>
            <span class="c1"># after all that check, there still can be infinite vertices that are not reachable</span>
            <span class="c1"># so we do feasibility test.</span>
            <span class="n">is_feasible</span><span class="o">=</span><span class="n">vertex</span><span class="o">.</span><span class="n">vertex_feasibility_test</span><span class="p">(</span><span class="n">chart</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="n">opt_constraints</span><span class="o">=</span><span class="p">[])</span>
            <span class="c1"># and then add to vertex_inf_dict.</span>
            <span class="k">if</span> <span class="n">is_feasible</span><span class="p">:</span>
              <span class="n">vertex_inf_dict</span><span class="p">[</span><span class="n">perm</span><span class="p">]</span><span class="o">=</span><span class="n">vertex</span>
      <span class="k">elif</span> <span class="n">vertex</span><span class="o">.</span><span class="n">orientation</span><span class="o">==</span><span class="n">orientation</span><span class="p">:</span>
        <span class="c1"># this is a finite vertex with the right orientation</span>
        <span class="c1"># we test for feasibility</span>
        <span class="n">is_feasible</span><span class="o">=</span><span class="n">vertex</span><span class="o">.</span><span class="n">vertex_feasibility_test</span><span class="p">(</span><span class="n">chart</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="n">opt_constraints</span><span class="o">=</span><span class="p">[])</span>
        <span class="c1"># and then add to vertex_fin_dict.</span>
        <span class="k">if</span> <span class="n">is_feasible</span><span class="p">:</span>
          <span class="n">vertex_fin_dict</span><span class="p">[</span><span class="n">perm</span><span class="p">]</span><span class="o">=</span><span class="n">vertex</span>
    <span class="n">vertex_dict</span><span class="o">=</span><span class="p">{</span><span class="o">**</span><span class="n">vertex_fin_dict</span><span class="p">,</span><span class="o">**</span><span class="n">vertex_inf_dict</span><span class="p">}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">vertex_dict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;all&#39;</span><span class="p">:</span><span class="n">vertex_dict</span><span class="p">,</span><span class="s1">&#39;finite&#39;</span><span class="p">:</span><span class="n">vertex_fin_dict</span><span class="p">,</span><span class="s1">&#39;infinite&#39;</span><span class="p">:</span><span class="n">vertex_inf_dict</span><span class="p">}</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Finished vertex construction, now computing neighbors of vertices...&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">perm</span><span class="p">,</span><span class="n">vv</span> <span class="ow">in</span> <span class="n">vertex_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
      <span class="n">vv</span><span class="o">.</span><span class="n">vertex_find_neighbors</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Finished neighbors, now computing log derivatives...&#39;</span><span class="p">)</span>
    <span class="c1"># first compute log der for finite vertices, since infinite ones rely on</span>
    <span class="c1"># finite neighbors to find orientation.</span>
    <span class="k">for</span> <span class="n">perm</span><span class="p">,</span><span class="n">vv</span> <span class="ow">in</span> <span class="n">vertex_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
      <span class="n">vv</span><span class="o">.</span><span class="n">vertex_ld_calc</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Finished log derivatives, now computing c_mat_xak&#39;</span><span class="p">)</span>
    <span class="c1"># compute c_mat_xak for each vertex in preparation for feasibility tests.</span>
    <span class="k">for</span> <span class="n">perm</span><span class="p">,</span><span class="n">vv</span> <span class="ow">in</span> <span class="n">vertex_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
      <span class="n">vv</span><span class="o">.</span><span class="n">vertex_c_mat_xak_calc</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Done.&#39;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="bcn.binding_network.binding_network.vertex_construct_direct" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">vertex_construct_direct</span><span class="p">()</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Construct the rop_vertex objects that this binding network can have, directly, without feasibility test.</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>None. The vertices are recorded in self.vertex_dict and by updating the vertex objects.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/bcn/binding_network.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1545</span>
<span class="normal">1546</span>
<span class="normal">1547</span>
<span class="normal">1548</span>
<span class="normal">1549</span>
<span class="normal">1550</span>
<span class="normal">1551</span>
<span class="normal">1552</span>
<span class="normal">1553</span>
<span class="normal">1554</span>
<span class="normal">1555</span>
<span class="normal">1556</span>
<span class="normal">1557</span>
<span class="normal">1558</span>
<span class="normal">1559</span>
<span class="normal">1560</span>
<span class="normal">1561</span>
<span class="normal">1562</span>
<span class="normal">1563</span>
<span class="normal">1564</span>
<span class="normal">1565</span>
<span class="normal">1566</span>
<span class="normal">1567</span>
<span class="normal">1568</span>
<span class="normal">1569</span>
<span class="normal">1570</span>
<span class="normal">1571</span>
<span class="normal">1572</span>
<span class="normal">1573</span>
<span class="normal">1574</span>
<span class="normal">1575</span>
<span class="normal">1576</span>
<span class="normal">1577</span>
<span class="normal">1578</span>
<span class="normal">1579</span>
<span class="normal">1580</span>
<span class="normal">1581</span>
<span class="normal">1582</span>
<span class="normal">1583</span>
<span class="normal">1584</span>
<span class="normal">1585</span>
<span class="normal">1586</span>
<span class="normal">1587</span>
<span class="normal">1588</span>
<span class="normal">1589</span>
<span class="normal">1590</span>
<span class="normal">1591</span>
<span class="normal">1592</span>
<span class="normal">1593</span>
<span class="normal">1594</span>
<span class="normal">1595</span>
<span class="normal">1596</span>
<span class="normal">1597</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">vertex_construct_direct</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Construct the rop_vertex objects that this binding network can have, directly, without feasibility test.</span>

<span class="sd">  Args:</span>
<span class="sd">      None.</span>

<span class="sd">  Returns:</span>
<span class="sd">      None. The vertices are recorded in self.vertex_dict and by updating the vertex objects.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="c1"># We construct the vertices by iteratively construct all the possible</span>
  <span class="c1"># dominance vector (perm).</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Constructing vertex objects DIRECTLY...&#39;</span><span class="p">)</span>
  <span class="n">a_mat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">l_mat</span>
  <span class="n">d</span><span class="p">,</span><span class="n">n</span><span class="o">=</span><span class="n">a_mat</span><span class="o">.</span><span class="n">shape</span>
  <span class="n">not_dominated_col_idx</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
  <span class="n">dominated_row_vec_prev</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
  <span class="n">dom_tuple_prev</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
  <span class="n">perm_dict</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__get_dom_vec</span><span class="p">(</span><span class="n">a_mat</span><span class="p">,</span><span class="n">not_dominated_col_idx</span><span class="p">,</span><span class="n">dominated_row_vec_prev</span><span class="p">,</span><span class="n">dom_tuple_prev</span><span class="p">)</span>
  <span class="n">vertex_fin_dict</span><span class="o">=</span><span class="p">{}</span>
  <span class="n">vertex_inf_dict</span><span class="o">=</span><span class="p">{}</span>
  <span class="n">vertex_infHO_dict</span><span class="o">=</span><span class="p">{}</span>
  <span class="k">for</span> <span class="n">perm</span> <span class="ow">in</span> <span class="n">perm_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
    <span class="n">vertex</span><span class="o">=</span><span class="n">rop_vertex</span><span class="p">(</span><span class="n">perm</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">repeat_vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">vertex</span><span class="o">.</span><span class="n">p_mat</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">vertex</span><span class="o">.</span><span class="n">orientation</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
      <span class="n">vertex_fin_dict</span><span class="p">[</span><span class="n">perm</span><span class="p">]</span><span class="o">=</span><span class="n">vertex</span>
    <span class="c1"># elif np.max(repeat_vec)&gt;2 or np.sum(repeat_vec&gt;1) &gt;=2:</span>
      <span class="c1"># there is an index repeated 3 or more times, OR there are more than two indices repeated twice or above;</span>
      <span class="c1"># So this is an infinite vertex of higher order.</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">repeat_vec</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">repeat_vec</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]])</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">:</span>
      <span class="c1"># another way to test for higher order is the sum of repeated indices&#39; total repeated times is &gt;2.</span>
      <span class="n">vertex_infHO_dict</span><span class="p">[</span><span class="n">perm</span><span class="p">]</span><span class="o">=</span><span class="n">vertex</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1">#infinite vertex of order one</span>
      <span class="n">vertex_inf_dict</span><span class="p">[</span><span class="n">perm</span><span class="p">]</span><span class="o">=</span><span class="n">vertex</span>
  <span class="n">vertex_dict</span><span class="o">=</span><span class="p">{</span><span class="o">**</span><span class="n">vertex_fin_dict</span><span class="p">,</span><span class="o">**</span><span class="n">vertex_inf_dict</span><span class="p">}</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">vertex_dict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;all&#39;</span><span class="p">:</span><span class="n">vertex_dict</span><span class="p">,</span><span class="s1">&#39;finite&#39;</span><span class="p">:</span><span class="n">vertex_fin_dict</span><span class="p">,</span><span class="s1">&#39;infinite&#39;</span><span class="p">:</span><span class="n">vertex_inf_dict</span><span class="p">,</span><span class="s1">&#39;infiniteHO&#39;</span><span class="p">:</span><span class="n">vertex_infHO_dict</span><span class="p">}</span>

  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Finished vertex construction, now computing neighbors of vertices...&#39;</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">perm</span><span class="p">,</span><span class="n">vv</span> <span class="ow">in</span> <span class="n">vertex_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">vv</span><span class="o">.</span><span class="n">vertex_find_neighbors</span><span class="p">()</span>

  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Finished neighbors, now computing log derivatives...&#39;</span><span class="p">)</span>
  <span class="c1"># first compute log der for finite vertices, since infinite ones rely on</span>
  <span class="c1"># finite neighbors to find orientation.</span>
  <span class="k">for</span> <span class="n">perm</span><span class="p">,</span><span class="n">vv</span> <span class="ow">in</span> <span class="n">vertex_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">vv</span><span class="o">.</span><span class="n">vertex_ld_calc</span><span class="p">()</span>

  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Finished log derivatives, now computing c_mat_xak&#39;</span><span class="p">)</span>
  <span class="c1"># compute c_mat_xak for each vertex in preparation for feasibility tests.</span>
  <span class="k">for</span> <span class="n">perm</span><span class="p">,</span><span class="n">vv</span> <span class="ow">in</span> <span class="n">vertex_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">vv</span><span class="o">.</span><span class="n">vertex_c_mat_xak_calc</span><span class="p">()</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Done.&#39;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="bcn.binding_network.binding_network.vertex_list_feasibility_test" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">vertex_list_feasibility_test</span><span class="p">(</span><span class="n">opt_constraints</span><span class="p">,</span> <span class="n">chart</span><span class="o">=</span><span class="s1">&#39;xak&#39;</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Given opt_constraints, test all the vertices for their feasibility and return is_feasible_dict.
This function is called by vertex_constrained_construct.
It can also be directly called to test for feasibility without storing or finding feasible neighbors.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>opt_constraints</code>
            </td>
            <td>
                  <code>list of cvxpy inequalities</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>List of constraints under which vertices are tested for feasibility.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>chart</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A string with value from {'x', 'xak', 'tk'} that specifies the chart that the opt_constraints are described in. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>&#39;xak&#39;</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>dict</code></td>            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A dictionary of {perm: is_feasible} pairs indicating whether a vertex is feasible.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/bcn/binding_network.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1636</span>
<span class="normal">1637</span>
<span class="normal">1638</span>
<span class="normal">1639</span>
<span class="normal">1640</span>
<span class="normal">1641</span>
<span class="normal">1642</span>
<span class="normal">1643</span>
<span class="normal">1644</span>
<span class="normal">1645</span>
<span class="normal">1646</span>
<span class="normal">1647</span>
<span class="normal">1648</span>
<span class="normal">1649</span>
<span class="normal">1650</span>
<span class="normal">1651</span>
<span class="normal">1652</span>
<span class="normal">1653</span>
<span class="normal">1654</span>
<span class="normal">1655</span>
<span class="normal">1656</span>
<span class="normal">1657</span>
<span class="normal">1658</span>
<span class="normal">1659</span>
<span class="normal">1660</span>
<span class="normal">1661</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">vertex_list_feasibility_test</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">opt_constraints</span><span class="p">,</span><span class="n">chart</span><span class="o">=</span><span class="s1">&#39;xak&#39;</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Given opt_constraints, test all the vertices for their feasibility and return is_feasible_dict.</span>
<span class="sd">  This function is called by vertex_constrained_construct.</span>
<span class="sd">  It can also be directly called to test for feasibility without storing or finding feasible neighbors.</span>

<span class="sd">  Args:</span>
<span class="sd">      opt_constraints (list of cvxpy inequalities): List of constraints under which vertices are tested for feasibility.</span>
<span class="sd">      chart (str, optional): A string with value from {&#39;x&#39;, &#39;xak&#39;, &#39;tk&#39;} that specifies the chart that the opt_constraints are described in. Defaults to None.</span>

<span class="sd">  Returns:</span>
<span class="sd">      dict: A dictionary of {perm: is_feasible} pairs indicating whether a vertex is feasible.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="c1"># for the given opt_constraints, test each of the vertex whether it is feasible</span>
  <span class="n">is_feasible_fin</span><span class="o">=</span><span class="p">{}</span>
  <span class="n">is_feasible_inf</span><span class="o">=</span><span class="p">{}</span>
  <span class="k">for</span> <span class="n">perm</span><span class="p">,</span><span class="n">vv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_dict</span><span class="p">[</span><span class="s1">&#39;finite&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">is_feasible</span><span class="o">=</span><span class="n">vv</span><span class="o">.</span><span class="n">vertex_feasibility_test</span><span class="p">(</span><span class="n">chart</span><span class="o">=</span><span class="n">chart</span><span class="p">,</span><span class="n">opt_constraints</span><span class="o">=</span><span class="n">opt_constraints</span><span class="p">)</span>
    <span class="n">is_feasible_fin</span><span class="p">[</span><span class="n">perm</span><span class="p">]</span><span class="o">=</span><span class="n">is_feasible</span>
  <span class="k">for</span> <span class="n">perm</span><span class="p">,</span><span class="n">vv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_dict</span><span class="p">[</span><span class="s1">&#39;infinite&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">is_feasible</span><span class="o">=</span><span class="n">vv</span><span class="o">.</span><span class="n">vertex_feasibility_test</span><span class="p">(</span><span class="n">chart</span><span class="o">=</span><span class="n">chart</span><span class="p">,</span><span class="n">opt_constraints</span><span class="o">=</span><span class="n">opt_constraints</span><span class="p">)</span>
    <span class="n">is_feasible_inf</span><span class="p">[</span><span class="n">perm</span><span class="p">]</span><span class="o">=</span><span class="n">is_feasible</span>

  <span class="n">is_feasible_all</span><span class="o">=</span><span class="p">{</span><span class="o">**</span><span class="n">is_feasible_fin</span><span class="p">,</span><span class="o">**</span><span class="n">is_feasible_inf</span><span class="p">}</span>
  <span class="n">is_feasible_dict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;all&#39;</span><span class="p">:</span><span class="n">is_feasible_all</span><span class="p">,</span><span class="s1">&#39;finite&#39;</span><span class="p">:</span><span class="n">is_feasible_fin</span><span class="p">,</span><span class="s1">&#39;infinite&#39;</span><span class="p">:</span><span class="n">is_feasible_inf</span><span class="p">}</span>
  <span class="k">return</span> <span class="n">is_feasible_dict</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="bcn.binding_network.binding_network.x2tk_num" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">x2tk_num</span><span class="p">(</span><span class="n">logx</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Compute the (logt, logk) value given logx.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>logx</code>
            </td>
            <td>
                  <code>numpy vector</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Vector numerical value for total variables that define the x point.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>tuple</code></td>            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A tuple containing two numpy vectors:
- logt: The numerical value of total concentration at this point. log is base 10.
- logk: The numerical value of binding constants at this point. log is base 10.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/bcn/binding_network.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1300</span>
<span class="normal">1301</span>
<span class="normal">1302</span>
<span class="normal">1303</span>
<span class="normal">1304</span>
<span class="normal">1305</span>
<span class="normal">1306</span>
<span class="normal">1307</span>
<span class="normal">1308</span>
<span class="normal">1309</span>
<span class="normal">1310</span>
<span class="normal">1311</span>
<span class="normal">1312</span>
<span class="normal">1313</span>
<span class="normal">1314</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">x2tk_num</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">logx</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Compute the (logt, logk) value given logx.</span>

<span class="sd">  Args:</span>
<span class="sd">      logx (numpy vector): Vector numerical value for total variables that define the x point.</span>

<span class="sd">  Returns:</span>
<span class="sd">      tuple: A tuple containing two numpy vectors:</span>
<span class="sd">          - logt: The numerical value of total concentration at this point. log is base 10.</span>
<span class="sd">          - logk: The numerical value of binding constants at this point. log is base 10.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">logt</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l_mat</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="n">logx</span><span class="p">))</span>
  <span class="n">logk</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_mat</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">logx</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">logt</span><span class="p">,</span><span class="n">logk</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="bcn.binding_network.binding_network.xak2x_num" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">xak2x_num</span><span class="p">(</span><span class="n">logxak</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Compute the logx value given logxak = (logxa, logk).</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>logxak</code>
            </td>
            <td>
                  <code>numpy vector</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Vector numerical value for atomic species concentration (first dim_d entries) and binding reaction constants (last dim_r entries). Shape is (dim_n,).
log is base 10.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>numpy vector: The numerical value of logx at this point.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/bcn/binding_network.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1316</span>
<span class="normal">1317</span>
<span class="normal">1318</span>
<span class="normal">1319</span>
<span class="normal">1320</span>
<span class="normal">1321</span>
<span class="normal">1322</span>
<span class="normal">1323</span>
<span class="normal">1324</span>
<span class="normal">1325</span>
<span class="normal">1326</span>
<span class="normal">1327</span>
<span class="normal">1328</span>
<span class="normal">1329</span>
<span class="normal">1330</span>
<span class="normal">1331</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">xak2x_num</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">logxak</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Compute the logx value given logxak = (logxa, logk).</span>

<span class="sd">  Args:</span>
<span class="sd">      logxak (numpy vector): Vector numerical value for atomic species concentration (first dim_d entries) and binding reaction constants (last dim_r entries). Shape is (dim_n,).</span>
<span class="sd">          log is base 10.</span>

<span class="sd">  Returns:</span>
<span class="sd">      numpy vector: The numerical value of logx at this point.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">try</span><span class="p">:</span> <span class="n">xak2x_map</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xak2x_map</span>
  <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">calc_xak2x_map</span><span class="p">()</span> <span class="c1"># if doesn&#39;t exist, calculate it</span>
    <span class="n">xak2x_map</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">xak2x_map</span>
  <span class="k">return</span> <span class="n">xak2x_map</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">logxak</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="bcn.binding_network.binding_network.xc2xak_sym" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">xc2xak_sym</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Input a symbolic expression containing complex species x^c, and map it to x^a and k.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>expr</code>
            </td>
            <td>
                  <code>sympy symbolic expression</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A symbolic expression to be converted.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>sympy symbolic expression: The symbolic expression after conversion.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/bcn/binding_network.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1982</span>
<span class="normal">1983</span>
<span class="normal">1984</span>
<span class="normal">1985</span>
<span class="normal">1986</span>
<span class="normal">1987</span>
<span class="normal">1988</span>
<span class="normal">1989</span>
<span class="normal">1990</span>
<span class="normal">1991</span>
<span class="normal">1992</span>
<span class="normal">1993</span>
<span class="normal">1994</span>
<span class="normal">1995</span>
<span class="normal">1996</span>
<span class="normal">1997</span>
<span class="normal">1998</span>
<span class="normal">1999</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">xc2xak_sym</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">expr</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Input a symbolic expression containing complex species x^c, and map it to x^a and k.</span>

<span class="sd">  Args:</span>
<span class="sd">      expr (sympy symbolic expression): A symbolic expression to be converted.</span>

<span class="sd">  Returns:</span>
<span class="sd">      sympy symbolic expression: The symbolic expression after conversion.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_atomic</span><span class="p">,</span> <span class="s2">&quot;this operation requires the binding network to be atomic&quot;</span>
  <span class="c1"># calculate the substitutions map for complex species to atomic species and k&#39;s, if it does not exist.</span>
  <span class="k">try</span><span class="p">:</span> <span class="n">expr_xak</span><span class="o">=</span><span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xc2xak</span><span class="p">)</span>
  <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
    <span class="n">xc2xak_subs_list</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">subs_list_xc2xak</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">xc2xak</span><span class="o">=</span><span class="n">xc2xak_subs_list</span>
    <span class="n">expr_xak</span><span class="o">=</span><span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xc2xak</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">expr_xak</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="bcn.binding_network.rop_dom_regime" class="doc doc-heading">
            <code>rop_dom_regime</code>


</h2>


    <div class="doc doc-contents ">


        <p>A dominance regime (dom_regime) object for a catalytic activity on top of a given binding network defined by b^T x, for some b vector.
  A dominance regime is labeled by a tuple ((perm), j) where perm is the permutation (a length-n tuple) defining the vertex, and j is the dominant species index in activity b^T x.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>row_idx</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The integer j indicating x_j is the dominant species in b^T x at this regime.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>b_vec</code>
            </td>
            <td>
                  <code>numpy array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The b vector defining the activity b^T x.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>vertex_perm</code>
            </td>
            <td>
                  <code>tuple of int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The tuple of length d (number of totals of binding network) referring to the dominance vertex that this dom_regime belongs to.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>vertex</code>
            </td>
            <td>
                  <code><span title="ROP_vertex">ROP_vertex</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The vertex that this dom_regime belongs to. This dom_regime is at this vertex with an additional dominance condition for the activity.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>bn</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="bcn.binding_network.binding_network" href="#bcn.binding_network.binding_network">binding_network</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The binding network that this dom_regime belongs to.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>ld</code>
            </td>
            <td>
                  <code><span title="tuple">tuple</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The reaction order or log derivative of this dom_regime. The row_idx row of the vertex's h_mat.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>neighbors_dict</code>
            </td>
            <td>
                  <code><span title="dict">dict</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The dictionary for dom_regime neighbors of this dom_regime.
Has four keys, three of them are "finite", "infinite", and "all",
for finite, infinite (ray) dom_regime neighbors, and all of dom_regime neighbors, respectively.
For each of these keys, we get a dictionary as well, with a (perm, row_idx) tuple as key and the dom_regime object as value.
The last key is "zero", which maps to neighbors connected via dom_regimes that are zero rays in reaction orders (or log derivative).
The value is itself a dictionary with "finite", "infinite", and "all" mapping to dictionaries with (ld: ld_regime) entries.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>is_feasible</code>
            </td>
            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether this dom_regime is feasible under the last given constraints.
If a new set of constraints is given and tested, then this is overwritten.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>neighbors_constrained_dict</code>
            </td>
            <td>
                  <code><span title="dict">dict</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The dictionary for ld_regime neighbors of this ld_regime that are feasible under constraints applied to each dom_regime.
Same keys as neighbors_dict.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>c_mat_add_x</code>
            </td>
            <td>
                  <code>numpy array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Additional inequalities specifying the condition to reach this dom_regime on top of the inequalities from its vertex.
To be concatenated vertically with vertex.c_mat_x. This is in chart 'x'.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>c_mat_add_xak</code>
            </td>
            <td>
                  <code>numpy array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Additional inequalities specifying the condition to reach this dom_regime on top of the inequalities from its vertex.
To be concatenated vertically with vertex.c_mat_xak. This is in chart 'xak'.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>c0_vec_add</code>
            </td>
            <td>
                  <code>numpy array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Additional intercept vector entries for the inequalities specifying the condition to reach this dom_regime on top of the inequalities from its vertex.
To be concatenated vertically with vertex.c0_vec when used to specify inequalities.
Same vector for both chart 'x' and 'xak'.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>c_mat_add_tk</code>
            </td>
            <td>
                  <code>numpy array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Additional inequalities specifying this dom_regime on top of the inequalities from its vertex.
To be concatenated vertically with vertex.c_mat_tk. This is in chart 'tk'.
Is only meaningful if its vertex is non-singular.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>






              <details class="quote">
                <summary>Source code in <code>src/bcn/binding_network.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">rop_dom_regime</span><span class="p">:</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  A dominance regime (dom_regime) object for a catalytic activity on top of a given binding network defined by b^T x, for some b vector.</span>
<span class="sd">    A dominance regime is labeled by a tuple ((perm), j) where perm is the permutation (a length-n tuple) defining the vertex, and j is the dominant species index in activity b^T x.</span>

<span class="sd">  Args:</span>
<span class="sd">      row_idx (int): The integer j indicating x_j is the dominant species in b^T x at this regime.</span>
<span class="sd">      b_vec (numpy array): The b vector defining the activity b^T x.</span>
<span class="sd">      vertex_perm (tuple of int): The tuple of length d (number of totals of binding network) referring to the dominance vertex that this dom_regime belongs to.</span>
<span class="sd">      vertex (ROP_vertex): The vertex that this dom_regime belongs to. This dom_regime is at this vertex with an additional dominance condition for the activity.</span>
<span class="sd">      bn (binding_network): The binding network that this dom_regime belongs to.</span>
<span class="sd">      ld (tuple): The reaction order or log derivative of this dom_regime. The row_idx row of the vertex&#39;s h_mat.</span>
<span class="sd">      neighbors_dict (dict): The dictionary for dom_regime neighbors of this dom_regime.</span>
<span class="sd">          Has four keys, three of them are &quot;finite&quot;, &quot;infinite&quot;, and &quot;all&quot;,</span>
<span class="sd">          for finite, infinite (ray) dom_regime neighbors, and all of dom_regime neighbors, respectively.</span>
<span class="sd">          For each of these keys, we get a dictionary as well, with a (perm, row_idx) tuple as key and the dom_regime object as value.</span>
<span class="sd">          The last key is &quot;zero&quot;, which maps to neighbors connected via dom_regimes that are zero rays in reaction orders (or log derivative).</span>
<span class="sd">          The value is itself a dictionary with &quot;finite&quot;, &quot;infinite&quot;, and &quot;all&quot; mapping to dictionaries with (ld: ld_regime) entries.</span>
<span class="sd">      is_feasible (bool): Whether this dom_regime is feasible under the last given constraints.</span>
<span class="sd">          If a new set of constraints is given and tested, then this is overwritten.</span>
<span class="sd">      neighbors_constrained_dict (dict): The dictionary for ld_regime neighbors of this ld_regime that are feasible under constraints applied to each dom_regime.</span>
<span class="sd">          Same keys as neighbors_dict.</span>
<span class="sd">      c_mat_add_x (numpy array): Additional inequalities specifying the condition to reach this dom_regime on top of the inequalities from its vertex.</span>
<span class="sd">          To be concatenated vertically with vertex.c_mat_x. This is in chart &#39;x&#39;.</span>
<span class="sd">      c_mat_add_xak (numpy array): Additional inequalities specifying the condition to reach this dom_regime on top of the inequalities from its vertex.</span>
<span class="sd">          To be concatenated vertically with vertex.c_mat_xak. This is in chart &#39;xak&#39;.</span>
<span class="sd">      c0_vec_add (numpy array): Additional intercept vector entries for the inequalities specifying the condition to reach this dom_regime on top of the inequalities from its vertex.</span>
<span class="sd">          To be concatenated vertically with vertex.c0_vec when used to specify inequalities.</span>
<span class="sd">          Same vector for both chart &#39;x&#39; and &#39;xak&#39;.</span>
<span class="sd">      c_mat_add_tk (numpy array): Additional inequalities specifying this dom_regime on top of the inequalities from its vertex.</span>
<span class="sd">          To be concatenated vertically with vertex.c_mat_tk. This is in chart &#39;tk&#39;.</span>
<span class="sd">          Is only meaningful if its vertex is non-singular.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">row_idx</span><span class="p">,</span><span class="n">b_vec</span><span class="p">,</span><span class="n">vertex_perm</span><span class="p">,</span><span class="n">bn</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initiates a ROP vertex.</span>

<span class="sd">    Args:</span>
<span class="sd">        row_idx (int): The integer j indicating x_j is the dominant species in b^T x at this regime.</span>
<span class="sd">        b_vec (numpy array): The b vector defining the activity b^T x.</span>
<span class="sd">        vertex_perm (tuple of int): The tuple of length d (number of totals of binding network) referring to the dominance vertex that this dom_regime belongs to.</span>
<span class="sd">        bn (binding_network): The binding network that this dom_regime belongs to.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">row_idx</span><span class="o">=</span><span class="n">row_idx</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">b_vec</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">b_vec</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">vertex_perm</span><span class="o">=</span><span class="n">vertex_perm</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">vertex</span><span class="o">=</span><span class="n">bn</span><span class="o">.</span><span class="n">vertex_dict</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">][</span><span class="n">vertex_perm</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">=</span><span class="n">bn</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ld</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex</span><span class="o">.</span><span class="n">h_mat</span><span class="p">[</span><span class="n">row_idx</span><span class="p">,:])</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">is_feasible</span><span class="o">=</span><span class="kc">True</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">chart_check_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">chart</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">chart</span><span class="o">==</span><span class="s1">&#39;x&#39;</span><span class="p">:</span>
      <span class="k">try</span><span class="p">:</span> 
        <span class="n">c_mat_add</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c_mat_add_x</span>
        <span class="n">c0_vec_add</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c0_vec_add</span>
      <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span> <span class="c1"># c_mat_add is not yet calculated</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calc_c_mat_add_x</span><span class="p">()</span>
        <span class="n">c_mat_add</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c_mat_add_x</span>
        <span class="n">c0_vec_add</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c0_vec_add</span>
    <span class="k">elif</span> <span class="n">chart</span><span class="o">==</span><span class="s1">&#39;xak&#39;</span><span class="p">:</span>
      <span class="k">try</span><span class="p">:</span> 
        <span class="n">c_mat_add</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c_mat_add_xak</span>
        <span class="n">c0_vec_add</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c0_vec_add</span>
      <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span> <span class="c1"># c_mat_add_xak is not yet calculated</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calc_c_mat_add_xak</span><span class="p">()</span>
        <span class="n">c_mat_add</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c_mat_add_xak</span>
        <span class="n">c0_vec_add</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c0_vec_add</span>
    <span class="k">elif</span> <span class="n">chart</span><span class="o">==</span><span class="s1">&#39;tk&#39;</span><span class="p">:</span>
      <span class="k">try</span><span class="p">:</span> 
        <span class="n">c_mat_add</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c_mat_add_tk</span>
        <span class="n">c0_vec_add</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c0_vec_add_tk</span>
      <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span> <span class="c1"># c_mat_add_tk is not yet calculated</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calc_c_mat_add_tk</span><span class="p">()</span>
        <span class="n">c_mat_add</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c_mat_add_tk</span>
        <span class="n">c0_vec_add</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c0_vec_add_tk</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;chart that is not one of &quot;x,xak,tk&quot; is not implemented yet&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">c_mat_add</span><span class="p">,</span><span class="n">c0_vec_add</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">feasibility_test</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">chart</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="n">opt_constraints</span><span class="o">=</span><span class="p">[],</span><span class="n">positive_threshold</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span><span class="n">is_asymptotic</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="n">c_mat_add</span><span class="p">,</span><span class="n">c0_vec_add</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chart_check_add</span><span class="p">(</span><span class="n">chart</span><span class="p">)</span>
    <span class="n">vv</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex</span>
    <span class="n">opt_var</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">.</span><span class="n">opt_var</span>
    <span class="n">opt_constraints_test</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">opt_constraints_test</span><span class="o">+=</span><span class="n">opt_constraints</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">c_mat_add</span><span class="p">):</span> <span class="c1">#c_mat_add could be empty if b_vec has just one nonzero entry.</span>
      <span class="k">if</span> <span class="n">is_asymptotic</span><span class="p">:</span> <span class="c1"># if the test condition is asymptotic, c0_vec_add is considered 0.</span>
        <span class="n">opt_constraints_test</span><span class="o">+=</span><span class="p">[</span><span class="n">c_mat_add</span> <span class="o">@</span> <span class="n">opt_var</span> <span class="o">&gt;=</span> <span class="n">positive_threshold</span><span class="p">]</span>
      <span class="k">else</span><span class="p">:</span> <span class="c1"># if not asymptotic, it is exact, so c0_vec_add needs to be considered.</span>
        <span class="n">opt_constraints_test</span><span class="o">+=</span><span class="p">[</span><span class="n">c_mat_add</span> <span class="o">@</span> <span class="n">opt_var</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">c0_vec_add</span> <span class="o">&gt;=</span> <span class="n">positive_threshold</span><span class="p">]</span>
    <span class="n">is_feasible</span><span class="o">=</span><span class="n">vv</span><span class="o">.</span><span class="n">vertex_feasibility_test</span><span class="p">(</span><span class="n">chart</span><span class="o">=</span><span class="n">chart</span><span class="p">,</span><span class="n">opt_constraints</span><span class="o">=</span><span class="n">opt_constraints_test</span><span class="p">,</span><span class="n">is_asymptotic</span><span class="o">=</span><span class="n">is_asymptotic</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">is_feasible</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">calc_c_mat_add_x</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># Compute feasibility conditions of this dominance regime in addition </span>
    <span class="c1">#   to vertex feasibility conditions in the form of </span>
    <span class="c1">#   c_mat_add_x * logx + c0_vec_add &gt; 0, i.e. in chart x.</span>
    <span class="c1"># Each condition comes from and inequality of the form </span>
    <span class="c1">#   b_j1 x_j1 &gt; b_j2 x_j2, which can be written as </span>
    <span class="c1">#   log(x_j1) - log(x_j2) + [log(b_j1) - log(b_j2)] &gt; 0.</span>
    <span class="c1"># So the corresponding row of c_mat_add_x are all 0&#39;s except 1 at j1 </span>
    <span class="c1">#   and -1 at j2. And corresponding entry of c0_vec is log(b_j1) - log(b_j2).</span>
    <span class="n">j</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">row_idx</span>
    <span class="n">b_vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b_vec</span><span class="p">)</span>
    <span class="n">idx_nonzero_b</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">b_vec</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">n_ineq</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">idx_nonzero_b</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">c_mat_add_x</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_ineq</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">.</span><span class="n">dim_n</span><span class="p">))</span>
    <span class="n">c0_vec_add</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_ineq</span><span class="p">)</span>
    <span class="n">counter</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">for</span> <span class="n">jp</span> <span class="ow">in</span> <span class="n">idx_nonzero_b</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">jp</span><span class="o">!=</span><span class="n">j</span><span class="p">:</span>
        <span class="n">c_mat_add_x</span><span class="p">[</span><span class="n">counter</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
        <span class="n">c_mat_add_x</span><span class="p">[</span><span class="n">counter</span><span class="p">,</span><span class="n">jp</span><span class="p">]</span><span class="o">=-</span><span class="mi">1</span>
        <span class="n">c0_vec_add</span><span class="p">[</span><span class="n">counter</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">b_vec</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">b_vec</span><span class="p">[</span><span class="n">jp</span><span class="p">])</span>
        <span class="n">counter</span><span class="o">+=</span><span class="mi">1</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">c_mat_add_x</span><span class="o">=</span><span class="n">c_mat_add_x</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">c0_vec_add</span><span class="o">=</span><span class="n">c0_vec_add</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">calc_c_mat_add_xak</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># compute feasibility conditions of this dominance regime in addition to vertex feasibility conditions</span>
    <span class="c1"># in the form of c_mat_add_xak * log(xa,k) + c0_vec_add &gt; 0, i.e. in chart log(xa,k)</span>
    <span class="k">try</span><span class="p">:</span> <span class="n">c_mat_add_x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c_mat_add_x</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span> <span class="c1"># c_mat_add is not yet calculated</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">calc_c_mat_add_x</span><span class="p">()</span>
      <span class="n">c_mat_add_x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c_mat_add_x</span>
    <span class="k">try</span><span class="p">:</span> <span class="n">xak2x_map</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">.</span><span class="n">xak2x_map</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">.</span><span class="n">calc_xak2x_map</span><span class="p">()</span>
      <span class="n">xak2x_map</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">.</span><span class="n">xak2x_map</span>
    <span class="n">c_mat_add_xak</span><span class="o">=</span><span class="n">c_mat_add_x</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">xak2x_map</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">c_mat_add_xak</span><span class="o">=</span><span class="n">c_mat_add_xak</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">calc_c_mat_add_tk</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># compute feasibility conditions of this dominance regime in addition to vertex feasibility conditions</span>
    <span class="c1"># in the form of c_mat_add_tk * log(t,k) &gt; 0, i.e. in chart log(t,k)</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex</span><span class="o">.</span><span class="n">orientation</span><span class="o">!=</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;only finite vertices can have non-singular (t,k) chart&quot;</span>
    <span class="k">try</span><span class="p">:</span> <span class="n">c_mat_add_x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c_mat_add_x</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span> <span class="c1"># c_mat_add is not yet calculated</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">calc_c_mat_add_x</span><span class="p">()</span>
      <span class="n">c_mat_add_x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c_mat_add_x</span>
    <span class="c1"># The equivalence here is the following:</span>
    <span class="c1"># c_mat_tk @ log(t,k) + c0_vec_tk &gt;=0  &lt;=&gt;  c_mat_x @ logx + c0_vec &gt;=0</span>
    <span class="c1"># and we use h_mat*log(t,k)=log(x) at the vertex</span>
    <span class="n">c_mat_add_tk</span><span class="o">=</span><span class="n">c_mat_add_x</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex</span><span class="o">.</span><span class="n">h_mat</span><span class="p">)</span> 
    <span class="n">c0_vec_add_tk</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c0_vec_add</span> <span class="o">-</span> <span class="n">c_mat_add_x</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h_mat</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m0_vec</span><span class="p">))</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">c_mat_add_tk</span><span class="o">=</span><span class="n">c_mat_add_tk</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">c0_vec_tk</span><span class="o">=</span><span class="n">c0_vec_add_tk</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">find_neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">vv</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex</span>
    <span class="n">neighbors_fin</span><span class="o">=</span><span class="p">{}</span>
    <span class="n">neighbors_inf</span><span class="o">=</span><span class="p">{}</span>
    <span class="n">regime_fin_dict</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">.</span><span class="n">activity_regime_dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b_vec</span><span class="p">)][</span><span class="s1">&#39;finite&#39;</span><span class="p">]</span>
    <span class="n">regime_inf_dict</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">.</span><span class="n">activity_regime_dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b_vec</span><span class="p">)][</span><span class="s1">&#39;infinite&#39;</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">regime</span> <span class="ow">in</span> <span class="n">regime_fin_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
      <span class="n">perm</span><span class="p">,</span><span class="n">row_idx</span><span class="o">=</span><span class="n">key</span>
      <span class="c1"># if same vertex, but different dominance, then it&#39;s neighbor.</span>
      <span class="k">if</span> <span class="n">perm</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex_perm</span> <span class="ow">and</span> <span class="n">row_idx</span><span class="o">!=</span><span class="bp">self</span><span class="o">.</span><span class="n">row_idx</span><span class="p">:</span>
        <span class="n">neighbors_fin</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">regime</span>
      <span class="c1"># if different vertex, but it&#39;s a neighboring vertex, then it&#39;s neighbor.</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span> <span class="c1"># if perm is in neighbors</span>
          <span class="n">vv</span><span class="o">.</span><span class="n">neighbors_dict</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">][</span><span class="n">perm</span><span class="p">]</span>
          <span class="c1"># If the neighboring vertex&#39;s transition index (the row_idx that changed compared to self)</span>
          <span class="c1"># is the same as its dominance index, then it&#39;s a neighbor.</span>
          <span class="c1"># Or, if the transition index is not the same, then its dominance index needs to be the same as self.</span>
          <span class="k">if</span> <span class="n">row_idx</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">row_idx</span> <span class="ow">or</span> <span class="n">perm</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span><span class="o">!=</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex_perm</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span><span class="o">==</span><span class="n">row_idx</span><span class="p">:</span>
            <span class="n">neighbors_fin</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">regime</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span> <span class="c1"># not in neighbors</span>
          <span class="k">continue</span>


    <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">regime</span> <span class="ow">in</span> <span class="n">regime_inf_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
      <span class="n">perm</span><span class="p">,</span><span class="n">row_idx</span><span class="o">=</span><span class="n">key</span>
      <span class="c1"># if same vertex, but different dominance, then it&#39;s neighbor.</span>
      <span class="k">if</span> <span class="n">perm</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex_perm</span> <span class="ow">and</span> <span class="n">row_idx</span><span class="o">!=</span><span class="bp">self</span><span class="o">.</span><span class="n">row_idx</span><span class="p">:</span>
        <span class="n">neighbors_inf</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">regime</span>
      <span class="c1"># if different vertex, but it&#39;s a neighboring vertex, then it&#39;s neighbor.</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span> <span class="c1"># if perm is in neighbors</span>
          <span class="n">vv</span><span class="o">.</span><span class="n">neighbors_dict</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">][</span><span class="n">perm</span><span class="p">]</span>
          <span class="k">if</span> <span class="n">row_idx</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">row_idx</span> <span class="ow">or</span> <span class="n">perm</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span><span class="o">!=</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex_perm</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span><span class="o">==</span><span class="n">row_idx</span><span class="p">:</span>
            <span class="n">neighbors_inf</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">regime</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span> <span class="c1"># not in neighbors</span>
          <span class="k">continue</span>
    <span class="n">neighbors_all</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">neighbors_fin</span><span class="p">,</span><span class="o">**</span><span class="n">neighbors_inf</span><span class="p">}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">neighbors_dict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;finite&#39;</span><span class="p">:</span><span class="n">neighbors_fin</span><span class="p">,</span><span class="s1">&#39;infinite&#39;</span><span class="p">:</span><span class="n">neighbors_inf</span><span class="p">,</span><span class="s1">&#39;all&#39;</span><span class="p">:</span><span class="n">neighbors_all</span><span class="p">}</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">find_neighbors_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># Find neighbors that connect through dom_regimes with zero ld.</span>
    <span class="c1"># neighbors via zero are not considered neighbors of dom_regimes,</span>
    <span class="c1"># but we would like to keep them tracked, since they will become neighbors</span>
    <span class="c1"># in ld space.</span>
    <span class="c1"># This should be done after all neighbors of dom_regimes are constructed</span>
    <span class="c1"># since it relies on knowing the neighbors of dom_regime with ld=0.</span>
    <span class="c1"># A zero neighbor could have a zero neighbor, so recursion is needed to exhaust this.</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">extract_zero_neighbor</span><span class="p">(</span><span class="n">infinite_neighbors</span><span class="p">,</span> <span class="n">finite_zero_neighbors</span><span class="p">,</span> <span class="n">infinite_zero_neighbors</span><span class="p">,</span> <span class="n">ld_zero</span><span class="p">,</span> <span class="n">visited</span><span class="p">):</span>
      <span class="n">zero_neighbors</span> <span class="o">=</span> <span class="p">{</span>
          <span class="n">key</span><span class="p">:</span> <span class="n">dom_regime</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">dom_regime</span> <span class="ow">in</span> <span class="n">infinite_neighbors</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dom_regime</span><span class="o">.</span><span class="n">ld</span><span class="p">)</span> <span class="o">==</span> <span class="n">ld_zero</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="n">zero_neighbors</span><span class="p">:</span>  <span class="c1"># the dictionary is not empty</span>
          <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">dom_regime</span> <span class="ow">in</span> <span class="n">zero_neighbors</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
              <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                  <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                  <span class="n">finite_zero_neighbors</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dom_regime</span><span class="o">.</span><span class="n">neighbors_dict</span><span class="p">[</span><span class="s1">&#39;finite&#39;</span><span class="p">])</span>
                  <span class="n">infinite_zero_neighbors</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dom_regime</span><span class="o">.</span><span class="n">neighbors_dict</span><span class="p">[</span><span class="s1">&#39;infinite&#39;</span><span class="p">])</span>
                  <span class="n">finite_zero_neighbors</span><span class="p">,</span> <span class="n">infinite_zero_neighbors</span><span class="p">,</span> <span class="n">visited</span> <span class="o">=</span> <span class="n">extract_zero_neighbor</span><span class="p">(</span>
                      <span class="n">dom_regime</span><span class="o">.</span><span class="n">neighbors_dict</span><span class="p">[</span><span class="s1">&#39;infinite&#39;</span><span class="p">],</span>
                      <span class="n">finite_zero_neighbors</span><span class="p">,</span>
                      <span class="n">infinite_zero_neighbors</span><span class="p">,</span>
                      <span class="n">ld_zero</span><span class="p">,</span>
                      <span class="n">visited</span>
                  <span class="p">)</span>
      <span class="k">return</span> <span class="n">finite_zero_neighbors</span><span class="p">,</span> <span class="n">infinite_zero_neighbors</span><span class="p">,</span> <span class="n">visited</span>

    <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">.</span><span class="n">dim_n</span>
    <span class="n">ld_zero</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="n">finite_zero_neighbors</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">infinite_zero_neighbors</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="n">infinite_neighbors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighbors_dict</span><span class="p">[</span><span class="s1">&#39;infinite&#39;</span><span class="p">]</span>
    <span class="n">finite_zero_neighbors</span><span class="p">,</span> <span class="n">infinite_zero_neighbors</span><span class="p">,</span> <span class="n">visited</span> <span class="o">=</span> <span class="n">extract_zero_neighbor</span><span class="p">(</span>
        <span class="n">infinite_neighbors</span><span class="p">,</span> <span class="n">finite_zero_neighbors</span><span class="p">,</span> <span class="n">infinite_zero_neighbors</span><span class="p">,</span> <span class="n">ld_zero</span><span class="p">,</span> <span class="n">visited</span>
    <span class="p">)</span>

    <span class="c1"># Remove self from the neighbors&#39; dictionaries if present</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex</span><span class="o">.</span><span class="n">orientation</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">infinite_zero_neighbors</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex_perm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">row_idx</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">finite_zero_neighbors</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex_perm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">row_idx</span><span class="p">)]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="n">all_zero_neighbors</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">finite_zero_neighbors</span><span class="p">,</span> <span class="o">**</span><span class="n">infinite_zero_neighbors</span><span class="p">}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">neighbors_dict</span><span class="p">[</span><span class="s1">&#39;zero&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;finite&#39;</span><span class="p">:</span> <span class="n">finite_zero_neighbors</span><span class="p">,</span>
        <span class="s1">&#39;infinite&#39;</span><span class="p">:</span> <span class="n">infinite_zero_neighbors</span><span class="p">,</span>
        <span class="s1">&#39;all&#39;</span><span class="p">:</span> <span class="n">all_zero_neighbors</span>
    <span class="p">}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">neighbors_dict</span><span class="p">[</span><span class="s1">&#39;allnzero&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;finite&#39;</span><span class="p">:</span> <span class="p">{</span><span class="o">**</span><span class="n">finite_zero_neighbors</span><span class="p">,</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">neighbors_dict</span><span class="p">[</span><span class="s1">&#39;finite&#39;</span><span class="p">]},</span>
        <span class="s1">&#39;infinite&#39;</span><span class="p">:</span> <span class="p">{</span><span class="o">**</span><span class="n">infinite_zero_neighbors</span><span class="p">,</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">neighbors_dict</span><span class="p">[</span><span class="s1">&#39;infinite&#39;</span><span class="p">]},</span>
        <span class="s1">&#39;all&#39;</span><span class="p">:</span> <span class="p">{</span><span class="o">**</span><span class="n">all_zero_neighbors</span><span class="p">,</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">neighbors_dict</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">]}</span>
    <span class="p">}</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">update_constrained_neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># Using dom_regimes&#39; is_feasible tag to have updated neighbors.</span>
    <span class="c1"># The feasible neighbors of an infeasible neighbor becomes this vertex&#39;s neighbors.</span>
    <span class="c1"># We search the next level for the infeasible neighbors of an infeasible neighbor.</span>
    <span class="c1"># So this uses recursion.</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">extract_infeasible_neighbor</span><span class="p">(</span><span class="n">infeasible_neighbors</span><span class="p">,</span><span class="n">neighbors_feasible_all</span><span class="p">,</span><span class="n">visited</span><span class="p">):</span>
      <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">dom_regime</span> <span class="ow">in</span> <span class="n">infeasible_neighbors</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
          <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
              <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
              <span class="c1"># get the feasible and infeasible neighbors of this dom_regime</span>
              <span class="n">infeasible_neighbors</span> <span class="o">=</span> <span class="p">{}</span>
              <span class="n">feasible_neighbors</span><span class="o">=</span><span class="p">{}</span>
              <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">dom_regime</span> <span class="ow">in</span> <span class="n">dom_regime</span><span class="o">.</span><span class="n">neighbors_dict</span><span class="p">[</span><span class="s1">&#39;allnzero&#39;</span><span class="p">][</span><span class="s1">&#39;all&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">dom_regime</span><span class="o">.</span><span class="n">is_feasible</span><span class="p">:</span>
                  <span class="n">feasible_neighbors</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="n">dom_regime</span>
                <span class="k">else</span><span class="p">:</span>
                  <span class="n">infeasible_neighbors</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="n">dom_regime</span>
              <span class="c1"># the feasible ones are neighbors under constraint.</span>
              <span class="n">neighbors_feasible_all</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">feasible_neighbors</span><span class="p">)</span>
              <span class="c1"># the infeasible ones we need to look further</span>
              <span class="k">if</span> <span class="n">infeasible_neighbors</span><span class="p">:</span>
                <span class="n">neighbors_feasible_all</span><span class="p">,</span> <span class="n">visited</span> <span class="o">=</span> <span class="n">extract_infeasible_neighbor</span><span class="p">(</span>
                  <span class="n">infeasible_neighbors</span><span class="p">,</span>
                  <span class="n">neighbors_feasible_all</span><span class="p">,</span>
                  <span class="n">visited</span>
                <span class="p">)</span>
      <span class="k">return</span> <span class="n">neighbors_feasible_all</span><span class="p">,</span> <span class="n">visited</span>

    <span class="n">neighbors_feasible_all</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span><span class="n">dom_regime</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">dom_regime</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighbors_dict</span><span class="p">[</span><span class="s1">&#39;allnzero&#39;</span><span class="p">][</span><span class="s1">&#39;all&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">dom_regime</span><span class="o">.</span><span class="n">is_feasible</span><span class="p">}</span>
    <span class="n">infeasible_neighbors</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span><span class="n">dom_regime</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">dom_regime</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighbors_dict</span><span class="p">[</span><span class="s1">&#39;allnzero&#39;</span><span class="p">][</span><span class="s1">&#39;all&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">dom_regime</span><span class="o">.</span><span class="n">is_feasible</span><span class="p">}</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">infeasible_neighbors</span><span class="p">:</span>
      <span class="n">neighbors_feasible_all</span><span class="p">,</span><span class="n">visited</span> <span class="o">=</span> <span class="n">extract_infeasible_neighbor</span><span class="p">(</span>
        <span class="n">infeasible_neighbors</span><span class="p">,</span><span class="n">neighbors_feasible_all</span><span class="p">,</span><span class="n">visited</span>
      <span class="p">)</span>
    <span class="c1"># Remove self from the neighbors&#39; dictionaries if present</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">neighbors_feasible_all</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex_perm</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">row_idx</span><span class="p">)]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="n">neighbors_feasible_inf</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">key</span><span class="p">:</span><span class="n">dom_regime</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">dom_regime</span> <span class="ow">in</span> <span class="n">neighbors_feasible_all</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">dom_regime</span><span class="o">.</span><span class="n">vertex</span><span class="o">.</span><span class="n">orientation</span><span class="o">==</span><span class="mi">0</span>
        <span class="p">}</span>
    <span class="n">neighbors_feasible_fin</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">key</span><span class="p">:</span><span class="n">dom_regime</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">dom_regime</span> <span class="ow">in</span> <span class="n">neighbors_feasible_all</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">dom_regime</span><span class="o">.</span><span class="n">vertex</span><span class="o">.</span><span class="n">orientation</span><span class="o">!=</span><span class="mi">0</span>
        <span class="p">}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">neighbors_constrained_dict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;finite&#39;</span><span class="p">:</span><span class="n">neighbors_feasible_fin</span><span class="p">,</span>
                                  <span class="s1">&#39;infinite&#39;</span><span class="p">:</span><span class="n">neighbors_feasible_inf</span><span class="p">,</span>
                                  <span class="s1">&#39;all&#39;</span><span class="p">:</span><span class="n">neighbors_feasible_all</span><span class="p">}</span>

  <span class="c1"># def print_validity_condition(self,is_asymptotic=False):</span>
  <span class="c1">#   # print the expression for t=x, x(t,k) and inequalities for the</span>
  <span class="c1">#   # region of validity for this dominance regime,</span>
  <span class="c1">#   # using the labels of x,t,k</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">hull_sampling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">nsample</span><span class="p">,</span><span class="n">chart</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">logmin</span><span class="o">=-</span><span class="mi">6</span><span class="p">,</span><span class="n">logmax</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span><span class="n">c_mat_extra</span><span class="o">=</span><span class="p">[],</span><span class="n">c0_vec_extra</span><span class="o">=</span><span class="p">[]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sample points in the dom_regime&#39;s region of validity based on its hull of feasible regions.</span>
<span class="sd">    Extra conditions (linear) can be added as c_mat_extra @ var + c0_vec_extra &gt;= 0.</span>
<span class="sd">    This is done by adding dom_regime&#39;s additional constraints to its vertex&#39;s sampling function.</span>

<span class="sd">    Args:</span>
<span class="sd">        nsample (int): Number of points to be sampled.</span>
<span class="sd">        chart (str, optional): A string indicating the chart that the opt_constraints are specified in.</span>
<span class="sd">            Choices are &#39;x&#39;,&#39;xak&#39;, and &#39;tk&#39;.</span>
<span class="sd">        margin (float, optional): The dom_regime&#39;s feasibility conditions are inequalities, </span>
<span class="sd">            of the form c_mat*x + c0_vec &gt;= margin (e.g. in &#39;x&#39; chart),</span>
<span class="sd">            where margin is the margin used here. Defaults to 0.</span>
<span class="sd">            This can be adjusted to be stronger/weaker requirements on dominance.</span>
<span class="sd">        logmin (float or ndarray vector): logmin, logmax could be scalars, then it&#39;s the same value applied to </span>
<span class="sd">            every variable. </span>
<span class="sd">            They could also be vectors of length dim_n.</span>
<span class="sd">        logmax (float or ndarray vector): logmin, logmax could be scalars, then it&#39;s the same value applied to </span>
<span class="sd">            every variable. </span>
<span class="sd">            They could also be vectors of length dim_n.</span>
<span class="sd">        c_mat_extra (ndarray, shape (n_constraints, n_var)): Extra optimization constraints to be added to feasibility conditions,</span>
<span class="sd">            in the form of c_mat_extra @ var + c0_vec_extra &gt;= 0.</span>
<span class="sd">        c0_vec_extra (numpy vector, shape (n_constraints,)): Extra optimization constraints to be added to feasibility conditions,</span>
<span class="sd">            in the form of c_mat_extra @ var + c0_vec_extra &gt;=0.</span>

<span class="sd">    Returns:</span>
<span class="sd">        sample (ndarray of shape nsample-by-dim_n): dim_n is number of species in the binding network.</span>
<span class="sd">            Sampled points satisfying the feasibility conditions of this vertex.</span>
<span class="sd">            Each row (sample[i,:]) is a sampled point.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get the additional constraints for the dom_regime</span>
    <span class="n">c_mat_add</span><span class="p">,</span><span class="n">c0_vec_add</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">chart_check_add</span><span class="p">(</span><span class="n">chart</span><span class="o">=</span><span class="n">chart</span><span class="p">)</span>
    <span class="c1"># Combine dom_regime constraints with given additional constraints </span>
    <span class="c1">#   to get the full constraints to be added to vertex validity.</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">c_mat_extra</span><span class="p">):</span> <span class="c1"># if there are additional constraints</span>
      <span class="n">c_mat_extra_full</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">c_mat_add</span><span class="p">,</span><span class="n">c_mat_extra</span><span class="p">))</span>
      <span class="c1"># Incorporate margin into c0_vec_add, since this won&#39;t be added again later in the vertex.</span>
      <span class="n">c0_vec_extra_full</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">c0_vec_add</span><span class="o">-</span><span class="n">margin</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">c0_vec_add</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">c0_vec_extra</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1"># there are no additional constraints</span>
      <span class="n">c_mat_extra_full</span> <span class="o">=</span> <span class="n">c_mat_add</span>
      <span class="n">c0_vec_extra_full</span> <span class="o">=</span> <span class="n">c0_vec_add</span><span class="o">-</span><span class="n">margin</span>
    <span class="c1"># Get the hull using the vertex&#39;s method, but with additional</span>
    <span class="c1">#   constraints from the dom_regime.</span>
    <span class="n">points</span><span class="p">,</span><span class="n">hull</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">_</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex</span><span class="o">.</span><span class="n">vertex_hull_of_validity</span><span class="p">(</span><span class="n">chart</span><span class="o">=</span><span class="n">chart</span><span class="p">,</span><span class="n">margin</span><span class="o">=</span><span class="n">margin</span><span class="p">,</span><span class="n">logmin</span><span class="o">=</span><span class="n">logmin</span><span class="p">,</span><span class="n">logmax</span><span class="o">=</span><span class="n">logmax</span><span class="p">,</span><span class="n">c_mat_extra</span><span class="o">=</span><span class="n">c_mat_extra_full</span><span class="p">,</span><span class="n">c0_vec_extra</span><span class="o">=</span><span class="n">c0_vec_extra_full</span><span class="p">)</span>
    <span class="n">ncoeffs</span><span class="o">=</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">temp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">nsample</span><span class="p">,</span><span class="n">ncoeffs</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">coeffs</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span><span class="n">prepend</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">append</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">sample</span><span class="o">=</span><span class="n">coeffs</span><span class="nd">@points</span> <span class="c1"># this has shape nsample-by-dim_n</span>
    <span class="k">return</span> <span class="n">sample</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h3 id="bcn.binding_network.rop_dom_regime.__init__" class="doc doc-heading">
            <code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="n">row_idx</span><span class="p">,</span> <span class="n">b_vec</span><span class="p">,</span> <span class="n">vertex_perm</span><span class="p">,</span> <span class="n">bn</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Initiates a ROP vertex.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>row_idx</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The integer j indicating x_j is the dominant species in b^T x at this regime.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>b_vec</code>
            </td>
            <td>
                  <code>numpy array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The b vector defining the activity b^T x.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>vertex_perm</code>
            </td>
            <td>
                  <code>tuple of int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The tuple of length d (number of totals of binding network) referring to the dominance vertex that this dom_regime belongs to.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>bn</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="bcn.binding_network.binding_network" href="#bcn.binding_network.binding_network">binding_network</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The binding network that this dom_regime belongs to.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/bcn/binding_network.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">row_idx</span><span class="p">,</span><span class="n">b_vec</span><span class="p">,</span><span class="n">vertex_perm</span><span class="p">,</span><span class="n">bn</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Initiates a ROP vertex.</span>

<span class="sd">  Args:</span>
<span class="sd">      row_idx (int): The integer j indicating x_j is the dominant species in b^T x at this regime.</span>
<span class="sd">      b_vec (numpy array): The b vector defining the activity b^T x.</span>
<span class="sd">      vertex_perm (tuple of int): The tuple of length d (number of totals of binding network) referring to the dominance vertex that this dom_regime belongs to.</span>
<span class="sd">      bn (binding_network): The binding network that this dom_regime belongs to.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">row_idx</span><span class="o">=</span><span class="n">row_idx</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">b_vec</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">b_vec</span><span class="p">)</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">vertex_perm</span><span class="o">=</span><span class="n">vertex_perm</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">vertex</span><span class="o">=</span><span class="n">bn</span><span class="o">.</span><span class="n">vertex_dict</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">][</span><span class="n">vertex_perm</span><span class="p">]</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">=</span><span class="n">bn</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">ld</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex</span><span class="o">.</span><span class="n">h_mat</span><span class="p">[</span><span class="n">row_idx</span><span class="p">,:])</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">is_feasible</span><span class="o">=</span><span class="kc">True</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="bcn.binding_network.rop_dom_regime.hull_sampling" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">hull_sampling</span><span class="p">(</span><span class="n">nsample</span><span class="p">,</span> <span class="n">chart</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">logmin</span><span class="o">=-</span><span class="mi">6</span><span class="p">,</span> <span class="n">logmax</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">c_mat_extra</span><span class="o">=</span><span class="p">[],</span> <span class="n">c0_vec_extra</span><span class="o">=</span><span class="p">[])</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Sample points in the dom_regime's region of validity based on its hull of feasible regions.
Extra conditions (linear) can be added as c_mat_extra @ var + c0_vec_extra &gt;= 0.
This is done by adding dom_regime's additional constraints to its vertex's sampling function.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>nsample</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Number of points to be sampled.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>chart</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A string indicating the chart that the opt_constraints are specified in.
Choices are 'x','xak', and 'tk'.</p>
              </div>
            </td>
            <td>
                  <code>&#39;x&#39;</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>margin</code>
            </td>
            <td>
                  <code><span title="float">float</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The dom_regime's feasibility conditions are inequalities, 
of the form c_mat*x + c0_vec &gt;= margin (e.g. in 'x' chart),
where margin is the margin used here. Defaults to 0.
This can be adjusted to be stronger/weaker requirements on dominance.</p>
              </div>
            </td>
            <td>
                  <code>0</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>logmin</code>
            </td>
            <td>
                  <code>float or ndarray vector</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>logmin, logmax could be scalars, then it's the same value applied to 
every variable. 
They could also be vectors of length dim_n.</p>
              </div>
            </td>
            <td>
                  <code>-6</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>logmax</code>
            </td>
            <td>
                  <code>float or ndarray vector</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>logmin, logmax could be scalars, then it's the same value applied to 
every variable. 
They could also be vectors of length dim_n.</p>
              </div>
            </td>
            <td>
                  <code>6</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>c_mat_extra</code>
            </td>
            <td>
                  <code>ndarray, shape (n_constraints, n_var</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Extra optimization constraints to be added to feasibility conditions,
in the form of c_mat_extra @ var + c0_vec_extra &gt;= 0.</p>
              </div>
            </td>
            <td>
                  <code>[]</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>c0_vec_extra</code>
            </td>
            <td>
                  <code>numpy vector, shape (n_constraints,</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Extra optimization constraints to be added to feasibility conditions,
in the form of c_mat_extra @ var + c0_vec_extra &gt;=0.</p>
              </div>
            </td>
            <td>
                  <code>[]</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>sample</code></td>            <td>
                  <code>ndarray of shape nsample-by-dim_n</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>dim_n is number of species in the binding network.
Sampled points satisfying the feasibility conditions of this vertex.
Each row (sample[i,:]) is a sampled point.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/bcn/binding_network.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">hull_sampling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">nsample</span><span class="p">,</span><span class="n">chart</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">logmin</span><span class="o">=-</span><span class="mi">6</span><span class="p">,</span><span class="n">logmax</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span><span class="n">c_mat_extra</span><span class="o">=</span><span class="p">[],</span><span class="n">c0_vec_extra</span><span class="o">=</span><span class="p">[]):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Sample points in the dom_regime&#39;s region of validity based on its hull of feasible regions.</span>
<span class="sd">  Extra conditions (linear) can be added as c_mat_extra @ var + c0_vec_extra &gt;= 0.</span>
<span class="sd">  This is done by adding dom_regime&#39;s additional constraints to its vertex&#39;s sampling function.</span>

<span class="sd">  Args:</span>
<span class="sd">      nsample (int): Number of points to be sampled.</span>
<span class="sd">      chart (str, optional): A string indicating the chart that the opt_constraints are specified in.</span>
<span class="sd">          Choices are &#39;x&#39;,&#39;xak&#39;, and &#39;tk&#39;.</span>
<span class="sd">      margin (float, optional): The dom_regime&#39;s feasibility conditions are inequalities, </span>
<span class="sd">          of the form c_mat*x + c0_vec &gt;= margin (e.g. in &#39;x&#39; chart),</span>
<span class="sd">          where margin is the margin used here. Defaults to 0.</span>
<span class="sd">          This can be adjusted to be stronger/weaker requirements on dominance.</span>
<span class="sd">      logmin (float or ndarray vector): logmin, logmax could be scalars, then it&#39;s the same value applied to </span>
<span class="sd">          every variable. </span>
<span class="sd">          They could also be vectors of length dim_n.</span>
<span class="sd">      logmax (float or ndarray vector): logmin, logmax could be scalars, then it&#39;s the same value applied to </span>
<span class="sd">          every variable. </span>
<span class="sd">          They could also be vectors of length dim_n.</span>
<span class="sd">      c_mat_extra (ndarray, shape (n_constraints, n_var)): Extra optimization constraints to be added to feasibility conditions,</span>
<span class="sd">          in the form of c_mat_extra @ var + c0_vec_extra &gt;= 0.</span>
<span class="sd">      c0_vec_extra (numpy vector, shape (n_constraints,)): Extra optimization constraints to be added to feasibility conditions,</span>
<span class="sd">          in the form of c_mat_extra @ var + c0_vec_extra &gt;=0.</span>

<span class="sd">  Returns:</span>
<span class="sd">      sample (ndarray of shape nsample-by-dim_n): dim_n is number of species in the binding network.</span>
<span class="sd">          Sampled points satisfying the feasibility conditions of this vertex.</span>
<span class="sd">          Each row (sample[i,:]) is a sampled point.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="c1"># Get the additional constraints for the dom_regime</span>
  <span class="n">c_mat_add</span><span class="p">,</span><span class="n">c0_vec_add</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">chart_check_add</span><span class="p">(</span><span class="n">chart</span><span class="o">=</span><span class="n">chart</span><span class="p">)</span>
  <span class="c1"># Combine dom_regime constraints with given additional constraints </span>
  <span class="c1">#   to get the full constraints to be added to vertex validity.</span>
  <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">c_mat_extra</span><span class="p">):</span> <span class="c1"># if there are additional constraints</span>
    <span class="n">c_mat_extra_full</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">c_mat_add</span><span class="p">,</span><span class="n">c_mat_extra</span><span class="p">))</span>
    <span class="c1"># Incorporate margin into c0_vec_add, since this won&#39;t be added again later in the vertex.</span>
    <span class="n">c0_vec_extra_full</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">c0_vec_add</span><span class="o">-</span><span class="n">margin</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">c0_vec_add</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">c0_vec_extra</span><span class="p">))</span>
  <span class="k">else</span><span class="p">:</span> <span class="c1"># there are no additional constraints</span>
    <span class="n">c_mat_extra_full</span> <span class="o">=</span> <span class="n">c_mat_add</span>
    <span class="n">c0_vec_extra_full</span> <span class="o">=</span> <span class="n">c0_vec_add</span><span class="o">-</span><span class="n">margin</span>
  <span class="c1"># Get the hull using the vertex&#39;s method, but with additional</span>
  <span class="c1">#   constraints from the dom_regime.</span>
  <span class="n">points</span><span class="p">,</span><span class="n">hull</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">_</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex</span><span class="o">.</span><span class="n">vertex_hull_of_validity</span><span class="p">(</span><span class="n">chart</span><span class="o">=</span><span class="n">chart</span><span class="p">,</span><span class="n">margin</span><span class="o">=</span><span class="n">margin</span><span class="p">,</span><span class="n">logmin</span><span class="o">=</span><span class="n">logmin</span><span class="p">,</span><span class="n">logmax</span><span class="o">=</span><span class="n">logmax</span><span class="p">,</span><span class="n">c_mat_extra</span><span class="o">=</span><span class="n">c_mat_extra_full</span><span class="p">,</span><span class="n">c0_vec_extra</span><span class="o">=</span><span class="n">c0_vec_extra_full</span><span class="p">)</span>
  <span class="n">ncoeffs</span><span class="o">=</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">temp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">nsample</span><span class="p">,</span><span class="n">ncoeffs</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">coeffs</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span><span class="n">prepend</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">append</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">sample</span><span class="o">=</span><span class="n">coeffs</span><span class="nd">@points</span> <span class="c1"># this has shape nsample-by-dim_n</span>
  <span class="k">return</span> <span class="n">sample</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="bcn.binding_network.rop_ld_regime" class="doc doc-heading">
            <code>rop_ld_regime</code>


</h2>


    <div class="doc doc-contents ">


        <p>The ld_regime object, for a given ld (log derivative or reaction order), there could be multiple dominance regimes (defined by dominance relations in x for a given catalytic activity on top of a binding network).
  Each ld_regime has possibly several dominance regimes with the same ld.</p>
<p>Args:
      ld (tuple of integers): The log derivative, or reaction order, of this ld_regime.
      b_vec (numpy array vector): The b vector defining the activity, b^T x.
      bn (binding_network object): The binding network that this ld_regime belongs to.
      is_ray (boolean): Whether this ld_regime is a ray or not.
      dom_regime_keys (list of tuples): The list of tuples, each tuple is the key for a dominance regime that has reaction order (ld) the same as this ld_regime.
      dom_regime_dict (dictionary): The dictionary with key as the tuple (perm, dom_idx) representing a dominance regime and value of the dominance regime object.
      neighbors_dict (dictionary): The dictionary for ld_regime neighbors of this ld_regime.
          Has four keys, three of them are "finite", "infinite", and "all",
          for finite, infinite (ray) ld_regime neighbors, and all of ld_regime neighbors, respectively.
          For each of these keys, we get a dictionary as well, with ld tuple as key and the ld_regime object as value.
          The last key is "zero", which maps to neighbors connected via ld_regimes that are zero rays. The value is itself a dictionary with "finite", "infinite", and "all" mapping to dictionaries with (ld: ld_regime) entries.
      is_feasible (boolean): Whether this ld_regime is feasible. It is feasible if it has at least one dom_regime that is feasible.
      neighbors_constrained_dict (dictionary): The dictionary for ld_regime neighbors of this ld_regime that are feasible under constraints applied to each dom_regime.</p>






              <details class="quote">
                <summary>Source code in <code>src/bcn/binding_network.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span>
<span class="normal">77</span>
<span class="normal">78</span>
<span class="normal">79</span>
<span class="normal">80</span>
<span class="normal">81</span>
<span class="normal">82</span>
<span class="normal">83</span>
<span class="normal">84</span>
<span class="normal">85</span>
<span class="normal">86</span>
<span class="normal">87</span>
<span class="normal">88</span>
<span class="normal">89</span>
<span class="normal">90</span>
<span class="normal">91</span>
<span class="normal">92</span>
<span class="normal">93</span>
<span class="normal">94</span>
<span class="normal">95</span>
<span class="normal">96</span>
<span class="normal">97</span>
<span class="normal">98</span>
<span class="normal">99</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">rop_ld_regime</span><span class="p">:</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  The ld_regime object, for a given ld (log derivative or reaction order), there could be multiple dominance regimes (defined by dominance relations in x for a given catalytic activity on top of a binding network).</span>
<span class="sd">    Each ld_regime has possibly several dominance regimes with the same ld.</span>

<span class="sd">    Args:</span>
<span class="sd">        ld (tuple of integers): The log derivative, or reaction order, of this ld_regime.</span>
<span class="sd">        b_vec (numpy array vector): The b vector defining the activity, b^T x.</span>
<span class="sd">        bn (binding_network object): The binding network that this ld_regime belongs to.</span>
<span class="sd">        is_ray (boolean): Whether this ld_regime is a ray or not.</span>
<span class="sd">        dom_regime_keys (list of tuples): The list of tuples, each tuple is the key for a dominance regime that has reaction order (ld) the same as this ld_regime.</span>
<span class="sd">        dom_regime_dict (dictionary): The dictionary with key as the tuple (perm, dom_idx) representing a dominance regime and value of the dominance regime object.</span>
<span class="sd">        neighbors_dict (dictionary): The dictionary for ld_regime neighbors of this ld_regime.</span>
<span class="sd">            Has four keys, three of them are &quot;finite&quot;, &quot;infinite&quot;, and &quot;all&quot;,</span>
<span class="sd">            for finite, infinite (ray) ld_regime neighbors, and all of ld_regime neighbors, respectively.</span>
<span class="sd">            For each of these keys, we get a dictionary as well, with ld tuple as key and the ld_regime object as value.</span>
<span class="sd">            The last key is &quot;zero&quot;, which maps to neighbors connected via ld_regimes that are zero rays. The value is itself a dictionary with &quot;finite&quot;, &quot;infinite&quot;, and &quot;all&quot; mapping to dictionaries with (ld: ld_regime) entries.</span>
<span class="sd">        is_feasible (boolean): Whether this ld_regime is feasible. It is feasible if it has at least one dom_regime that is feasible.</span>
<span class="sd">        neighbors_constrained_dict (dictionary): The dictionary for ld_regime neighbors of this ld_regime that are feasible under constraints applied to each dom_regime.</span>
<span class="sd">    &quot;&quot;&quot;</span>
  <span class="c1"># b_vec defines an activity, yielding possibly multiple regimes for each vertex,</span>
  <span class="c1"># with logder corresponding to different rows of the vertex logder matrix.</span>
  <span class="c1"># ld_regime focus on logder, collapsing the same logder to be the same ld_regime,</span>
  <span class="c1"># which may come from different vertices.</span>
  <span class="c1"># Each ld_regime has multiple dom_regimes and regions of feasibility.</span>
  <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ld</span><span class="p">,</span><span class="n">is_ray</span><span class="p">,</span><span class="n">b_vec</span><span class="p">,</span><span class="n">dom_regime_keys</span><span class="p">,</span><span class="n">bn</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        ld (tuple of integers): The log derivative, or reaction order, of this ld_regime.</span>
<span class="sd">        is_ray (bool): Whether this ld_regime is a ray or not.</span>
<span class="sd">        b_vec (numpy array): The b vector defining the activity, b^T x.</span>
<span class="sd">        dom_regime_keys (list of tuples): The list of tuples, each tuple is the key for a dominance regime that has reaction order (ld) the same as this ld_regime.</span>
<span class="sd">        bn (binding_network): The binding network that this ld_regime belongs to.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ld</span><span class="o">=</span><span class="n">ld</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">b_vec</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">b_vec</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">=</span><span class="n">bn</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">is_ray</span><span class="o">=</span><span class="n">is_ray</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dom_regime_keys</span><span class="o">=</span><span class="n">dom_regime_keys</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dom_regime_dict</span><span class="o">=</span><span class="p">{</span><span class="n">key</span><span class="p">:</span><span class="n">bn</span><span class="o">.</span><span class="n">activity_regime_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">b_vec</span><span class="p">][</span><span class="s1">&#39;all&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dom_regime_keys</span><span class="p">}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">is_feasible</span><span class="o">=</span><span class="kc">True</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">find_neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># Construct self.neighbors_dict based on dominance regimes&#39; neighbors,</span>
    <span class="c1"># then construct neighbors_constrained_dict.</span>
    <span class="n">neighbors_fin</span><span class="o">=</span><span class="p">{};</span><span class="n">neighbors_inf</span><span class="o">=</span><span class="p">{};</span><span class="n">neighbors_fin_zero</span><span class="o">=</span><span class="p">{};</span><span class="n">neighbors_inf_zero</span><span class="o">=</span><span class="p">{}</span>
    <span class="c1"># Instead of iterating through all ld_regimes, we just look at this ld_regime&#39;s</span>
    <span class="c1"># dom_regimes and their corresponding ld_regimes as neighbors.</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">dom_regime</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dom_regime_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
      <span class="k">for</span> <span class="n">nb_key</span><span class="p">,</span><span class="n">nb_regime</span> <span class="ow">in</span> <span class="n">dom_regime</span><span class="o">.</span><span class="n">neighbors_dict</span><span class="p">[</span><span class="s1">&#39;finite&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">neighbors_fin</span><span class="p">[</span><span class="n">nb_regime</span><span class="o">.</span><span class="n">ld</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">.</span><span class="n">activity_ld_regime_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">b_vec</span><span class="p">][</span><span class="s1">&#39;finite&#39;</span><span class="p">][</span><span class="n">nb_regime</span><span class="o">.</span><span class="n">ld</span><span class="p">]</span>
      <span class="k">for</span> <span class="n">nb_key</span><span class="p">,</span><span class="n">nb_regime</span> <span class="ow">in</span> <span class="n">dom_regime</span><span class="o">.</span><span class="n">neighbors_dict</span><span class="p">[</span><span class="s1">&#39;infinite&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">neighbors_inf</span><span class="p">[</span><span class="n">nb_regime</span><span class="o">.</span><span class="n">ld</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">.</span><span class="n">activity_ld_regime_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">b_vec</span><span class="p">][</span><span class="s1">&#39;infinite&#39;</span><span class="p">][</span><span class="n">nb_regime</span><span class="o">.</span><span class="n">ld</span><span class="p">]</span>
      <span class="k">for</span> <span class="n">nb_key</span><span class="p">,</span><span class="n">nb_regime</span> <span class="ow">in</span> <span class="n">dom_regime</span><span class="o">.</span><span class="n">neighbors_dict</span><span class="p">[</span><span class="s1">&#39;zero&#39;</span><span class="p">][</span><span class="s1">&#39;finite&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">neighbors_fin_zero</span><span class="p">[</span><span class="n">nb_regime</span><span class="o">.</span><span class="n">ld</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">.</span><span class="n">activity_ld_regime_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">b_vec</span><span class="p">][</span><span class="s1">&#39;finite&#39;</span><span class="p">][</span><span class="n">nb_regime</span><span class="o">.</span><span class="n">ld</span><span class="p">]</span>
      <span class="k">for</span> <span class="n">nb_key</span><span class="p">,</span><span class="n">nb_regime</span> <span class="ow">in</span> <span class="n">dom_regime</span><span class="o">.</span><span class="n">neighbors_dict</span><span class="p">[</span><span class="s1">&#39;zero&#39;</span><span class="p">][</span><span class="s1">&#39;infinite&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">neighbors_inf_zero</span><span class="p">[</span><span class="n">nb_regime</span><span class="o">.</span><span class="n">ld</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">.</span><span class="n">activity_ld_regime_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">b_vec</span><span class="p">][</span><span class="s1">&#39;infinite&#39;</span><span class="p">][</span><span class="n">nb_regime</span><span class="o">.</span><span class="n">ld</span><span class="p">]</span>
    <span class="n">neighbors_all</span><span class="o">=</span><span class="p">{</span><span class="o">**</span><span class="n">neighbors_fin</span><span class="p">,</span><span class="o">**</span><span class="n">neighbors_inf</span><span class="p">}</span>
    <span class="n">neighbors_all_zero</span><span class="o">=</span><span class="p">{</span><span class="o">**</span><span class="n">neighbors_fin_zero</span><span class="p">,</span><span class="o">**</span><span class="n">neighbors_inf_zero</span><span class="p">}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">neighbors_dict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;all&#39;</span><span class="p">:</span><span class="n">neighbors_all</span><span class="p">,</span><span class="s1">&#39;finite&#39;</span><span class="p">:</span><span class="n">neighbors_fin</span><span class="p">,</span><span class="s1">&#39;infinite&#39;</span><span class="p">:</span><span class="n">neighbors_inf</span><span class="p">,</span>
                         <span class="s1">&#39;zero&#39;</span><span class="p">:{</span><span class="s1">&#39;all&#39;</span><span class="p">:</span><span class="n">neighbors_all_zero</span><span class="p">,</span><span class="s1">&#39;finite&#39;</span><span class="p">:</span><span class="n">neighbors_fin_zero</span><span class="p">,</span><span class="s1">&#39;infinite&#39;</span><span class="p">:</span><span class="n">neighbors_inf_zero</span><span class="p">}}</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">update_feasibility</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># Construct self.dom_regime_constrained_dict using dom_regime&#39;s is_feasible tag.</span>
    <span class="c1"># Then update self.is_feasible tag, True if self.dom_regime_constrained_dict is not empty,</span>
    <span class="c1"># since this means there are some dom_regimes satisfying the constraints.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dom_regime_constrained_dict</span><span class="o">=</span><span class="p">{</span><span class="n">key</span><span class="p">:</span><span class="n">regime</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">regime</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dom_regime_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">regime</span><span class="o">.</span><span class="n">is_feasible</span><span class="p">}</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dom_regime_constrained_dict</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_feasible</span><span class="o">=</span><span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_feasible</span><span class="o">=</span><span class="kc">False</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">update_constrained_neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># Construct self.neighbors_constrained_dict based on dominance regimes&#39; neighbors_constrained_dict.</span>
    <span class="c1"># This does not distinguish neighbors via zero or not.</span>

    <span class="n">neighbors_constrained_fin</span><span class="o">=</span><span class="p">{}</span>
    <span class="n">neighbors_constrained_inf</span><span class="o">=</span><span class="p">{}</span>
    <span class="c1"># Instead of iterating through all ld_regimes, we just look at this ld_regime&#39;s</span>
    <span class="c1"># dom_regimes and their corresponding ld_regimes as neighbors.</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">dom_regime</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dom_regime_constrained_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
      <span class="k">for</span> <span class="n">nb_key</span><span class="p">,</span><span class="n">nb_regime</span> <span class="ow">in</span> <span class="n">dom_regime</span><span class="o">.</span><span class="n">neighbors_constrained_dict</span><span class="p">[</span><span class="s1">&#39;finite&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">neighbors_constrained_fin</span><span class="p">[</span><span class="n">nb_regime</span><span class="o">.</span><span class="n">ld</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">.</span><span class="n">activity_ld_regime_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">b_vec</span><span class="p">][</span><span class="s1">&#39;finite&#39;</span><span class="p">][</span><span class="n">nb_regime</span><span class="o">.</span><span class="n">ld</span><span class="p">]</span>
      <span class="k">for</span> <span class="n">nb_key</span><span class="p">,</span><span class="n">nb_regime</span> <span class="ow">in</span> <span class="n">dom_regime</span><span class="o">.</span><span class="n">neighbors_constrained_dict</span><span class="p">[</span><span class="s1">&#39;infinite&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">neighbors_constrained_inf</span><span class="p">[</span><span class="n">nb_regime</span><span class="o">.</span><span class="n">ld</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">.</span><span class="n">activity_ld_regime_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">b_vec</span><span class="p">][</span><span class="s1">&#39;infinite&#39;</span><span class="p">][</span><span class="n">nb_regime</span><span class="o">.</span><span class="n">ld</span><span class="p">]</span>
    <span class="n">neighbors_constrained_all</span><span class="o">=</span><span class="p">{</span><span class="o">**</span><span class="n">neighbors_constrained_fin</span><span class="p">,</span><span class="o">**</span><span class="n">neighbors_constrained_inf</span><span class="p">}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">neighbors_constrained_dict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;all&#39;</span><span class="p">:</span><span class="n">neighbors_constrained_all</span><span class="p">,</span>
                                     <span class="s1">&#39;finite&#39;</span><span class="p">:</span><span class="n">neighbors_constrained_fin</span><span class="p">,</span>
                                     <span class="s1">&#39;infinite&#39;</span><span class="p">:</span><span class="n">neighbors_constrained_inf</span><span class="p">}</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h3 id="bcn.binding_network.rop_ld_regime.__init__" class="doc doc-heading">
            <code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="n">ld</span><span class="p">,</span> <span class="n">is_ray</span><span class="p">,</span> <span class="n">b_vec</span><span class="p">,</span> <span class="n">dom_regime_keys</span><span class="p">,</span> <span class="n">bn</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">



<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>ld</code>
            </td>
            <td>
                  <code>tuple of integers</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The log derivative, or reaction order, of this ld_regime.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>is_ray</code>
            </td>
            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether this ld_regime is a ray or not.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>b_vec</code>
            </td>
            <td>
                  <code>numpy array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The b vector defining the activity, b^T x.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>dom_regime_keys</code>
            </td>
            <td>
                  <code>list of tuples</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The list of tuples, each tuple is the key for a dominance regime that has reaction order (ld) the same as this ld_regime.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>bn</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="bcn.binding_network.binding_network" href="#bcn.binding_network.binding_network">binding_network</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The binding network that this ld_regime belongs to.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/bcn/binding_network.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ld</span><span class="p">,</span><span class="n">is_ray</span><span class="p">,</span><span class="n">b_vec</span><span class="p">,</span><span class="n">dom_regime_keys</span><span class="p">,</span><span class="n">bn</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Args:</span>
<span class="sd">      ld (tuple of integers): The log derivative, or reaction order, of this ld_regime.</span>
<span class="sd">      is_ray (bool): Whether this ld_regime is a ray or not.</span>
<span class="sd">      b_vec (numpy array): The b vector defining the activity, b^T x.</span>
<span class="sd">      dom_regime_keys (list of tuples): The list of tuples, each tuple is the key for a dominance regime that has reaction order (ld) the same as this ld_regime.</span>
<span class="sd">      bn (binding_network): The binding network that this ld_regime belongs to.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">ld</span><span class="o">=</span><span class="n">ld</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">b_vec</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">b_vec</span><span class="p">)</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">=</span><span class="n">bn</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">is_ray</span><span class="o">=</span><span class="n">is_ray</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">dom_regime_keys</span><span class="o">=</span><span class="n">dom_regime_keys</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">dom_regime_dict</span><span class="o">=</span><span class="p">{</span><span class="n">key</span><span class="p">:</span><span class="n">bn</span><span class="o">.</span><span class="n">activity_regime_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">b_vec</span><span class="p">][</span><span class="s1">&#39;all&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dom_regime_keys</span><span class="p">}</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">is_feasible</span><span class="o">=</span><span class="kc">True</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="bcn.binding_network.rop_vertex" class="doc doc-heading">
            <code>rop_vertex</code>


</h2>


    <div class="doc doc-contents ">


        <p>A vertex object for reaction order polyhedra.
Each binding network has multiple vertices.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>perm</code>
            </td>
            <td>
                  <code>int tuple</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>An integer tuple of length dim_d, indicating for each conserved quantity, 
which species is dominant.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>bn</code>
            </td>
            <td>
                  <code>binding_network object</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The binding network that this vertex belongs to.
Has l_mat (conservation law matrix) and n_mat (stoichiometry matrix).</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>p_mat</code>
            </td>
            <td>
                  <code>numpy array, d-by-n</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>d x n matrix with exactly one nonzero entry in each row, 
of value 1. One-hot representation of perm.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>p0_vec</code>
            </td>
            <td>
                  <code>numpy array, d-by-1</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Vector used in (logt, logk) = [p_mat n_mat]' logx + [p0_vec 0]'. 
Intercept relating log x to (logt, logk).
n_mat is that of the binding network.
p0_vec is all zeros if all entries of bn's l_mat are 0 and 1's.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>m_mat</code>
            </td>
            <td>
                  <code>numpy array, n-by-n</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Matrix formed by p_mat and n_mat stacked vertically. 
In other words, m_mat = [p_mat n_mat]'.
n_mat is that of the binding network.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>m0_vec</code>
            </td>
            <td>
                  <code>numpy array, n-by-1</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Vector used in (logt, logk) = m_mat logx + m0_vec.
m0_vec is the same as [p0_vec 0]', i.e., p0_vec vertically extended with r more zeros.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>orientation</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Take value in +1, 0, -1. Sign of determinant of [A' N'] matrix.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>h_mat</code>
            </td>
            <td>
                  <code>numpy array, n-by-n</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>n x n matrix corresponding to the log derivative of this vertex.
If finite (non-singular), then this is the log derivative.
If infinite (singular), then this is the direction that log derivative goes into.
At this vertex, we have relation logx = h_mat (logt, logk) + h0_vec.
Not always defined, computed and stored once log derivative is 
computed by calling self.vertex_ld_calc().</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>h0_vec</code>
            </td>
            <td>
                  <code>numpy array, n-by-1</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The intercept vector used in the following relation at this vertex:
logx = h_mat (logt, logk) + h0_vec.
Only defined for finite (non-singular) vertices.
Not always defined, computed and stored once log derivative is 
computed by calling self.vertex_ld_calc().</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>c_mat_x</code>
            </td>
            <td>
                  <code>numpy array, shape (n_constraints, n_var</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Matrix encoding feasibility condition of this vertex
in 'x' chart, c_mat_x * logx + c0_vec &gt; 0.
If the feasibility condition is considered "asymptotic", i.e., in positive
projective measure rather than Lebesgue measure (so a ray is an infinitesimal
of volume, not a point), then c0_vec is dropped.
Not always defined, computed and stored when used in feasibility tests.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>c_mat_xak</code>
            </td>
            <td>
                  <code>numpy array, shape (n_constraints, n_var</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Matrix encoding feasibility condition of this vertex
in 'xak' chart, c_mat_xak * (logxa, logk) + c0_vec &gt; 0.
If the feasibility condition is considered "asymptotic", i.e., in positive
projective measure rather than Lebesgue measure (so a ray is an infinitesimal
of volume, not a point), then c0_vec is dropped.
Not always defined, computed and stored when used in feasibility tests.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>c0_vec</code>
            </td>
            <td>
                  <code>numpy vector, shape (n_constraints,</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Numpy vector encoding a part of the feasibility condition of this vertex,
same for 'x' chart and 'xak' chart.
Not always defined, computed and stored when used in feasibility tests.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>c_mat_tk</code>
            </td>
            <td>
                  <code>numpy array, shape (n_constraints, n_var</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Matrix encoding feasibility condition of this vertex
in 'tk' chart, c_mat_tk * (logt, logk) + c0_vec_tk &gt; 0.
If the feasibility condition is considered "asymptotic", i.e., in positive
projective measure rather than Lebesgue measure (so a ray is an infinitesimal
of volume, not a point), then c0_vec_tk is dropped.
Only defined for finite (non-singular) vertices.
Not always defined, computed and stored when used in feasibility tests.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>c0_vec_tk</code>
            </td>
            <td>
                  <code>numpy vector, shape (n_constraints,</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Numpy vector encoding a part of the feasibility condition of this vertex
in the 'tk' chart.
Only defined for finite (non-singular) vertices.
Not always defined, computed and stored when used in feasibility tests.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>neighbors_dict</code>
            </td>
            <td>
                  <code><span title="dict">dict</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The dictionary for dom_regime neighbors of this dom_regime.
Has four keys: "finite", "infinite", "all", and "zero".
- "finite", "infinite", and "all" map to dictionaries with (perm, row_idx) tuple as keys 
  and the dom_regime object as values.
- "zero" maps to neighbors connected via dom_regimes that are zero rays in reaction orders 
  (or log derivative).</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>neighbors_constrained_dict</code>
            </td>
            <td>
                  <code><span title="dict">dict</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The dictionary for ld_regime neighbors of this ld_regime that are feasible
under constraints applied to each dom_regime. 
Same keys as neighbors_dict.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>






              <details class="quote">
                <summary>Source code in <code>src/bcn/binding_network.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 456</span>
<span class="normal"> 457</span>
<span class="normal"> 458</span>
<span class="normal"> 459</span>
<span class="normal"> 460</span>
<span class="normal"> 461</span>
<span class="normal"> 462</span>
<span class="normal"> 463</span>
<span class="normal"> 464</span>
<span class="normal"> 465</span>
<span class="normal"> 466</span>
<span class="normal"> 467</span>
<span class="normal"> 468</span>
<span class="normal"> 469</span>
<span class="normal"> 470</span>
<span class="normal"> 471</span>
<span class="normal"> 472</span>
<span class="normal"> 473</span>
<span class="normal"> 474</span>
<span class="normal"> 475</span>
<span class="normal"> 476</span>
<span class="normal"> 477</span>
<span class="normal"> 478</span>
<span class="normal"> 479</span>
<span class="normal"> 480</span>
<span class="normal"> 481</span>
<span class="normal"> 482</span>
<span class="normal"> 483</span>
<span class="normal"> 484</span>
<span class="normal"> 485</span>
<span class="normal"> 486</span>
<span class="normal"> 487</span>
<span class="normal"> 488</span>
<span class="normal"> 489</span>
<span class="normal"> 490</span>
<span class="normal"> 491</span>
<span class="normal"> 492</span>
<span class="normal"> 493</span>
<span class="normal"> 494</span>
<span class="normal"> 495</span>
<span class="normal"> 496</span>
<span class="normal"> 497</span>
<span class="normal"> 498</span>
<span class="normal"> 499</span>
<span class="normal"> 500</span>
<span class="normal"> 501</span>
<span class="normal"> 502</span>
<span class="normal"> 503</span>
<span class="normal"> 504</span>
<span class="normal"> 505</span>
<span class="normal"> 506</span>
<span class="normal"> 507</span>
<span class="normal"> 508</span>
<span class="normal"> 509</span>
<span class="normal"> 510</span>
<span class="normal"> 511</span>
<span class="normal"> 512</span>
<span class="normal"> 513</span>
<span class="normal"> 514</span>
<span class="normal"> 515</span>
<span class="normal"> 516</span>
<span class="normal"> 517</span>
<span class="normal"> 518</span>
<span class="normal"> 519</span>
<span class="normal"> 520</span>
<span class="normal"> 521</span>
<span class="normal"> 522</span>
<span class="normal"> 523</span>
<span class="normal"> 524</span>
<span class="normal"> 525</span>
<span class="normal"> 526</span>
<span class="normal"> 527</span>
<span class="normal"> 528</span>
<span class="normal"> 529</span>
<span class="normal"> 530</span>
<span class="normal"> 531</span>
<span class="normal"> 532</span>
<span class="normal"> 533</span>
<span class="normal"> 534</span>
<span class="normal"> 535</span>
<span class="normal"> 536</span>
<span class="normal"> 537</span>
<span class="normal"> 538</span>
<span class="normal"> 539</span>
<span class="normal"> 540</span>
<span class="normal"> 541</span>
<span class="normal"> 542</span>
<span class="normal"> 543</span>
<span class="normal"> 544</span>
<span class="normal"> 545</span>
<span class="normal"> 546</span>
<span class="normal"> 547</span>
<span class="normal"> 548</span>
<span class="normal"> 549</span>
<span class="normal"> 550</span>
<span class="normal"> 551</span>
<span class="normal"> 552</span>
<span class="normal"> 553</span>
<span class="normal"> 554</span>
<span class="normal"> 555</span>
<span class="normal"> 556</span>
<span class="normal"> 557</span>
<span class="normal"> 558</span>
<span class="normal"> 559</span>
<span class="normal"> 560</span>
<span class="normal"> 561</span>
<span class="normal"> 562</span>
<span class="normal"> 563</span>
<span class="normal"> 564</span>
<span class="normal"> 565</span>
<span class="normal"> 566</span>
<span class="normal"> 567</span>
<span class="normal"> 568</span>
<span class="normal"> 569</span>
<span class="normal"> 570</span>
<span class="normal"> 571</span>
<span class="normal"> 572</span>
<span class="normal"> 573</span>
<span class="normal"> 574</span>
<span class="normal"> 575</span>
<span class="normal"> 576</span>
<span class="normal"> 577</span>
<span class="normal"> 578</span>
<span class="normal"> 579</span>
<span class="normal"> 580</span>
<span class="normal"> 581</span>
<span class="normal"> 582</span>
<span class="normal"> 583</span>
<span class="normal"> 584</span>
<span class="normal"> 585</span>
<span class="normal"> 586</span>
<span class="normal"> 587</span>
<span class="normal"> 588</span>
<span class="normal"> 589</span>
<span class="normal"> 590</span>
<span class="normal"> 591</span>
<span class="normal"> 592</span>
<span class="normal"> 593</span>
<span class="normal"> 594</span>
<span class="normal"> 595</span>
<span class="normal"> 596</span>
<span class="normal"> 597</span>
<span class="normal"> 598</span>
<span class="normal"> 599</span>
<span class="normal"> 600</span>
<span class="normal"> 601</span>
<span class="normal"> 602</span>
<span class="normal"> 603</span>
<span class="normal"> 604</span>
<span class="normal"> 605</span>
<span class="normal"> 606</span>
<span class="normal"> 607</span>
<span class="normal"> 608</span>
<span class="normal"> 609</span>
<span class="normal"> 610</span>
<span class="normal"> 611</span>
<span class="normal"> 612</span>
<span class="normal"> 613</span>
<span class="normal"> 614</span>
<span class="normal"> 615</span>
<span class="normal"> 616</span>
<span class="normal"> 617</span>
<span class="normal"> 618</span>
<span class="normal"> 619</span>
<span class="normal"> 620</span>
<span class="normal"> 621</span>
<span class="normal"> 622</span>
<span class="normal"> 623</span>
<span class="normal"> 624</span>
<span class="normal"> 625</span>
<span class="normal"> 626</span>
<span class="normal"> 627</span>
<span class="normal"> 628</span>
<span class="normal"> 629</span>
<span class="normal"> 630</span>
<span class="normal"> 631</span>
<span class="normal"> 632</span>
<span class="normal"> 633</span>
<span class="normal"> 634</span>
<span class="normal"> 635</span>
<span class="normal"> 636</span>
<span class="normal"> 637</span>
<span class="normal"> 638</span>
<span class="normal"> 639</span>
<span class="normal"> 640</span>
<span class="normal"> 641</span>
<span class="normal"> 642</span>
<span class="normal"> 643</span>
<span class="normal"> 644</span>
<span class="normal"> 645</span>
<span class="normal"> 646</span>
<span class="normal"> 647</span>
<span class="normal"> 648</span>
<span class="normal"> 649</span>
<span class="normal"> 650</span>
<span class="normal"> 651</span>
<span class="normal"> 652</span>
<span class="normal"> 653</span>
<span class="normal"> 654</span>
<span class="normal"> 655</span>
<span class="normal"> 656</span>
<span class="normal"> 657</span>
<span class="normal"> 658</span>
<span class="normal"> 659</span>
<span class="normal"> 660</span>
<span class="normal"> 661</span>
<span class="normal"> 662</span>
<span class="normal"> 663</span>
<span class="normal"> 664</span>
<span class="normal"> 665</span>
<span class="normal"> 666</span>
<span class="normal"> 667</span>
<span class="normal"> 668</span>
<span class="normal"> 669</span>
<span class="normal"> 670</span>
<span class="normal"> 671</span>
<span class="normal"> 672</span>
<span class="normal"> 673</span>
<span class="normal"> 674</span>
<span class="normal"> 675</span>
<span class="normal"> 676</span>
<span class="normal"> 677</span>
<span class="normal"> 678</span>
<span class="normal"> 679</span>
<span class="normal"> 680</span>
<span class="normal"> 681</span>
<span class="normal"> 682</span>
<span class="normal"> 683</span>
<span class="normal"> 684</span>
<span class="normal"> 685</span>
<span class="normal"> 686</span>
<span class="normal"> 687</span>
<span class="normal"> 688</span>
<span class="normal"> 689</span>
<span class="normal"> 690</span>
<span class="normal"> 691</span>
<span class="normal"> 692</span>
<span class="normal"> 693</span>
<span class="normal"> 694</span>
<span class="normal"> 695</span>
<span class="normal"> 696</span>
<span class="normal"> 697</span>
<span class="normal"> 698</span>
<span class="normal"> 699</span>
<span class="normal"> 700</span>
<span class="normal"> 701</span>
<span class="normal"> 702</span>
<span class="normal"> 703</span>
<span class="normal"> 704</span>
<span class="normal"> 705</span>
<span class="normal"> 706</span>
<span class="normal"> 707</span>
<span class="normal"> 708</span>
<span class="normal"> 709</span>
<span class="normal"> 710</span>
<span class="normal"> 711</span>
<span class="normal"> 712</span>
<span class="normal"> 713</span>
<span class="normal"> 714</span>
<span class="normal"> 715</span>
<span class="normal"> 716</span>
<span class="normal"> 717</span>
<span class="normal"> 718</span>
<span class="normal"> 719</span>
<span class="normal"> 720</span>
<span class="normal"> 721</span>
<span class="normal"> 722</span>
<span class="normal"> 723</span>
<span class="normal"> 724</span>
<span class="normal"> 725</span>
<span class="normal"> 726</span>
<span class="normal"> 727</span>
<span class="normal"> 728</span>
<span class="normal"> 729</span>
<span class="normal"> 730</span>
<span class="normal"> 731</span>
<span class="normal"> 732</span>
<span class="normal"> 733</span>
<span class="normal"> 734</span>
<span class="normal"> 735</span>
<span class="normal"> 736</span>
<span class="normal"> 737</span>
<span class="normal"> 738</span>
<span class="normal"> 739</span>
<span class="normal"> 740</span>
<span class="normal"> 741</span>
<span class="normal"> 742</span>
<span class="normal"> 743</span>
<span class="normal"> 744</span>
<span class="normal"> 745</span>
<span class="normal"> 746</span>
<span class="normal"> 747</span>
<span class="normal"> 748</span>
<span class="normal"> 749</span>
<span class="normal"> 750</span>
<span class="normal"> 751</span>
<span class="normal"> 752</span>
<span class="normal"> 753</span>
<span class="normal"> 754</span>
<span class="normal"> 755</span>
<span class="normal"> 756</span>
<span class="normal"> 757</span>
<span class="normal"> 758</span>
<span class="normal"> 759</span>
<span class="normal"> 760</span>
<span class="normal"> 761</span>
<span class="normal"> 762</span>
<span class="normal"> 763</span>
<span class="normal"> 764</span>
<span class="normal"> 765</span>
<span class="normal"> 766</span>
<span class="normal"> 767</span>
<span class="normal"> 768</span>
<span class="normal"> 769</span>
<span class="normal"> 770</span>
<span class="normal"> 771</span>
<span class="normal"> 772</span>
<span class="normal"> 773</span>
<span class="normal"> 774</span>
<span class="normal"> 775</span>
<span class="normal"> 776</span>
<span class="normal"> 777</span>
<span class="normal"> 778</span>
<span class="normal"> 779</span>
<span class="normal"> 780</span>
<span class="normal"> 781</span>
<span class="normal"> 782</span>
<span class="normal"> 783</span>
<span class="normal"> 784</span>
<span class="normal"> 785</span>
<span class="normal"> 786</span>
<span class="normal"> 787</span>
<span class="normal"> 788</span>
<span class="normal"> 789</span>
<span class="normal"> 790</span>
<span class="normal"> 791</span>
<span class="normal"> 792</span>
<span class="normal"> 793</span>
<span class="normal"> 794</span>
<span class="normal"> 795</span>
<span class="normal"> 796</span>
<span class="normal"> 797</span>
<span class="normal"> 798</span>
<span class="normal"> 799</span>
<span class="normal"> 800</span>
<span class="normal"> 801</span>
<span class="normal"> 802</span>
<span class="normal"> 803</span>
<span class="normal"> 804</span>
<span class="normal"> 805</span>
<span class="normal"> 806</span>
<span class="normal"> 807</span>
<span class="normal"> 808</span>
<span class="normal"> 809</span>
<span class="normal"> 810</span>
<span class="normal"> 811</span>
<span class="normal"> 812</span>
<span class="normal"> 813</span>
<span class="normal"> 814</span>
<span class="normal"> 815</span>
<span class="normal"> 816</span>
<span class="normal"> 817</span>
<span class="normal"> 818</span>
<span class="normal"> 819</span>
<span class="normal"> 820</span>
<span class="normal"> 821</span>
<span class="normal"> 822</span>
<span class="normal"> 823</span>
<span class="normal"> 824</span>
<span class="normal"> 825</span>
<span class="normal"> 826</span>
<span class="normal"> 827</span>
<span class="normal"> 828</span>
<span class="normal"> 829</span>
<span class="normal"> 830</span>
<span class="normal"> 831</span>
<span class="normal"> 832</span>
<span class="normal"> 833</span>
<span class="normal"> 834</span>
<span class="normal"> 835</span>
<span class="normal"> 836</span>
<span class="normal"> 837</span>
<span class="normal"> 838</span>
<span class="normal"> 839</span>
<span class="normal"> 840</span>
<span class="normal"> 841</span>
<span class="normal"> 842</span>
<span class="normal"> 843</span>
<span class="normal"> 844</span>
<span class="normal"> 845</span>
<span class="normal"> 846</span>
<span class="normal"> 847</span>
<span class="normal"> 848</span>
<span class="normal"> 849</span>
<span class="normal"> 850</span>
<span class="normal"> 851</span>
<span class="normal"> 852</span>
<span class="normal"> 853</span>
<span class="normal"> 854</span>
<span class="normal"> 855</span>
<span class="normal"> 856</span>
<span class="normal"> 857</span>
<span class="normal"> 858</span>
<span class="normal"> 859</span>
<span class="normal"> 860</span>
<span class="normal"> 861</span>
<span class="normal"> 862</span>
<span class="normal"> 863</span>
<span class="normal"> 864</span>
<span class="normal"> 865</span>
<span class="normal"> 866</span>
<span class="normal"> 867</span>
<span class="normal"> 868</span>
<span class="normal"> 869</span>
<span class="normal"> 870</span>
<span class="normal"> 871</span>
<span class="normal"> 872</span>
<span class="normal"> 873</span>
<span class="normal"> 874</span>
<span class="normal"> 875</span>
<span class="normal"> 876</span>
<span class="normal"> 877</span>
<span class="normal"> 878</span>
<span class="normal"> 879</span>
<span class="normal"> 880</span>
<span class="normal"> 881</span>
<span class="normal"> 882</span>
<span class="normal"> 883</span>
<span class="normal"> 884</span>
<span class="normal"> 885</span>
<span class="normal"> 886</span>
<span class="normal"> 887</span>
<span class="normal"> 888</span>
<span class="normal"> 889</span>
<span class="normal"> 890</span>
<span class="normal"> 891</span>
<span class="normal"> 892</span>
<span class="normal"> 893</span>
<span class="normal"> 894</span>
<span class="normal"> 895</span>
<span class="normal"> 896</span>
<span class="normal"> 897</span>
<span class="normal"> 898</span>
<span class="normal"> 899</span>
<span class="normal"> 900</span>
<span class="normal"> 901</span>
<span class="normal"> 902</span>
<span class="normal"> 903</span>
<span class="normal"> 904</span>
<span class="normal"> 905</span>
<span class="normal"> 906</span>
<span class="normal"> 907</span>
<span class="normal"> 908</span>
<span class="normal"> 909</span>
<span class="normal"> 910</span>
<span class="normal"> 911</span>
<span class="normal"> 912</span>
<span class="normal"> 913</span>
<span class="normal"> 914</span>
<span class="normal"> 915</span>
<span class="normal"> 916</span>
<span class="normal"> 917</span>
<span class="normal"> 918</span>
<span class="normal"> 919</span>
<span class="normal"> 920</span>
<span class="normal"> 921</span>
<span class="normal"> 922</span>
<span class="normal"> 923</span>
<span class="normal"> 924</span>
<span class="normal"> 925</span>
<span class="normal"> 926</span>
<span class="normal"> 927</span>
<span class="normal"> 928</span>
<span class="normal"> 929</span>
<span class="normal"> 930</span>
<span class="normal"> 931</span>
<span class="normal"> 932</span>
<span class="normal"> 933</span>
<span class="normal"> 934</span>
<span class="normal"> 935</span>
<span class="normal"> 936</span>
<span class="normal"> 937</span>
<span class="normal"> 938</span>
<span class="normal"> 939</span>
<span class="normal"> 940</span>
<span class="normal"> 941</span>
<span class="normal"> 942</span>
<span class="normal"> 943</span>
<span class="normal"> 944</span>
<span class="normal"> 945</span>
<span class="normal"> 946</span>
<span class="normal"> 947</span>
<span class="normal"> 948</span>
<span class="normal"> 949</span>
<span class="normal"> 950</span>
<span class="normal"> 951</span>
<span class="normal"> 952</span>
<span class="normal"> 953</span>
<span class="normal"> 954</span>
<span class="normal"> 955</span>
<span class="normal"> 956</span>
<span class="normal"> 957</span>
<span class="normal"> 958</span>
<span class="normal"> 959</span>
<span class="normal"> 960</span>
<span class="normal"> 961</span>
<span class="normal"> 962</span>
<span class="normal"> 963</span>
<span class="normal"> 964</span>
<span class="normal"> 965</span>
<span class="normal"> 966</span>
<span class="normal"> 967</span>
<span class="normal"> 968</span>
<span class="normal"> 969</span>
<span class="normal"> 970</span>
<span class="normal"> 971</span>
<span class="normal"> 972</span>
<span class="normal"> 973</span>
<span class="normal"> 974</span>
<span class="normal"> 975</span>
<span class="normal"> 976</span>
<span class="normal"> 977</span>
<span class="normal"> 978</span>
<span class="normal"> 979</span>
<span class="normal"> 980</span>
<span class="normal"> 981</span>
<span class="normal"> 982</span>
<span class="normal"> 983</span>
<span class="normal"> 984</span>
<span class="normal"> 985</span>
<span class="normal"> 986</span>
<span class="normal"> 987</span>
<span class="normal"> 988</span>
<span class="normal"> 989</span>
<span class="normal"> 990</span>
<span class="normal"> 991</span>
<span class="normal"> 992</span>
<span class="normal"> 993</span>
<span class="normal"> 994</span>
<span class="normal"> 995</span>
<span class="normal"> 996</span>
<span class="normal"> 997</span>
<span class="normal"> 998</span>
<span class="normal"> 999</span>
<span class="normal">1000</span>
<span class="normal">1001</span>
<span class="normal">1002</span>
<span class="normal">1003</span>
<span class="normal">1004</span>
<span class="normal">1005</span>
<span class="normal">1006</span>
<span class="normal">1007</span>
<span class="normal">1008</span>
<span class="normal">1009</span>
<span class="normal">1010</span>
<span class="normal">1011</span>
<span class="normal">1012</span>
<span class="normal">1013</span>
<span class="normal">1014</span>
<span class="normal">1015</span>
<span class="normal">1016</span>
<span class="normal">1017</span>
<span class="normal">1018</span>
<span class="normal">1019</span>
<span class="normal">1020</span>
<span class="normal">1021</span>
<span class="normal">1022</span>
<span class="normal">1023</span>
<span class="normal">1024</span>
<span class="normal">1025</span>
<span class="normal">1026</span>
<span class="normal">1027</span>
<span class="normal">1028</span>
<span class="normal">1029</span>
<span class="normal">1030</span>
<span class="normal">1031</span>
<span class="normal">1032</span>
<span class="normal">1033</span>
<span class="normal">1034</span>
<span class="normal">1035</span>
<span class="normal">1036</span>
<span class="normal">1037</span>
<span class="normal">1038</span>
<span class="normal">1039</span>
<span class="normal">1040</span>
<span class="normal">1041</span>
<span class="normal">1042</span>
<span class="normal">1043</span>
<span class="normal">1044</span>
<span class="normal">1045</span>
<span class="normal">1046</span>
<span class="normal">1047</span>
<span class="normal">1048</span>
<span class="normal">1049</span>
<span class="normal">1050</span>
<span class="normal">1051</span>
<span class="normal">1052</span>
<span class="normal">1053</span>
<span class="normal">1054</span>
<span class="normal">1055</span>
<span class="normal">1056</span>
<span class="normal">1057</span>
<span class="normal">1058</span>
<span class="normal">1059</span>
<span class="normal">1060</span>
<span class="normal">1061</span>
<span class="normal">1062</span>
<span class="normal">1063</span>
<span class="normal">1064</span>
<span class="normal">1065</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">rop_vertex</span><span class="p">:</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A vertex object for reaction order polyhedra.</span>
<span class="sd">    Each binding network has multiple vertices.</span>

<span class="sd">    Args:</span>
<span class="sd">        perm (int tuple): An integer tuple of length dim_d, indicating for each conserved quantity, </span>
<span class="sd">            which species is dominant.</span>
<span class="sd">        bn (binding_network object): The binding network that this vertex belongs to.</span>
<span class="sd">            Has l_mat (conservation law matrix) and n_mat (stoichiometry matrix).</span>
<span class="sd">        p_mat (numpy array, d-by-n): d x n matrix with exactly one nonzero entry in each row, </span>
<span class="sd">            of value 1. One-hot representation of perm.</span>
<span class="sd">        p0_vec (numpy array, d-by-1): Vector used in (logt, logk) = [p_mat n_mat]&#39; logx + [p0_vec 0]&#39;. </span>
<span class="sd">            Intercept relating log x to (logt, logk).</span>
<span class="sd">            n_mat is that of the binding network.</span>
<span class="sd">            p0_vec is all zeros if all entries of bn&#39;s l_mat are 0 and 1&#39;s.</span>
<span class="sd">        m_mat (numpy array, n-by-n): Matrix formed by p_mat and n_mat stacked vertically. </span>
<span class="sd">            In other words, m_mat = [p_mat n_mat]&#39;.</span>
<span class="sd">            n_mat is that of the binding network.</span>
<span class="sd">        m0_vec (numpy array, n-by-1): Vector used in (logt, logk) = m_mat logx + m0_vec.</span>
<span class="sd">            m0_vec is the same as [p0_vec 0]&#39;, i.e., p0_vec vertically extended with r more zeros.</span>
<span class="sd">        orientation (int): Take value in +1, 0, -1. Sign of determinant of [A&#39; N&#39;] matrix.</span>
<span class="sd">        h_mat (numpy array, n-by-n): n x n matrix corresponding to the log derivative of this vertex.</span>
<span class="sd">            If finite (non-singular), then this is the log derivative.</span>
<span class="sd">            If infinite (singular), then this is the direction that log derivative goes into.</span>
<span class="sd">            At this vertex, we have relation logx = h_mat (logt, logk) + h0_vec.</span>
<span class="sd">            Not always defined, computed and stored once log derivative is </span>
<span class="sd">            computed by calling self.vertex_ld_calc().</span>
<span class="sd">        h0_vec (numpy array, n-by-1): The intercept vector used in the following relation at this vertex:</span>
<span class="sd">            logx = h_mat (logt, logk) + h0_vec.</span>
<span class="sd">            Only defined for finite (non-singular) vertices.</span>
<span class="sd">            Not always defined, computed and stored once log derivative is </span>
<span class="sd">            computed by calling self.vertex_ld_calc().</span>
<span class="sd">        c_mat_x (numpy array, shape (n_constraints, n_var)): Matrix encoding feasibility condition of this vertex</span>
<span class="sd">            in &#39;x&#39; chart, c_mat_x * logx + c0_vec &gt; 0.</span>
<span class="sd">            If the feasibility condition is considered &quot;asymptotic&quot;, i.e., in positive</span>
<span class="sd">            projective measure rather than Lebesgue measure (so a ray is an infinitesimal</span>
<span class="sd">            of volume, not a point), then c0_vec is dropped.</span>
<span class="sd">            Not always defined, computed and stored when used in feasibility tests.</span>
<span class="sd">        c_mat_xak (numpy array, shape (n_constraints, n_var)): Matrix encoding feasibility condition of this vertex</span>
<span class="sd">            in &#39;xak&#39; chart, c_mat_xak * (logxa, logk) + c0_vec &gt; 0.</span>
<span class="sd">            If the feasibility condition is considered &quot;asymptotic&quot;, i.e., in positive</span>
<span class="sd">            projective measure rather than Lebesgue measure (so a ray is an infinitesimal</span>
<span class="sd">            of volume, not a point), then c0_vec is dropped.</span>
<span class="sd">            Not always defined, computed and stored when used in feasibility tests.</span>
<span class="sd">        c0_vec (numpy vector, shape (n_constraints,)): Numpy vector encoding a part of the feasibility condition of this vertex,</span>
<span class="sd">            same for &#39;x&#39; chart and &#39;xak&#39; chart.</span>
<span class="sd">            Not always defined, computed and stored when used in feasibility tests.</span>
<span class="sd">        c_mat_tk (numpy array, shape (n_constraints, n_var)): Matrix encoding feasibility condition of this vertex</span>
<span class="sd">            in &#39;tk&#39; chart, c_mat_tk * (logt, logk) + c0_vec_tk &gt; 0.</span>
<span class="sd">            If the feasibility condition is considered &quot;asymptotic&quot;, i.e., in positive</span>
<span class="sd">            projective measure rather than Lebesgue measure (so a ray is an infinitesimal</span>
<span class="sd">            of volume, not a point), then c0_vec_tk is dropped.</span>
<span class="sd">            Only defined for finite (non-singular) vertices.</span>
<span class="sd">            Not always defined, computed and stored when used in feasibility tests.</span>
<span class="sd">        c0_vec_tk (numpy vector, shape (n_constraints,)): Numpy vector encoding a part of the feasibility condition of this vertex</span>
<span class="sd">            in the &#39;tk&#39; chart.</span>
<span class="sd">            Only defined for finite (non-singular) vertices.</span>
<span class="sd">            Not always defined, computed and stored when used in feasibility tests.</span>
<span class="sd">        neighbors_dict (dict): The dictionary for dom_regime neighbors of this dom_regime.</span>
<span class="sd">            Has four keys: &quot;finite&quot;, &quot;infinite&quot;, &quot;all&quot;, and &quot;zero&quot;.</span>
<span class="sd">            - &quot;finite&quot;, &quot;infinite&quot;, and &quot;all&quot; map to dictionaries with (perm, row_idx) tuple as keys </span>
<span class="sd">              and the dom_regime object as values.</span>
<span class="sd">            - &quot;zero&quot; maps to neighbors connected via dom_regimes that are zero rays in reaction orders </span>
<span class="sd">              (or log derivative).</span>
<span class="sd">        neighbors_constrained_dict (dict): The dictionary for ld_regime neighbors of this ld_regime that are feasible</span>
<span class="sd">            under constraints applied to each dom_regime. </span>
<span class="sd">            Same keys as neighbors_dict.</span>
<span class="sd">    &quot;&quot;&quot;</span>
  <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">perm</span><span class="p">,</span><span class="n">bn</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initiates a ROP vertex.</span>

<span class="sd">    Args:</span>
<span class="sd">        perm (int tuple): An integer tuple of length dim_d, indicating for each conserved quantity, </span>
<span class="sd">            which species is dominant.</span>
<span class="sd">        bn (binding_network object): The binding network that this vertex is a part of.</span>
<span class="sd">            Used to get dimensions and stoichiometry matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">perm</span><span class="o">=</span><span class="n">perm</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">=</span><span class="n">bn</span>
    <span class="n">p_mat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">bn</span><span class="o">.</span><span class="n">dim_d</span><span class="p">,</span><span class="n">bn</span><span class="o">.</span><span class="n">dim_n</span><span class="p">))</span> <span class="c1"># p_mat is all 0 and 1</span>
    <span class="n">p0_vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">bn</span><span class="o">.</span><span class="n">dim_d</span><span class="p">)</span> <span class="c1"># the value of nonzero entries of l_mat chosen by p_mat in each row for this vertex</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bn</span><span class="o">.</span><span class="n">dim_d</span><span class="p">):</span>
      <span class="n">p_mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">=</span><span class="mi">1</span>
      <span class="n">p0_vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">bn</span><span class="o">.</span><span class="n">l_mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">p_mat</span><span class="o">=</span><span class="n">p_mat</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">p0_vec</span><span class="o">=</span><span class="n">p0_vec</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">m_mat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">p_mat</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">.</span><span class="n">n_mat</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">m0_vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">p0_vec</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">.</span><span class="n">dim_r</span><span class="p">)),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">orientation</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m_mat</span><span class="p">))</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">is_feasible</span><span class="o">=</span><span class="kc">True</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">vertex_ld_calc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># calculate log derivative matrix,</span>
    <span class="c1"># gives ray direction matrix if infinite vertex</span>
    <span class="n">dim_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">.</span><span class="n">dim_n</span>
    <span class="n">m_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m_mat</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">orientation</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c1"># if singular, get the ray direction</span>
      <span class="n">m_mult_left</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dim_n</span><span class="p">),</span><span class="n">m_mat</span><span class="p">)</span>
      <span class="n">m_mult_right</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">m_mat</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dim_n</span><span class="p">))</span>
      <span class="n">temp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span> <span class="p">(</span><span class="n">m_mult_left</span><span class="p">,</span><span class="n">m_mult_right</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
      <span class="c1"># the following assertion test is not necessary if guaranteed to be rank 1 singularity.</span>
      <span class="c1"># assert temp.shape[1]-np.linalg.matrix_rank(temp)==1, &quot;the vertex is singular in more than one direction.&quot;</span>
      <span class="c1"># we assert that an infinite vertex cannot be singular in more than one direction</span>
      <span class="c1"># so the ray is always rank 1. We assume higher order rays are convex combinations of first order rays.</span>
      <span class="n">rslt</span><span class="o">=</span><span class="n">null_space</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
      <span class="c1"># the following normalizes the entries to largest entry = 1.</span>
      <span class="n">h_mat_coarse</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">rslt</span><span class="p">,(</span><span class="n">dim_n</span><span class="p">,</span><span class="n">dim_n</span><span class="p">),</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span> <span class="c1">#order=&#39;F&#39; is earlier index changes first. here fortran</span>
      <span class="n">temp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">h_mat_coarse</span><span class="p">)</span>
      <span class="n">minfactor</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="n">temp</span><span class="o">&gt;</span><span class="mf">1e-7</span><span class="p">])</span>
      <span class="n">h_mat_coarse_int</span><span class="o">=</span><span class="n">h_mat_coarse</span><span class="o">/</span><span class="n">minfactor</span> <span class="c1">#all non-zero entries are now integers</span>
      <span class="n">h_mat_int</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">h_mat_coarse_int</span><span class="p">)</span>
      <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">h_mat_int</span><span class="o">-</span><span class="n">h_mat_coarse_int</span><span class="p">))</span> <span class="o">&lt;</span><span class="mf">1e-3</span><span class="p">,</span> <span class="s1">&#39;rounding of h_mat for vertices caused large error.&#39;</span>
      <span class="n">h_mat</span><span class="o">=</span><span class="n">h_mat_int</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">h_mat_int</span><span class="p">)</span> <span class="c1"># normalize largest entry to 1.</span>

      <span class="c1"># now we need to check the directionality. This utilizes neighbors</span>
      <span class="n">vv_nb</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neighbors_dict</span><span class="p">[</span><span class="s1">&#39;finite&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
      <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">vv_nb</span><span class="o">.</span><span class="n">h_mat</span><span class="o">+</span><span class="mf">1e5</span><span class="o">*</span><span class="n">h_mat</span><span class="p">))</span><span class="o">!=</span><span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">.</span><span class="n">orientation</span><span class="p">:</span>
        <span class="n">h_mat</span><span class="o">=-</span><span class="mi">1</span><span class="o">*</span><span class="n">h_mat</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1"># if not singular, just invert the matrix.</span>
      <span class="n">h_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">m_mat</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">h0_vec</span> <span class="o">=</span> <span class="o">-</span><span class="n">h_mat</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m0_vec</span><span class="p">)</span> <span class="c1"># only non-singular vertices have h0_vec.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">h_mat</span><span class="o">=</span><span class="n">h_mat</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">vertex_c_mat_x_calc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># Get feasibility condition for this vertex expressed in (x) chart.</span>
    <span class="c1"># c_mat*log(x) + c0_vec &gt; 0 is the validity condition, log is log10.</span>
    <span class="n">l_mat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">.</span><span class="n">l_mat</span>
    <span class="n">j_list</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">j_func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p_mat</span><span class="p">,</span><span class="n">l_mat</span><span class="p">)</span>
    <span class="n">dim</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">j_list</span><span class="p">])</span>
    <span class="n">c_mat_x</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">dim</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">.</span><span class="n">dim_n</span><span class="p">))</span>
    <span class="n">c0_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
    <span class="n">dim_n</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">.</span><span class="n">dim_n</span>
    <span class="n">counter</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">.</span><span class="n">dim_d</span><span class="p">):</span>
      <span class="n">j_i</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
      <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">j_list</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
        <span class="n">c_mat_x</span><span class="p">[</span><span class="n">counter</span><span class="p">,</span><span class="n">j_i</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
        <span class="n">c_mat_x</span><span class="p">[</span><span class="n">counter</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=-</span><span class="mi">1</span>
        <span class="n">c0_vec</span><span class="p">[</span><span class="n">counter</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">l_mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j_i</span><span class="p">])</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">l_mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span>
        <span class="n">counter</span><span class="o">+=</span><span class="mi">1</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">c_mat_x</span><span class="o">=</span><span class="n">c_mat_x</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">c0_vec</span> <span class="o">=</span> <span class="n">c0_vec</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">j_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">p_mat</span><span class="p">,</span><span class="n">l_mat</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For p_mat and l_mat, find (column) indices that are nonzero in each row of</span>
<span class="sd">    l_mat but not nonzero in p_mat.</span>

<span class="sd">    Args:</span>
<span class="sd">        p_mat (numpy array): d-by-n matrix, each row has only one nonzero entry that is 1.</span>
<span class="sd">        l_mat (numpy array): d-by-n matrix, binding network&#39;s conservation law matrix.</span>

<span class="sd">    Returns:</span>
<span class="sd">        j_list (list of int): List of (column) indices that are nonzero in l_mat but zero in p_mat.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">j_list</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">l_mat_masked</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">l_mat</span><span class="p">,</span><span class="n">mask</span><span class="o">=</span><span class="n">p_mat</span><span class="p">)</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
      <span class="n">j_list</span><span class="o">+=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">l_mat_masked</span><span class="p">[</span><span class="n">i</span><span class="p">,:])[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">j_list</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">vertex_feasibility_test</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">chart</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="n">opt_constraints</span><span class="o">=</span><span class="p">[],</span><span class="n">positive_threshold</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span><span class="n">is_asymptotic</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For given constraints, compute whether this vertex is feasible.</span>

<span class="sd">    Args:</span>
<span class="sd">        chart (str, optional): A string indicating the chart that the opt_constraints are specified in.</span>
<span class="sd">            Choices are &#39;x&#39;,&#39;xak&#39;, and &#39;tk&#39;.</span>
<span class="sd">        opt_constraints (list of cvxpy inequalities, optional): A list of optimization constraints specified in terms of inequalities</span>
<span class="sd">            relating cvxpy variables of the binding network.</span>
<span class="sd">        positive_threshold (float, optional): The vertex itself has inequality conditions, of the form c_mat*x + c0_vec &gt; th,</span>
<span class="sd">            where th is the positive threshold used here. Defaults to 1e-5.</span>
<span class="sd">        is_asymptotic (bool, optional): Whether the inequalities of the vertex itself should be considered asymptotically</span>
<span class="sd">            or exactly. If asymptotically, then the inequality tested omits c0_vec,</span>
<span class="sd">            so it is c_mat*x &gt; th. is_asymptotic=True corresponds to inequality satisfied</span>
<span class="sd">            for the positive projective measure (where a ray is an infinitesimal of volume),</span>
<span class="sd">            and is_asymptotic=False is Lebesgue measure (a point is an infinitesimal of volume).</span>

<span class="sd">    Returns:</span>
<span class="sd">        is_feasible (bool): Whether this vertex is feasible under the constraints.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># first prepare the c_mat and c0_vec for the desired chart.</span>
    <span class="n">c_mat</span><span class="p">,</span><span class="n">c0_vec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">chart_check</span><span class="p">(</span><span class="n">chart</span><span class="p">)</span>
    <span class="n">is_feasible</span><span class="o">=</span><span class="kc">True</span>
    <span class="n">opt_var</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">.</span><span class="n">opt_var</span> <span class="c1">#opt_var came from the binding network.</span>
    <span class="k">if</span> <span class="n">is_asymptotic</span><span class="p">:</span> <span class="c1">#if asymptotic, c0_vec is zero.</span>
      <span class="n">prob</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">Problem</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">Minimize</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">opt_constraints</span><span class="o">+</span><span class="p">[</span><span class="n">c_mat</span> <span class="o">@</span> <span class="n">opt_var</span> <span class="o">&gt;=</span> <span class="n">positive_threshold</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1"># if not asymptotic, it is exact, so c0_vec is taken into account.</span>
      <span class="n">prob</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">Problem</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">Minimize</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">opt_constraints</span><span class="o">+</span><span class="p">[</span><span class="n">c_mat</span> <span class="o">@</span> <span class="n">opt_var</span> <span class="o">+</span> <span class="n">c0_vec</span> <span class="o">&gt;=</span> <span class="n">positive_threshold</span><span class="p">])</span>
    <span class="n">prob</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">prob</span><span class="o">.</span><span class="n">status</span><span class="o">==</span><span class="s1">&#39;infeasible&#39;</span><span class="p">:</span>
      <span class="n">is_feasible</span><span class="o">=</span><span class="kc">False</span>
    <span class="k">return</span> <span class="n">is_feasible</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">vertex_find_neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># Given a binding network with (already-computed) vertex dictionaries,</span>
    <span class="c1">#   compute this vertex&#39;s neighbors and store in self.neighbors,</span>
    <span class="c1">#   depending on whether it is finite or infinite.</span>
    <span class="c1"># Neighbor is defined as changing one row by moving the &quot;1&quot; to another place.</span>
    <span class="c1"># For chart &#39;x&#39;, neighbor is more nuanced.</span>
    <span class="c1">#   For example, (0,7,7) can have a neighbor (7,1,7) because it has </span>
    <span class="c1">#     neighbor (7,7,7), which is shared with (7,1,7).</span>
    <span class="c1">#   But we do not consider (7,7,7) as an &quot;infinite vertex&quot;,</span>
    <span class="c1">#     since &gt;1 order infinite vertices only matter as a </span>
    <span class="c1">#     &quot;connecting region&quot;, and they are ignored in vertex construction. </span>
    <span class="c1">#   To include these cases, for an infinite vertex perm1, for a given candidate </span>
    <span class="c1">#     infinite neighbor perm 2, if difference is 2 then of course it&#39;s a neighbor,</span>
    <span class="c1">#     e.g. (5,5,2) and (5,5,3); if difference is more than 2, then switch the</span>
    <span class="c1">#     differing rows&#39; order and see whether now they match with difference in just one row.</span>
    <span class="c1">#   Since whenever this is the case, there is the regime (j,j,j,*)</span>
    <span class="n">neighbors_fin</span><span class="o">=</span><span class="p">{}</span>
    <span class="n">neighbors_inf</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">perm</span><span class="p">,</span><span class="n">vv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">.</span><span class="n">vertex_dict</span><span class="p">[</span><span class="s1">&#39;finite&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
      <span class="c1"># temp=[not np.all(self.p_mat[i,:]==vv.p_mat[i,:]) for i in range(self.bn.dim_d)]</span>
      <span class="c1"># if np.sum(temp)==1: #the difference is just one row</span>
      <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p_mat</span><span class="o">-</span><span class="n">vv</span><span class="o">.</span><span class="n">p_mat</span><span class="p">))</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span> <span class="c1">#difference is in just one row and it&#39;s -1, 1.</span>
        <span class="n">neighbors_fin</span><span class="p">[</span><span class="n">perm</span><span class="p">]</span><span class="o">=</span><span class="n">vv</span>
    <span class="k">for</span> <span class="n">perm</span><span class="p">,</span><span class="n">vv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">.</span><span class="n">vertex_dict</span><span class="p">[</span><span class="s1">&#39;infinite&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
      <span class="c1"># temp=[not np.all(self.p_mat[i,:]==vv.p_mat[i,:]) for i in range(self.bn.dim_d)]</span>
      <span class="c1"># if np.sum(temp)==1: #the difference is just one row</span>
      <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p_mat</span><span class="o">-</span><span class="n">vv</span><span class="o">.</span><span class="n">p_mat</span><span class="p">))</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span> <span class="c1">#difference is in just one row and it&#39;s -1, 1.</span>
        <span class="n">neighbors_inf</span><span class="p">[</span><span class="n">perm</span><span class="p">]</span><span class="o">=</span><span class="n">vv</span>

    <span class="c1"># if self.orientation==0:</span>
    <span class="n">neighbors_all</span><span class="o">=</span><span class="p">{</span><span class="o">**</span><span class="n">neighbors_fin</span><span class="p">,</span><span class="o">**</span><span class="n">neighbors_inf</span><span class="p">}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">neighbors_dict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;finite&#39;</span><span class="p">:</span><span class="n">neighbors_fin</span><span class="p">,</span><span class="s1">&#39;infinite&#39;</span><span class="p">:</span><span class="n">neighbors_inf</span><span class="p">,</span><span class="s1">&#39;all&#39;</span><span class="p">:</span><span class="n">neighbors_all</span><span class="p">}</span>


  <span class="k">def</span><span class="w"> </span><span class="nf">vertex_update_constrained_neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># Using vertices&#39; is_feasible tag to have updated neighbors under constraints.</span>
    <span class="c1"># The feasible neighbors of an infeasible neighbor becomes this vertex&#39;s neighbors</span>
    <span class="c1"># under constraints.</span>
    <span class="c1"># If an infeasible neighbor has infeasible neighbors as well, we need to look at</span>
    <span class="c1"># their feasible neighbors as neighbors under constraint as well.</span>
    <span class="c1"># So this uses recursion.</span>
    <span class="c1"># The resulting constrained neighbors is stored in self.neighbors_constrained_dict.</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">extract_infeasible_neighbor</span><span class="p">(</span><span class="n">neighbors_all</span><span class="p">,</span><span class="n">neighbors_feasible_all</span><span class="p">,</span><span class="n">visited</span><span class="p">):</span>
      <span class="n">infeasible_neighbors</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">perm</span><span class="p">:</span> <span class="n">vv</span> <span class="k">for</span> <span class="n">perm</span><span class="p">,</span><span class="n">vv</span> <span class="ow">in</span> <span class="n">neighbors_all</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">vv</span><span class="o">.</span><span class="n">is_feasible</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="n">infeasible_neighbors</span><span class="p">:</span>  <span class="c1"># the dictionary is not empty</span>
        <span class="k">for</span> <span class="n">perm</span><span class="p">,</span><span class="n">vv</span> <span class="ow">in</span> <span class="n">infeasible_neighbors</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">perm</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span>
                <span class="n">neighbors_feasible_all</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">perm</span><span class="p">:</span><span class="n">vv</span> <span class="k">for</span> <span class="n">perm</span><span class="p">,</span><span class="n">vv</span> <span class="ow">in</span> <span class="n">vv</span><span class="o">.</span><span class="n">neighbors_dict</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">vv</span><span class="o">.</span><span class="n">is_feasible</span><span class="p">})</span>
                <span class="n">neighbors_feasible_all</span><span class="p">,</span> <span class="n">visited</span> <span class="o">=</span> <span class="n">extract_infeasible_neighbor</span><span class="p">(</span>
                  <span class="n">vv</span><span class="o">.</span><span class="n">neighbors_dict</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">],</span>
                  <span class="n">neighbors_feasible_all</span><span class="p">,</span>
                  <span class="n">visited</span>
                <span class="p">)</span>
      <span class="k">return</span> <span class="n">neighbors_feasible_all</span><span class="p">,</span> <span class="n">visited</span>

    <span class="c1"># first, each neighbor that is feasible should be a neighbor under constraint.</span>
    <span class="n">neighbors_feasible_all</span> <span class="o">=</span> <span class="p">{</span><span class="n">perm</span><span class="p">:</span><span class="n">vv</span> <span class="k">for</span> <span class="n">perm</span><span class="p">,</span><span class="n">vv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighbors_dict</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">vv</span><span class="o">.</span><span class="n">is_feasible</span><span class="p">}</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="n">neighbors_feasible_all</span><span class="p">,</span><span class="n">visited</span> <span class="o">=</span> <span class="n">extract_infeasible_neighbor</span><span class="p">(</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">neighbors_dict</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">],</span><span class="n">neighbors_feasible_all</span><span class="p">,</span><span class="n">visited</span>
    <span class="p">)</span>
    <span class="c1"># Remove self from the neighbors&#39; dictionaries if present</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">neighbors_feasible_all</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">perm</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="n">neighbors_feasible_inf</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">perm</span><span class="p">:</span><span class="n">vv</span> <span class="k">for</span> <span class="n">perm</span><span class="p">,</span><span class="n">vv</span> <span class="ow">in</span> <span class="n">neighbors_feasible_all</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">vv</span><span class="o">.</span><span class="n">orientation</span><span class="o">==</span><span class="mi">0</span>
        <span class="p">}</span>
    <span class="n">neighbors_feasible_fin</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">perm</span><span class="p">:</span><span class="n">vv</span> <span class="k">for</span> <span class="n">perm</span><span class="p">,</span><span class="n">vv</span> <span class="ow">in</span> <span class="n">neighbors_feasible_all</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">vv</span><span class="o">.</span><span class="n">orientation</span><span class="o">!=</span><span class="mi">0</span>
        <span class="p">}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">neighbors_constrained_dict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;finite&#39;</span><span class="p">:</span><span class="n">neighbors_feasible_fin</span><span class="p">,</span>
                                  <span class="s1">&#39;infinite&#39;</span><span class="p">:</span><span class="n">neighbors_feasible_inf</span><span class="p">,</span>
                                  <span class="s1">&#39;all&#39;</span><span class="p">:</span><span class="n">neighbors_feasible_all</span><span class="p">}</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">vertex_c_mat_xak_calc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># get the C matrix but for log(xa,k) coordinate</span>
    <span class="c1"># store as self.c_mat_xak</span>
    <span class="k">try</span><span class="p">:</span> <span class="n">c_mat_x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c_mat_x</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">vertex_c_mat_x_calc</span><span class="p">()</span>
      <span class="n">c_mat_x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c_mat_x</span>
    <span class="k">try</span><span class="p">:</span> <span class="n">xak2x_map</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">.</span><span class="n">xak2x_map</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">.</span><span class="n">calc_xak2x_map</span><span class="p">()</span>
      <span class="n">xak2x_map</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">.</span><span class="n">xak2x_map</span>
    <span class="n">c_mat_xak</span><span class="o">=</span><span class="n">c_mat_x</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">xak2x_map</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">c_mat_xak</span><span class="o">=</span><span class="n">c_mat_xak</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">vertex_c_mat_tk_calc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># get the C matrix but for log(t,k) coordinate</span>
    <span class="c1"># store as self.c_mat_tk</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">orientation</span><span class="o">!=</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;only finite vertices can have non-singular (t,k) chart&quot;</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="n">c_mat_x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c_mat_x</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">vertex_c_mat_x_calc</span><span class="p">()</span>
      <span class="n">c_mat_x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c_mat_x</span>
    <span class="c1"># The equivalence here is the following:</span>
    <span class="c1"># c_mat_tk @ log(t,k) + c0_vec_tk &gt;=0  &lt;=&gt;  c_mat_x @ logx + c0_vec &gt;=0</span>
    <span class="n">c_mat_tk</span><span class="o">=</span><span class="n">c_mat_x</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h_mat</span><span class="p">)</span> <span class="c1">#because h_mat*log(t,k)=log(x)</span>
    <span class="n">c0_vec_tk</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c0_vec</span> <span class="o">-</span> <span class="n">c_mat_x</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h_mat</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m0_vec</span><span class="p">))</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">c_mat_tk</span><span class="o">=</span><span class="n">c_mat_tk</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">c0_vec_tk</span><span class="o">=</span><span class="n">c0_vec_tk</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">chart_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">chart</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Prepare the c_mat and c0_vec for the desired chart.</span>

<span class="sd">    Args:</span>
<span class="sd">        chart (str, optional): A string indicating the chart that the opt_constraints are specified in.</span>
<span class="sd">            Choices are &#39;x&#39;,&#39;xak&#39;, and &#39;tk&#39;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        c_mat (ndarray, shape (n_constraints, n_var)): Matrix used in this vertex&#39;s feasibility condition in the </span>
<span class="sd">            desired chart, e.g., it is c_mat * x + c0_vec &gt; 0 in chart &#39;x&#39;.</span>
<span class="sd">        c0_vec (ndarray, shape (n_constraints,)): The vector used in this vertex&#39;s feasibility condition in the</span>
<span class="sd">            desired chart, e.g., it is c_mat * x + c0_vec &gt; 0 in chart &#39;x&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">chart</span><span class="o">==</span><span class="s1">&#39;x&#39;</span><span class="p">:</span>
      <span class="k">try</span><span class="p">:</span>
        <span class="n">c_mat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c_mat_x</span>
        <span class="n">c0_vec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c0_vec</span>
      <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span> <span class="c1"># if c_mat_x is not yet calculated</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertex_c_mat_x_calc</span><span class="p">()</span>
        <span class="n">c_mat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c_mat_x</span>
        <span class="n">c0_vec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c0_vec</span>
    <span class="k">elif</span> <span class="n">chart</span><span class="o">==</span><span class="s1">&#39;xak&#39;</span><span class="p">:</span>
      <span class="k">try</span><span class="p">:</span>
        <span class="n">c_mat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c_mat_xak</span>
        <span class="n">c0_vec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c0_vec</span> <span class="c1">#c0_vec is the same for chart x and xak.</span>
      <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span> <span class="c1"># if c_mat_xak is not yet calculated</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertex_c_mat_xak_calc</span><span class="p">()</span>
        <span class="n">c_mat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c_mat_xak</span>
        <span class="n">c0_vec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c0_vec</span>
    <span class="k">elif</span> <span class="n">chart</span><span class="o">==</span><span class="s1">&#39;tk&#39;</span><span class="p">:</span>
      <span class="k">try</span><span class="p">:</span>
        <span class="n">c_mat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c_mat_tk</span>
        <span class="n">c0_vec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c0_vec_tk</span>
      <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span> <span class="c1"># if c_mat_xak is not yet calculated</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertex_c_mat_tk_calc</span><span class="p">()</span>
        <span class="n">c_mat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c_mat_tk</span>
        <span class="n">c0_vec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c0_vec_tk</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;chart that is not one of x,xak or tk is not implemented yet&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">c_mat</span><span class="p">,</span><span class="n">c0_vec</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">vertex_hull_of_validity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">chart</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="n">margin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">logmin</span><span class="o">=-</span><span class="mi">6</span><span class="p">,</span><span class="n">logmax</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span><span class="n">c_mat_extra</span><span class="o">=</span><span class="p">[],</span><span class="n">c0_vec_extra</span><span class="o">=</span><span class="p">[]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the vertices of the validity region as a bounded convex hull.</span>

<span class="sd">    Args:</span>
<span class="sd">        chart (str, optional): A string indicating the chart that the opt_constraints are specified in.</span>
<span class="sd">            Choices are &#39;x&#39;,&#39;xak&#39;, and &#39;tk&#39;.</span>
<span class="sd">        margin (float, optional): The vertex&#39;s feasibility conditions are inequalities, </span>
<span class="sd">            of the form c_mat*x + c0_vec &gt;= margin (e.g., in &#39;x&#39; chart),</span>
<span class="sd">            Margin defaults to 0, and its values are in log10.</span>
<span class="sd">            This can be adjusted to be stronger/weaker requirements on dominance.</span>
<span class="sd">        logmin (float or ndarray vector): logmin, logmax could be scalars, then it&#39;s the same value applied to </span>
<span class="sd">            every variable. </span>
<span class="sd">            They could also be vectors of length dim_n.</span>
<span class="sd">        logmax (float or ndarray vector): logmin, logmax could be scalars, then it&#39;s the same value applied to </span>
<span class="sd">            every variable. </span>
<span class="sd">            They could also be vectors of length dim_n.</span>
<span class="sd">        c_mat_extra (ndarray, shape (n_constraints, n_var)): Extra optimization constraints to be added to feasibility conditions,</span>
<span class="sd">            in the form of c_mat_extra @ var + c0_vec_extra &gt;= 0.</span>
<span class="sd">        c0_vec_extra (numpy vector, shape (n_constraints,)): Extra optimization constraints to be added to feasibility conditions,</span>
<span class="sd">            in the form of c_mat_extra @ var + c0_vec_extra &gt;=0.</span>

<span class="sd">    Returns:</span>
<span class="sd">        points (ndarray): The points corresponding to vertices of the convex hull that is the </span>
<span class="sd">            region of validity.</span>
<span class="sd">        feasible_point (ndarray vector): The point that is feasible in the interior of the convex hull.</span>
<span class="sd">        hs (scipy.spatial.HalfspaceIntersection): The half space intersection built from the feasibility inequalities.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># first check whether logmin and logmax are scalars or vectors.</span>
    <span class="k">try</span><span class="p">:</span> 
      <span class="nb">float</span><span class="p">(</span><span class="n">logmin</span><span class="p">)</span> <span class="c1"># if logmin and logmax are scalars</span>
      <span class="n">bbox</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">logmin</span><span class="p">,</span><span class="n">logmax</span><span class="p">]]),</span><span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">.</span><span class="n">dim_n</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1">#bounding box to make polyhedra bounded</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span> <span class="c1"># if logmin and logmax are vectors</span>
      <span class="c1"># stack them horizontally as column vectors</span>
      <span class="n">bbox</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">logmin</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span><span class="n">logmax</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]))</span>

    <span class="n">c_mat</span><span class="p">,</span><span class="n">c0_vec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">chart_check</span><span class="p">(</span><span class="n">chart</span><span class="p">)</span>

    <span class="c1"># the inequality c_mat*var + c0_vec - margin &gt;= 0, becomes A*var + b &lt;=0</span>
    <span class="c1"># where A = -c_mat, and b = th - c0_vec.</span>
    <span class="c1"># With extra constraints, margin is always 0 for extra constraints,</span>
    <span class="c1"># so margin_full = vstack((margin,zeros)) where zeros is of length len(c0_vec_extra)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">c_mat_extra</span><span class="p">):</span> <span class="c1"># if there are additional constraints</span>
      <span class="n">c_mat_full</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">c_mat</span><span class="p">,</span><span class="n">c_mat_extra</span><span class="p">))</span>
      <span class="n">c0_vec_full</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">c0_vec</span><span class="p">,</span><span class="n">c0_vec_extra</span><span class="p">))</span>
      <span class="n">margin_vec_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">margin</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">c0_vec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">c0_vec_extra</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1"># there are no additional constraints</span>
      <span class="n">c_mat_full</span><span class="o">=</span><span class="n">c_mat</span> 
      <span class="n">c0_vec_full</span> <span class="o">=</span> <span class="n">c0_vec</span>
      <span class="n">margin_vec_full</span> <span class="o">=</span> <span class="n">margin</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">c0_vec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">A</span><span class="o">=-</span><span class="n">c_mat_full</span> <span class="c1"># negtive because the optimization code is for Ax+b&lt;=0, while our notation is c_mat*x+c0_vec &gt;=0.</span>
    <span class="n">b</span><span class="o">=</span><span class="n">margin_vec_full</span> <span class="o">-</span> <span class="n">c0_vec_full</span>

    <span class="n">points</span><span class="p">,</span> <span class="n">hull</span><span class="p">,</span> <span class="n">feasible_point</span><span class="p">,</span> <span class="n">hs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_convex_hull</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">bbox</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">points</span><span class="p">,</span> <span class="n">hull</span><span class="p">,</span> <span class="n">feasible_point</span><span class="p">,</span><span class="n">hs</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">__feasible_point_calc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="c1"># Finds the center of the largest sphere fitting in the convex hull of</span>
    <span class="c1">#   A x + b &lt;= 0.</span>
    <span class="c1"># Use method in description of scipy.spatial.HalfspaceIntersection.</span>
    <span class="c1"># Based on Chebyshev center finding of Boyd&#39;s book 4.3.1</span>
    <span class="c1"># Needs to solve max y s.t. A x + y |A_i| + b &lt;= 0. A_i are rows of A,</span>
    <span class="c1">#   so |A_i| is the norm vector of rows of A.</span>
    <span class="c1"># We transform this inequality into min c*x, A_lp x &lt;= b_lp,</span>
    <span class="c1">#   standard form of a linear program,</span>
    <span class="c1">#   where c=(0,...,0,-1) so that c*x = x[-1] = y, and x[:-1] is x above,</span>
    <span class="c1">#   A_lp = hstack(A,|A_i|). b_lp is the same as -b, but as a column vector.</span>
    <span class="n">norm_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># Frobenius norm</span>
    <span class="n">A_linprog</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">A</span><span class="p">,</span> <span class="n">norm_vector</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]))</span> 
    <span class="n">b_linprog</span> <span class="o">=</span> <span class="o">-</span><span class="n">b</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="c1"># this makes b into shape len(b)-by-1.</span>
    <span class="n">c</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,))</span>
    <span class="n">c</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">linprog</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">A_ub</span><span class="o">=</span><span class="n">A_linprog</span><span class="p">,</span> <span class="n">b_ub</span><span class="o">=</span><span class="n">b_linprog</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">res</span><span class="o">.</span><span class="n">status</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span> <span class="nb">breakpoint</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">__add_bbox</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">bbox</span><span class="p">):</span>
    <span class="c1"># in case A x + b &lt;= 0 is not bounded, add a bounding box specified by bbox.</span>
    <span class="c1"># bbox is an array, n-by-2, the ith row is (min,max) of x_i.</span>
    <span class="c1"># Transform: bbox[i,0] is min, so x_i &gt;= bbox[i,0] becomes -x_i + bbox[i,0] &lt;=0.</span>
    <span class="c1">#   This is encoded in A&#39;s entry is -I, and b&#39;s entry is bbox[i,0].</span>
    <span class="c1">#   Similarly for max, A&#39;s entry is +I, and b&#39;s entry is -bbox[i,1].</span>
    <span class="n">dim_n</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">A_bounded</span><span class="o">=</span><span class="n">A</span>
    <span class="n">b_bounded</span><span class="o">=</span><span class="n">b</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim_n</span><span class="p">):</span>
      <span class="n">A_bounded</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">A_bounded</span><span class="p">,</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">dim_n</span><span class="p">,</span><span class="n">i</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">dim_n</span><span class="p">,</span><span class="n">i</span><span class="p">)))</span>
      <span class="n">b_bounded</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">b_bounded</span><span class="p">,</span><span class="n">bbox</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="o">-</span><span class="n">bbox</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">A_bounded</span><span class="p">,</span> <span class="n">b_bounded</span>   

  <span class="k">def</span><span class="w"> </span><span class="nf">__hs_intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">feasible_point</span><span class="p">):</span>
    <span class="c1"># HalfspaceIntersection take the convention halfspaces=[A;b]</span>
    <span class="c1">#   to indicate A x + b &lt;= 0.</span>
    <span class="n">halfspaces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]))</span>
    <span class="c1"># hs = HalfspaceIntersection(halfspaces, feasible_point,qhull_options=&#39;QJ&#39;) #QJ option to joggle to avoid non-full-dimensional constraints.</span>
    <span class="c1"># Qt option to triangulate all the time to avoid precision issues.</span>
    <span class="c1"># This is helpful to avoid problems since later on the &quot;ConvexHull&quot;</span>
    <span class="c1">#   function uses this Qt option.</span>
    <span class="n">hs</span> <span class="o">=</span> <span class="n">HalfspaceIntersection</span><span class="p">(</span><span class="n">halfspaces</span><span class="p">,</span> <span class="n">feasible_point</span><span class="p">,</span><span class="n">qhull_options</span><span class="o">=</span><span class="s1">&#39;Qt&#39;</span><span class="p">)</span> 
    <span class="k">return</span> <span class="n">hs</span>


  <span class="k">def</span><span class="w"> </span><span class="nf">get_convex_hull</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">A_local</span><span class="p">,</span> <span class="n">b_local</span><span class="p">,</span> <span class="n">bbox</span><span class="p">):</span>
    <span class="c1"># Given A,b for halfspace intersection A x + b &lt;=0,</span>
    <span class="c1">#   and bounding box bbox,</span>
    <span class="c1">#   get the vertices of the convex hull that formed.</span>
    <span class="c1"># Modified from https://stackoverflow.com/questions/65343771/solve-linear-inequalities</span>
    <span class="n">A_bounded</span><span class="p">,</span> <span class="n">b_bounded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__add_bbox</span><span class="p">(</span><span class="n">A_local</span><span class="p">,</span> <span class="n">b_local</span><span class="p">,</span> <span class="n">bbox</span><span class="p">)</span>
    <span class="n">feasible_point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__feasible_point_calc</span><span class="p">(</span><span class="n">A_bounded</span><span class="p">,</span> <span class="n">b_bounded</span><span class="p">)</span>
    <span class="n">hs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__hs_intersection</span><span class="p">(</span><span class="n">A_bounded</span><span class="p">,</span> <span class="n">b_bounded</span><span class="p">,</span> <span class="n">feasible_point</span><span class="p">)</span>
    <span class="c1"># hs = hs_intersection(A, b, interior_point)</span>
    <span class="n">points</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">intersections</span>
    <span class="n">hull</span> <span class="o">=</span> <span class="n">ConvexHull</span><span class="p">(</span><span class="n">points</span><span class="p">,</span><span class="n">qhull_options</span><span class="o">=</span><span class="s1">&#39;Q12&#39;</span><span class="p">)</span> <span class="c1"># to allow wide facets and dulbridge... meaning what???</span>
    <span class="k">return</span> <span class="n">points</span><span class="p">,</span><span class="n">points</span><span class="p">[</span><span class="n">hull</span><span class="o">.</span><span class="n">vertices</span><span class="p">],</span><span class="n">feasible_point</span><span class="p">,</span> <span class="n">hs</span>


  <span class="k">def</span><span class="w"> </span><span class="nf">vertex_hull_sampling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">nsample</span><span class="p">,</span><span class="n">chart</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">logmin</span><span class="o">=-</span><span class="mi">6</span><span class="p">,</span><span class="n">logmax</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span><span class="n">c_mat_extra</span><span class="o">=</span><span class="p">[],</span><span class="n">c0_vec_extra</span><span class="o">=</span><span class="p">[]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sample points in the vertex&#39;s region of validity based on its hull of feasible regions.</span>
<span class="sd">    Extra conditions (linear) can be added as c_mat_extra @ var + c0_vec_extra &gt;= 0.</span>

<span class="sd">    Args:</span>
<span class="sd">        nsample (int): Number of points to be sampled.</span>
<span class="sd">        chart (str, optional): A string indicating the chart that the opt_constraints are specified in.</span>
<span class="sd">            Choices are &#39;x&#39;,&#39;xak&#39;, and &#39;tk&#39;.</span>
<span class="sd">        margin (float, optional): The vertex&#39;s feasibility conditions are inequalities, </span>
<span class="sd">            of the form c_mat*x + c0_vec &gt;= margin (e.g., in &#39;x&#39; chart),</span>
<span class="sd">            where margin is the margin used here. Defaults to 0.</span>
<span class="sd">            This can be adjusted to be stronger/weaker requirements on dominance.</span>
<span class="sd">        logmin (float or ndarray vector): logmin, logmax could be scalars, then it&#39;s the same value applied to </span>
<span class="sd">            every variable. </span>
<span class="sd">            They could also be vectors of length dim_n.</span>
<span class="sd">        logmax (float or ndarray vector): logmin, logmax could be scalars, then it&#39;s the same value applied to </span>
<span class="sd">            every variable. </span>
<span class="sd">            They could also is vectors of length dim_n.</span>
<span class="sd">        c_mat_extra (ndarray, shape (n_constraints, n_var)): Extra optimization constraints to be added to feasibility conditions,</span>
<span class="sd">            in the form of c_mat_extra @ var + c0_vec_extra &gt;= 0.</span>
<span class="sd">        c0_vec_extra (numpy vector, shape (n_constraints,)): Extra optimization constraints to be added to feasibility conditions,</span>
<span class="sd">            in the form of c_mat_extra @ var + c0_vec_extra &gt;=0.</span>

<span class="sd">    Returns:</span>
<span class="sd">        sample (ndarray of shape nsample-by-dim_n): dim_n is number of species in the binding network.</span>
<span class="sd">            Sampled points satisfying the feasibility conditions of this vertex.</span>
<span class="sd">            Each row (sample[i,:]) is a sampled point.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># first compute the convex hull for this vertex&#39;s validity and get the vertex points.</span>
    <span class="n">points</span><span class="p">,</span><span class="n">hull</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">_</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex_hull_of_validity</span><span class="p">(</span><span class="n">chart</span><span class="o">=</span><span class="n">chart</span><span class="p">,</span><span class="n">margin</span><span class="o">=</span><span class="n">margin</span><span class="p">,</span><span class="n">logmin</span><span class="o">=</span><span class="n">logmin</span><span class="p">,</span><span class="n">logmax</span><span class="o">=</span><span class="n">logmax</span><span class="p">,</span><span class="n">c_mat_extra</span><span class="o">=</span><span class="n">c_mat_extra</span><span class="p">,</span><span class="n">c0_vec_extra</span><span class="o">=</span><span class="n">c0_vec_extra</span><span class="p">)</span>
    <span class="n">sample</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__dist_in_hull</span><span class="p">(</span><span class="n">points</span><span class="p">,</span><span class="n">nsample</span><span class="p">,</span><span class="n">points_are_vertices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1"># To sample a simplex in n-dim uniformly, take n uniform(0,1) random </span>
    <span class="c1">#   variables and take difference after padding 0 at the beginning and</span>
    <span class="c1">#   1 at the end. This gives a vector of n-dim in the simplex, with</span>
    <span class="c1">#   a probability density that is uniform in the simplex.</span>
    <span class="c1">#   See https://cs.stackexchange.com/questions/3227/uniform-sampling-from-a-simplex</span>
    <span class="c1"># ncoeffs=points.shape[0]</span>
    <span class="c1"># temp=np.sort(np.random.rand(nsample,ncoeffs-1),axis=1)</span>
    <span class="c1"># coeffs=np.diff(temp,prepend=0,append=1,axis=1)</span>
    <span class="c1"># sample=coeffs@points # this has shape nsample-by-dim_n</span>
    <span class="k">return</span> <span class="n">sample</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">__dist_in_hull</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">points</span><span class="p">,</span> <span class="n">nsample</span><span class="p">,</span> <span class="n">points_are_vertices</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create uniform sample over convex hulls by Delaunay triangulation.</span>
<span class="sd">    Adapted from https://stackoverflow.com/questions/59073952/how-to-get-uniformly-distributed-points-in-convex-hull</span>

<span class="sd">    Args:</span>
<span class="sd">        points (ndarray, shape (num_points, dim)): Points whose convex hull is to be sampled uniformly.</span>
<span class="sd">        nsample (int): Number of points to be sampled.</span>
<span class="sd">        points_are_vertices (bool, optional): If True, points are assumed to be vertices.</span>
<span class="sd">            If False, convex hull of points is first taken to find vertices.</span>
<span class="sd">            Defaults to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        sample (ndarray, shape (nsample, dim)): Sampled points uniformly in convex hull of points.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">points_are_vertices</span><span class="p">:</span>
      <span class="n">hull</span><span class="o">=</span><span class="n">points</span> 
    <span class="k">else</span><span class="p">:</span> 
      <span class="n">hull</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">ConvexHull</span><span class="p">(</span><span class="n">points</span><span class="p">,</span><span class="n">qhull_options</span><span class="o">=</span><span class="s1">&#39;Q12&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">vertices</span><span class="p">]</span>
    <span class="nb">breakpoint</span><span class="p">()</span>
    <span class="n">deln</span> <span class="o">=</span> <span class="n">hull</span><span class="p">[</span><span class="n">Delaunay</span><span class="p">(</span><span class="n">hull</span><span class="p">,</span><span class="n">qhull_options</span><span class="o">=</span><span class="s1">&#39;Q12&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">simplices</span><span class="p">]</span>
    <span class="n">vols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">deln</span><span class="p">[:,</span> <span class="p">:</span><span class="n">dims</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">deln</span><span class="p">[:,</span> <span class="n">dims</span><span class="p">:,</span> <span class="p">:]))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>    
    <span class="n">sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vols</span><span class="p">),</span> <span class="n">size</span> <span class="o">=</span> <span class="n">nsample</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">vols</span> <span class="o">/</span> <span class="n">vols</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijk, ij -&gt; ik&#39;</span><span class="p">,</span> <span class="n">deln</span><span class="p">[</span><span class="n">sample</span><span class="p">],</span> <span class="n">dirichlet</span><span class="o">.</span><span class="n">rvs</span><span class="p">([</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">dims</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">size</span> <span class="o">=</span> <span class="n">nsample</span><span class="p">))</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">vertex_print_validity_condition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">is_asymptotic</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Print the expression for t=x, x(t,k) and inequalities for the region of validity </span>
<span class="sd">    given a regime, using the labels of x, t, k.</span>

<span class="sd">    Args:</span>
<span class="sd">        is_asymptotic (bool, optional): If False, the inequalities are shown with intercept.</span>
<span class="sd">            If True, the inequalities are shown without intercept.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None: Prints a lot of text.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="n">c_mat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c_mat_tk</span>
      <span class="n">c0_vec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c0_vec_tk</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span> <span class="c1"># if c_mat_xak is not yet calculated</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">vertex_c_mat_tk_calc</span><span class="p">()</span>
      <span class="n">c_mat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c_mat_tk</span>
      <span class="n">c0_vec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c0_vec_tk</span>
    <span class="n">h_mat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">h_mat</span>
    <span class="n">h0_vec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">h0_vec</span>
    <span class="n">p0_vec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">p0_vec</span>
    <span class="n">perm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">perm</span>
    <span class="n">x_sym</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">.</span><span class="n">x_sym</span>
    <span class="n">tk_sym</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">.</span><span class="n">tk_sym</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;======This is vertex perm &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;======</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">t2x_list</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">.</span><span class="n">dim_d</span><span class="p">):</span>
      <span class="n">p0</span><span class="o">=</span><span class="n">p0_vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
      <span class="k">if</span> <span class="n">p0</span><span class="o">==</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">is_asymptotic</span><span class="p">:</span>
        <span class="n">t2x_list</span><span class="o">+=</span><span class="p">[</span><span class="n">tk_sym</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;=&#39;</span> <span class="o">+</span> <span class="n">x_sym</span><span class="p">[</span><span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">t2x_list</span><span class="o">+=</span><span class="p">[</span><span class="n">tk_sym</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;=&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">p0</span><span class="p">)</span> <span class="o">+</span> <span class="n">x_sym</span><span class="p">[</span><span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;(1) t in x: t is dominated by... </span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">t2x_list</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="c1"># BELOW we obtain x&#39;s expression in terms of t,k by</span>
    <span class="c1"># log(x) = h_mat * log(t,k) + h0_vec</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">orientation</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
      <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;(2) x in tk: Vertex is singular, cannot express (x) in (t,k).&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">x2tk_list</span><span class="o">=</span><span class="p">[]</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">.</span><span class="n">dim_n</span><span class="p">):</span>
        <span class="n">h_row</span><span class="o">=</span><span class="n">h_mat</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span>
        <span class="n">pos_idx</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">h_row</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">neg_idx</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">h_row</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">expr_pos</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">tk_sym</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;^&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">h_row</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="k">if</span> <span class="n">h_row</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">!=</span><span class="mf">1.0</span> <span class="k">else</span> <span class="n">tk_sym</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">pos_idx</span><span class="p">])</span>
        <span class="n">expr_neg</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">tk_sym</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;^&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="o">-</span><span class="n">h_row</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="k">if</span> <span class="o">-</span><span class="n">h_row</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">!=</span><span class="mf">1.0</span> <span class="k">else</span> <span class="n">tk_sym</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">neg_idx</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">neg_idx</span><span class="o">.</span><span class="n">size</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
          <span class="n">expr</span><span class="o">=</span><span class="n">expr_pos</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">expr</span><span class="o">=</span><span class="n">expr_pos</span> <span class="o">+</span> <span class="s1">&#39; / &#39;</span> <span class="o">+</span> <span class="n">expr_neg</span>
        <span class="n">h0</span><span class="o">=</span><span class="n">h0_vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">h0</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
          <span class="n">x2tk_list</span><span class="o">+=</span><span class="p">[</span><span class="n">x_sym</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39; = &#39;</span><span class="o">+</span> <span class="n">expr</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">x2tk_list</span><span class="o">+=</span><span class="p">[</span><span class="n">x_sym</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39; = &#39;</span> <span class="o">+</span> <span class="n">expr</span> <span class="o">+</span> <span class="s1">&#39; / &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="n">h0</span><span class="p">)]</span>
      <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;(2) x in tk: </span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="s1">&#39;,</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">x2tk_list</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>


    <span class="n">ineq_list</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">c_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
      <span class="n">c_row</span><span class="o">=</span><span class="n">c_mat</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span>
      <span class="n">pos_idx</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">c_row</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
      <span class="n">neg_idx</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">c_row</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
      <span class="n">expr_pos</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">tk_sym</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;^&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">c_row</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="k">if</span> <span class="n">c_row</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">!=</span><span class="mf">1.0</span> <span class="k">else</span> <span class="n">tk_sym</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">pos_idx</span><span class="p">])</span>
      <span class="n">expr_neg</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">tk_sym</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;^&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="o">-</span><span class="n">c_row</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="k">if</span> <span class="o">-</span><span class="n">c_row</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">!=</span><span class="mf">1.0</span> <span class="k">else</span> <span class="n">tk_sym</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">neg_idx</span><span class="p">])</span>
      <span class="n">c0</span><span class="o">=</span><span class="n">c0_vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
      <span class="k">if</span> <span class="n">c0</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">ineq_list</span><span class="o">+=</span><span class="p">[</span><span class="n">expr_pos</span> <span class="o">+</span> <span class="s1">&#39; &gt; &#39;</span> <span class="o">+</span> <span class="n">expr_neg</span><span class="p">]</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">ineq_list</span><span class="o">+=</span><span class="p">[</span><span class="n">expr_pos</span> <span class="o">+</span> <span class="s1">&#39; &gt; &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">c0</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">expr_neg</span><span class="p">]</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;(3) BELOW is constraints for regions of validity </span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="s1">&#39;,</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ineq_list</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h3 id="bcn.binding_network.rop_vertex.__dist_in_hull" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">__dist_in_hull</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">nsample</span><span class="p">,</span> <span class="n">points_are_vertices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Create uniform sample over convex hulls by Delaunay triangulation.
Adapted from https://stackoverflow.com/questions/59073952/how-to-get-uniformly-distributed-points-in-convex-hull</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>points</code>
            </td>
            <td>
                  <code>ndarray, shape (num_points, dim</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Points whose convex hull is to be sampled uniformly.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>nsample</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Number of points to be sampled.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>points_are_vertices</code>
            </td>
            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If True, points are assumed to be vertices.
If False, convex hull of points is first taken to find vertices.
Defaults to False.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>sample</code></td>            <td>
                  <code>(<span title="ndarray">ndarray</span>, <span title="shape">shape</span>(<span title="nsample">nsample</span>, <span title="dim">dim</span>))</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Sampled points uniformly in convex hull of points.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/bcn/binding_network.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">965</span>
<span class="normal">966</span>
<span class="normal">967</span>
<span class="normal">968</span>
<span class="normal">969</span>
<span class="normal">970</span>
<span class="normal">971</span>
<span class="normal">972</span>
<span class="normal">973</span>
<span class="normal">974</span>
<span class="normal">975</span>
<span class="normal">976</span>
<span class="normal">977</span>
<span class="normal">978</span>
<span class="normal">979</span>
<span class="normal">980</span>
<span class="normal">981</span>
<span class="normal">982</span>
<span class="normal">983</span>
<span class="normal">984</span>
<span class="normal">985</span>
<span class="normal">986</span>
<span class="normal">987</span>
<span class="normal">988</span>
<span class="normal">989</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">__dist_in_hull</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">points</span><span class="p">,</span> <span class="n">nsample</span><span class="p">,</span> <span class="n">points_are_vertices</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Create uniform sample over convex hulls by Delaunay triangulation.</span>
<span class="sd">  Adapted from https://stackoverflow.com/questions/59073952/how-to-get-uniformly-distributed-points-in-convex-hull</span>

<span class="sd">  Args:</span>
<span class="sd">      points (ndarray, shape (num_points, dim)): Points whose convex hull is to be sampled uniformly.</span>
<span class="sd">      nsample (int): Number of points to be sampled.</span>
<span class="sd">      points_are_vertices (bool, optional): If True, points are assumed to be vertices.</span>
<span class="sd">          If False, convex hull of points is first taken to find vertices.</span>
<span class="sd">          Defaults to False.</span>

<span class="sd">  Returns:</span>
<span class="sd">      sample (ndarray, shape (nsample, dim)): Sampled points uniformly in convex hull of points.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">dims</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
  <span class="k">if</span> <span class="n">points_are_vertices</span><span class="p">:</span>
    <span class="n">hull</span><span class="o">=</span><span class="n">points</span> 
  <span class="k">else</span><span class="p">:</span> 
    <span class="n">hull</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">ConvexHull</span><span class="p">(</span><span class="n">points</span><span class="p">,</span><span class="n">qhull_options</span><span class="o">=</span><span class="s1">&#39;Q12&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">vertices</span><span class="p">]</span>
  <span class="nb">breakpoint</span><span class="p">()</span>
  <span class="n">deln</span> <span class="o">=</span> <span class="n">hull</span><span class="p">[</span><span class="n">Delaunay</span><span class="p">(</span><span class="n">hull</span><span class="p">,</span><span class="n">qhull_options</span><span class="o">=</span><span class="s1">&#39;Q12&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">simplices</span><span class="p">]</span>
  <span class="n">vols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">deln</span><span class="p">[:,</span> <span class="p">:</span><span class="n">dims</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">deln</span><span class="p">[:,</span> <span class="n">dims</span><span class="p">:,</span> <span class="p">:]))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>    
  <span class="n">sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vols</span><span class="p">),</span> <span class="n">size</span> <span class="o">=</span> <span class="n">nsample</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">vols</span> <span class="o">/</span> <span class="n">vols</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
  <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijk, ij -&gt; ik&#39;</span><span class="p">,</span> <span class="n">deln</span><span class="p">[</span><span class="n">sample</span><span class="p">],</span> <span class="n">dirichlet</span><span class="o">.</span><span class="n">rvs</span><span class="p">([</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">dims</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">size</span> <span class="o">=</span> <span class="n">nsample</span><span class="p">))</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="bcn.binding_network.rop_vertex.__init__" class="doc doc-heading">
            <code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="n">perm</span><span class="p">,</span> <span class="n">bn</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Initiates a ROP vertex.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>perm</code>
            </td>
            <td>
                  <code>int tuple</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>An integer tuple of length dim_d, indicating for each conserved quantity, 
which species is dominant.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>bn</code>
            </td>
            <td>
                  <code>binding_network object</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The binding network that this vertex is a part of.
Used to get dimensions and stoichiometry matrix.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/bcn/binding_network.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">perm</span><span class="p">,</span><span class="n">bn</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Initiates a ROP vertex.</span>

<span class="sd">  Args:</span>
<span class="sd">      perm (int tuple): An integer tuple of length dim_d, indicating for each conserved quantity, </span>
<span class="sd">          which species is dominant.</span>
<span class="sd">      bn (binding_network object): The binding network that this vertex is a part of.</span>
<span class="sd">          Used to get dimensions and stoichiometry matrix.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">perm</span><span class="o">=</span><span class="n">perm</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">=</span><span class="n">bn</span>
  <span class="n">p_mat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">bn</span><span class="o">.</span><span class="n">dim_d</span><span class="p">,</span><span class="n">bn</span><span class="o">.</span><span class="n">dim_n</span><span class="p">))</span> <span class="c1"># p_mat is all 0 and 1</span>
  <span class="n">p0_vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">bn</span><span class="o">.</span><span class="n">dim_d</span><span class="p">)</span> <span class="c1"># the value of nonzero entries of l_mat chosen by p_mat in each row for this vertex</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bn</span><span class="o">.</span><span class="n">dim_d</span><span class="p">):</span>
    <span class="n">p_mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">=</span><span class="mi">1</span>
    <span class="n">p0_vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">bn</span><span class="o">.</span><span class="n">l_mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">p_mat</span><span class="o">=</span><span class="n">p_mat</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">p0_vec</span><span class="o">=</span><span class="n">p0_vec</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">m_mat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">p_mat</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">.</span><span class="n">n_mat</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">m0_vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">p0_vec</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">.</span><span class="n">dim_r</span><span class="p">)),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">orientation</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m_mat</span><span class="p">))</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">is_feasible</span><span class="o">=</span><span class="kc">True</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="bcn.binding_network.rop_vertex.chart_check" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">chart_check</span><span class="p">(</span><span class="n">chart</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Prepare the c_mat and c0_vec for the desired chart.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>chart</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A string indicating the chart that the opt_constraints are specified in.
Choices are 'x','xak', and 'tk'.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>c_mat</code></td>            <td>
                  <code>(<span title="ndarray">ndarray</span>, <span title="shape">shape</span>(<span title="n_constraints">n_constraints</span>, <span title="n_var">n_var</span>))</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Matrix used in this vertex's feasibility condition in the 
desired chart, e.g., it is c_mat * x + c0_vec &gt; 0 in chart 'x'.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
<td><code>c0_vec</code></td>            <td>
                  <code>(<span title="ndarray">ndarray</span>, <span title="shape">shape</span>(<span title="n_constraints">n_constraints</span>))</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The vector used in this vertex's feasibility condition in the
desired chart, e.g., it is c_mat * x + c0_vec &gt; 0 in chart 'x'.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/bcn/binding_network.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">763</span>
<span class="normal">764</span>
<span class="normal">765</span>
<span class="normal">766</span>
<span class="normal">767</span>
<span class="normal">768</span>
<span class="normal">769</span>
<span class="normal">770</span>
<span class="normal">771</span>
<span class="normal">772</span>
<span class="normal">773</span>
<span class="normal">774</span>
<span class="normal">775</span>
<span class="normal">776</span>
<span class="normal">777</span>
<span class="normal">778</span>
<span class="normal">779</span>
<span class="normal">780</span>
<span class="normal">781</span>
<span class="normal">782</span>
<span class="normal">783</span>
<span class="normal">784</span>
<span class="normal">785</span>
<span class="normal">786</span>
<span class="normal">787</span>
<span class="normal">788</span>
<span class="normal">789</span>
<span class="normal">790</span>
<span class="normal">791</span>
<span class="normal">792</span>
<span class="normal">793</span>
<span class="normal">794</span>
<span class="normal">795</span>
<span class="normal">796</span>
<span class="normal">797</span>
<span class="normal">798</span>
<span class="normal">799</span>
<span class="normal">800</span>
<span class="normal">801</span>
<span class="normal">802</span>
<span class="normal">803</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">chart_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">chart</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Prepare the c_mat and c0_vec for the desired chart.</span>

<span class="sd">  Args:</span>
<span class="sd">      chart (str, optional): A string indicating the chart that the opt_constraints are specified in.</span>
<span class="sd">          Choices are &#39;x&#39;,&#39;xak&#39;, and &#39;tk&#39;.</span>

<span class="sd">  Returns:</span>
<span class="sd">      c_mat (ndarray, shape (n_constraints, n_var)): Matrix used in this vertex&#39;s feasibility condition in the </span>
<span class="sd">          desired chart, e.g., it is c_mat * x + c0_vec &gt; 0 in chart &#39;x&#39;.</span>
<span class="sd">      c0_vec (ndarray, shape (n_constraints,)): The vector used in this vertex&#39;s feasibility condition in the</span>
<span class="sd">          desired chart, e.g., it is c_mat * x + c0_vec &gt; 0 in chart &#39;x&#39;.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="n">chart</span><span class="o">==</span><span class="s1">&#39;x&#39;</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="n">c_mat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c_mat_x</span>
      <span class="n">c0_vec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c0_vec</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span> <span class="c1"># if c_mat_x is not yet calculated</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">vertex_c_mat_x_calc</span><span class="p">()</span>
      <span class="n">c_mat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c_mat_x</span>
      <span class="n">c0_vec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c0_vec</span>
  <span class="k">elif</span> <span class="n">chart</span><span class="o">==</span><span class="s1">&#39;xak&#39;</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="n">c_mat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c_mat_xak</span>
      <span class="n">c0_vec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c0_vec</span> <span class="c1">#c0_vec is the same for chart x and xak.</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span> <span class="c1"># if c_mat_xak is not yet calculated</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">vertex_c_mat_xak_calc</span><span class="p">()</span>
      <span class="n">c_mat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c_mat_xak</span>
      <span class="n">c0_vec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c0_vec</span>
  <span class="k">elif</span> <span class="n">chart</span><span class="o">==</span><span class="s1">&#39;tk&#39;</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="n">c_mat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c_mat_tk</span>
      <span class="n">c0_vec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c0_vec_tk</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span> <span class="c1"># if c_mat_xak is not yet calculated</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">vertex_c_mat_tk_calc</span><span class="p">()</span>
      <span class="n">c_mat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c_mat_tk</span>
      <span class="n">c0_vec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c0_vec_tk</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;chart that is not one of x,xak or tk is not implemented yet&#39;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">c_mat</span><span class="p">,</span><span class="n">c0_vec</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="bcn.binding_network.rop_vertex.j_func" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">j_func</span><span class="p">(</span><span class="n">p_mat</span><span class="p">,</span> <span class="n">l_mat</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>For p_mat and l_mat, find (column) indices that are nonzero in each row of
l_mat but not nonzero in p_mat.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>p_mat</code>
            </td>
            <td>
                  <code>numpy array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>d-by-n matrix, each row has only one nonzero entry that is 1.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>l_mat</code>
            </td>
            <td>
                  <code>numpy array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>d-by-n matrix, binding network's conservation law matrix.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>j_list</code></td>            <td>
                  <code>list of int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>List of (column) indices that are nonzero in l_mat but zero in p_mat.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/bcn/binding_network.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span>
<span class="normal">609</span>
<span class="normal">610</span>
<span class="normal">611</span>
<span class="normal">612</span>
<span class="normal">613</span>
<span class="normal">614</span>
<span class="normal">615</span>
<span class="normal">616</span>
<span class="normal">617</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">j_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">p_mat</span><span class="p">,</span><span class="n">l_mat</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  For p_mat and l_mat, find (column) indices that are nonzero in each row of</span>
<span class="sd">  l_mat but not nonzero in p_mat.</span>

<span class="sd">  Args:</span>
<span class="sd">      p_mat (numpy array): d-by-n matrix, each row has only one nonzero entry that is 1.</span>
<span class="sd">      l_mat (numpy array): d-by-n matrix, binding network&#39;s conservation law matrix.</span>

<span class="sd">  Returns:</span>
<span class="sd">      j_list (list of int): List of (column) indices that are nonzero in l_mat but zero in p_mat.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">j_list</span><span class="o">=</span><span class="p">[]</span>
  <span class="n">l_mat_masked</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">l_mat</span><span class="p">,</span><span class="n">mask</span><span class="o">=</span><span class="n">p_mat</span><span class="p">)</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
    <span class="n">j_list</span><span class="o">+=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">l_mat_masked</span><span class="p">[</span><span class="n">i</span><span class="p">,:])[</span><span class="mi">0</span><span class="p">]]</span>
  <span class="k">return</span> <span class="n">j_list</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="bcn.binding_network.rop_vertex.vertex_feasibility_test" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">vertex_feasibility_test</span><span class="p">(</span><span class="n">chart</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">opt_constraints</span><span class="o">=</span><span class="p">[],</span> <span class="n">positive_threshold</span><span class="o">=</span><span class="mf">1e-05</span><span class="p">,</span> <span class="n">is_asymptotic</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>For given constraints, compute whether this vertex is feasible.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>chart</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A string indicating the chart that the opt_constraints are specified in.
Choices are 'x','xak', and 'tk'.</p>
              </div>
            </td>
            <td>
                  <code>&#39;x&#39;</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>opt_constraints</code>
            </td>
            <td>
                  <code>list of cvxpy inequalities</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A list of optimization constraints specified in terms of inequalities
relating cvxpy variables of the binding network.</p>
              </div>
            </td>
            <td>
                  <code>[]</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>positive_threshold</code>
            </td>
            <td>
                  <code><span title="float">float</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The vertex itself has inequality conditions, of the form c_mat*x + c0_vec &gt; th,
where th is the positive threshold used here. Defaults to 1e-5.</p>
              </div>
            </td>
            <td>
                  <code>1e-05</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>is_asymptotic</code>
            </td>
            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether the inequalities of the vertex itself should be considered asymptotically
or exactly. If asymptotically, then the inequality tested omits c0_vec,
so it is c_mat*x &gt; th. is_asymptotic=True corresponds to inequality satisfied
for the positive projective measure (where a ray is an infinitesimal of volume),
and is_asymptotic=False is Lebesgue measure (a point is an infinitesimal of volume).</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>is_feasible</code></td>            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether this vertex is feasible under the constraints.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/bcn/binding_network.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">619</span>
<span class="normal">620</span>
<span class="normal">621</span>
<span class="normal">622</span>
<span class="normal">623</span>
<span class="normal">624</span>
<span class="normal">625</span>
<span class="normal">626</span>
<span class="normal">627</span>
<span class="normal">628</span>
<span class="normal">629</span>
<span class="normal">630</span>
<span class="normal">631</span>
<span class="normal">632</span>
<span class="normal">633</span>
<span class="normal">634</span>
<span class="normal">635</span>
<span class="normal">636</span>
<span class="normal">637</span>
<span class="normal">638</span>
<span class="normal">639</span>
<span class="normal">640</span>
<span class="normal">641</span>
<span class="normal">642</span>
<span class="normal">643</span>
<span class="normal">644</span>
<span class="normal">645</span>
<span class="normal">646</span>
<span class="normal">647</span>
<span class="normal">648</span>
<span class="normal">649</span>
<span class="normal">650</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">vertex_feasibility_test</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">chart</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="n">opt_constraints</span><span class="o">=</span><span class="p">[],</span><span class="n">positive_threshold</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span><span class="n">is_asymptotic</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  For given constraints, compute whether this vertex is feasible.</span>

<span class="sd">  Args:</span>
<span class="sd">      chart (str, optional): A string indicating the chart that the opt_constraints are specified in.</span>
<span class="sd">          Choices are &#39;x&#39;,&#39;xak&#39;, and &#39;tk&#39;.</span>
<span class="sd">      opt_constraints (list of cvxpy inequalities, optional): A list of optimization constraints specified in terms of inequalities</span>
<span class="sd">          relating cvxpy variables of the binding network.</span>
<span class="sd">      positive_threshold (float, optional): The vertex itself has inequality conditions, of the form c_mat*x + c0_vec &gt; th,</span>
<span class="sd">          where th is the positive threshold used here. Defaults to 1e-5.</span>
<span class="sd">      is_asymptotic (bool, optional): Whether the inequalities of the vertex itself should be considered asymptotically</span>
<span class="sd">          or exactly. If asymptotically, then the inequality tested omits c0_vec,</span>
<span class="sd">          so it is c_mat*x &gt; th. is_asymptotic=True corresponds to inequality satisfied</span>
<span class="sd">          for the positive projective measure (where a ray is an infinitesimal of volume),</span>
<span class="sd">          and is_asymptotic=False is Lebesgue measure (a point is an infinitesimal of volume).</span>

<span class="sd">  Returns:</span>
<span class="sd">      is_feasible (bool): Whether this vertex is feasible under the constraints.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="c1"># first prepare the c_mat and c0_vec for the desired chart.</span>
  <span class="n">c_mat</span><span class="p">,</span><span class="n">c0_vec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">chart_check</span><span class="p">(</span><span class="n">chart</span><span class="p">)</span>
  <span class="n">is_feasible</span><span class="o">=</span><span class="kc">True</span>
  <span class="n">opt_var</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">.</span><span class="n">opt_var</span> <span class="c1">#opt_var came from the binding network.</span>
  <span class="k">if</span> <span class="n">is_asymptotic</span><span class="p">:</span> <span class="c1">#if asymptotic, c0_vec is zero.</span>
    <span class="n">prob</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">Problem</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">Minimize</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">opt_constraints</span><span class="o">+</span><span class="p">[</span><span class="n">c_mat</span> <span class="o">@</span> <span class="n">opt_var</span> <span class="o">&gt;=</span> <span class="n">positive_threshold</span><span class="p">])</span>
  <span class="k">else</span><span class="p">:</span> <span class="c1"># if not asymptotic, it is exact, so c0_vec is taken into account.</span>
    <span class="n">prob</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">Problem</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">Minimize</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">opt_constraints</span><span class="o">+</span><span class="p">[</span><span class="n">c_mat</span> <span class="o">@</span> <span class="n">opt_var</span> <span class="o">+</span> <span class="n">c0_vec</span> <span class="o">&gt;=</span> <span class="n">positive_threshold</span><span class="p">])</span>
  <span class="n">prob</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
  <span class="k">if</span> <span class="n">prob</span><span class="o">.</span><span class="n">status</span><span class="o">==</span><span class="s1">&#39;infeasible&#39;</span><span class="p">:</span>
    <span class="n">is_feasible</span><span class="o">=</span><span class="kc">False</span>
  <span class="k">return</span> <span class="n">is_feasible</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="bcn.binding_network.rop_vertex.vertex_hull_of_validity" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">vertex_hull_of_validity</span><span class="p">(</span><span class="n">chart</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">logmin</span><span class="o">=-</span><span class="mi">6</span><span class="p">,</span> <span class="n">logmax</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">c_mat_extra</span><span class="o">=</span><span class="p">[],</span> <span class="n">c0_vec_extra</span><span class="o">=</span><span class="p">[])</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Compute the vertices of the validity region as a bounded convex hull.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>chart</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A string indicating the chart that the opt_constraints are specified in.
Choices are 'x','xak', and 'tk'.</p>
              </div>
            </td>
            <td>
                  <code>&#39;x&#39;</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>margin</code>
            </td>
            <td>
                  <code><span title="float">float</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The vertex's feasibility conditions are inequalities, 
of the form c_mat*x + c0_vec &gt;= margin (e.g., in 'x' chart),
Margin defaults to 0, and its values are in log10.
This can be adjusted to be stronger/weaker requirements on dominance.</p>
              </div>
            </td>
            <td>
                  <code>0</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>logmin</code>
            </td>
            <td>
                  <code>float or ndarray vector</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>logmin, logmax could be scalars, then it's the same value applied to 
every variable. 
They could also be vectors of length dim_n.</p>
              </div>
            </td>
            <td>
                  <code>-6</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>logmax</code>
            </td>
            <td>
                  <code>float or ndarray vector</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>logmin, logmax could be scalars, then it's the same value applied to 
every variable. 
They could also be vectors of length dim_n.</p>
              </div>
            </td>
            <td>
                  <code>6</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>c_mat_extra</code>
            </td>
            <td>
                  <code>ndarray, shape (n_constraints, n_var</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Extra optimization constraints to be added to feasibility conditions,
in the form of c_mat_extra @ var + c0_vec_extra &gt;= 0.</p>
              </div>
            </td>
            <td>
                  <code>[]</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>c0_vec_extra</code>
            </td>
            <td>
                  <code>numpy vector, shape (n_constraints,</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Extra optimization constraints to be added to feasibility conditions,
in the form of c_mat_extra @ var + c0_vec_extra &gt;=0.</p>
              </div>
            </td>
            <td>
                  <code>[]</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>points</code></td>            <td>
                  <code><span title="ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The points corresponding to vertices of the convex hull that is the 
region of validity.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
<td><code>feasible_point</code></td>            <td>
                  <code>ndarray vector</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The point that is feasible in the interior of the convex hull.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
<td><code>hs</code></td>            <td>
                  <code><span title="scipy.spatial.HalfspaceIntersection">HalfspaceIntersection</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The half space intersection built from the feasibility inequalities.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/bcn/binding_network.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">805</span>
<span class="normal">806</span>
<span class="normal">807</span>
<span class="normal">808</span>
<span class="normal">809</span>
<span class="normal">810</span>
<span class="normal">811</span>
<span class="normal">812</span>
<span class="normal">813</span>
<span class="normal">814</span>
<span class="normal">815</span>
<span class="normal">816</span>
<span class="normal">817</span>
<span class="normal">818</span>
<span class="normal">819</span>
<span class="normal">820</span>
<span class="normal">821</span>
<span class="normal">822</span>
<span class="normal">823</span>
<span class="normal">824</span>
<span class="normal">825</span>
<span class="normal">826</span>
<span class="normal">827</span>
<span class="normal">828</span>
<span class="normal">829</span>
<span class="normal">830</span>
<span class="normal">831</span>
<span class="normal">832</span>
<span class="normal">833</span>
<span class="normal">834</span>
<span class="normal">835</span>
<span class="normal">836</span>
<span class="normal">837</span>
<span class="normal">838</span>
<span class="normal">839</span>
<span class="normal">840</span>
<span class="normal">841</span>
<span class="normal">842</span>
<span class="normal">843</span>
<span class="normal">844</span>
<span class="normal">845</span>
<span class="normal">846</span>
<span class="normal">847</span>
<span class="normal">848</span>
<span class="normal">849</span>
<span class="normal">850</span>
<span class="normal">851</span>
<span class="normal">852</span>
<span class="normal">853</span>
<span class="normal">854</span>
<span class="normal">855</span>
<span class="normal">856</span>
<span class="normal">857</span>
<span class="normal">858</span>
<span class="normal">859</span>
<span class="normal">860</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">vertex_hull_of_validity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">chart</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="n">margin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">logmin</span><span class="o">=-</span><span class="mi">6</span><span class="p">,</span><span class="n">logmax</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span><span class="n">c_mat_extra</span><span class="o">=</span><span class="p">[],</span><span class="n">c0_vec_extra</span><span class="o">=</span><span class="p">[]):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Compute the vertices of the validity region as a bounded convex hull.</span>

<span class="sd">  Args:</span>
<span class="sd">      chart (str, optional): A string indicating the chart that the opt_constraints are specified in.</span>
<span class="sd">          Choices are &#39;x&#39;,&#39;xak&#39;, and &#39;tk&#39;.</span>
<span class="sd">      margin (float, optional): The vertex&#39;s feasibility conditions are inequalities, </span>
<span class="sd">          of the form c_mat*x + c0_vec &gt;= margin (e.g., in &#39;x&#39; chart),</span>
<span class="sd">          Margin defaults to 0, and its values are in log10.</span>
<span class="sd">          This can be adjusted to be stronger/weaker requirements on dominance.</span>
<span class="sd">      logmin (float or ndarray vector): logmin, logmax could be scalars, then it&#39;s the same value applied to </span>
<span class="sd">          every variable. </span>
<span class="sd">          They could also be vectors of length dim_n.</span>
<span class="sd">      logmax (float or ndarray vector): logmin, logmax could be scalars, then it&#39;s the same value applied to </span>
<span class="sd">          every variable. </span>
<span class="sd">          They could also be vectors of length dim_n.</span>
<span class="sd">      c_mat_extra (ndarray, shape (n_constraints, n_var)): Extra optimization constraints to be added to feasibility conditions,</span>
<span class="sd">          in the form of c_mat_extra @ var + c0_vec_extra &gt;= 0.</span>
<span class="sd">      c0_vec_extra (numpy vector, shape (n_constraints,)): Extra optimization constraints to be added to feasibility conditions,</span>
<span class="sd">          in the form of c_mat_extra @ var + c0_vec_extra &gt;=0.</span>

<span class="sd">  Returns:</span>
<span class="sd">      points (ndarray): The points corresponding to vertices of the convex hull that is the </span>
<span class="sd">          region of validity.</span>
<span class="sd">      feasible_point (ndarray vector): The point that is feasible in the interior of the convex hull.</span>
<span class="sd">      hs (scipy.spatial.HalfspaceIntersection): The half space intersection built from the feasibility inequalities.</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="c1"># first check whether logmin and logmax are scalars or vectors.</span>
  <span class="k">try</span><span class="p">:</span> 
    <span class="nb">float</span><span class="p">(</span><span class="n">logmin</span><span class="p">)</span> <span class="c1"># if logmin and logmax are scalars</span>
    <span class="n">bbox</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">logmin</span><span class="p">,</span><span class="n">logmax</span><span class="p">]]),</span><span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">.</span><span class="n">dim_n</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1">#bounding box to make polyhedra bounded</span>
  <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span> <span class="c1"># if logmin and logmax are vectors</span>
    <span class="c1"># stack them horizontally as column vectors</span>
    <span class="n">bbox</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">logmin</span><span class="p">[:,</span><span class="kc">None</span><span class="p">],</span><span class="n">logmax</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]))</span>

  <span class="n">c_mat</span><span class="p">,</span><span class="n">c0_vec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">chart_check</span><span class="p">(</span><span class="n">chart</span><span class="p">)</span>

  <span class="c1"># the inequality c_mat*var + c0_vec - margin &gt;= 0, becomes A*var + b &lt;=0</span>
  <span class="c1"># where A = -c_mat, and b = th - c0_vec.</span>
  <span class="c1"># With extra constraints, margin is always 0 for extra constraints,</span>
  <span class="c1"># so margin_full = vstack((margin,zeros)) where zeros is of length len(c0_vec_extra)</span>
  <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">c_mat_extra</span><span class="p">):</span> <span class="c1"># if there are additional constraints</span>
    <span class="n">c_mat_full</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">c_mat</span><span class="p">,</span><span class="n">c_mat_extra</span><span class="p">))</span>
    <span class="n">c0_vec_full</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">c0_vec</span><span class="p">,</span><span class="n">c0_vec_extra</span><span class="p">))</span>
    <span class="n">margin_vec_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">margin</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">c0_vec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">c0_vec_extra</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
  <span class="k">else</span><span class="p">:</span> <span class="c1"># there are no additional constraints</span>
    <span class="n">c_mat_full</span><span class="o">=</span><span class="n">c_mat</span> 
    <span class="n">c0_vec_full</span> <span class="o">=</span> <span class="n">c0_vec</span>
    <span class="n">margin_vec_full</span> <span class="o">=</span> <span class="n">margin</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">c0_vec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
  <span class="n">A</span><span class="o">=-</span><span class="n">c_mat_full</span> <span class="c1"># negtive because the optimization code is for Ax+b&lt;=0, while our notation is c_mat*x+c0_vec &gt;=0.</span>
  <span class="n">b</span><span class="o">=</span><span class="n">margin_vec_full</span> <span class="o">-</span> <span class="n">c0_vec_full</span>

  <span class="n">points</span><span class="p">,</span> <span class="n">hull</span><span class="p">,</span> <span class="n">feasible_point</span><span class="p">,</span> <span class="n">hs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_convex_hull</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">bbox</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">points</span><span class="p">,</span> <span class="n">hull</span><span class="p">,</span> <span class="n">feasible_point</span><span class="p">,</span><span class="n">hs</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="bcn.binding_network.rop_vertex.vertex_hull_sampling" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">vertex_hull_sampling</span><span class="p">(</span><span class="n">nsample</span><span class="p">,</span> <span class="n">chart</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">logmin</span><span class="o">=-</span><span class="mi">6</span><span class="p">,</span> <span class="n">logmax</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">c_mat_extra</span><span class="o">=</span><span class="p">[],</span> <span class="n">c0_vec_extra</span><span class="o">=</span><span class="p">[])</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Sample points in the vertex's region of validity based on its hull of feasible regions.
Extra conditions (linear) can be added as c_mat_extra @ var + c0_vec_extra &gt;= 0.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>nsample</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Number of points to be sampled.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>chart</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A string indicating the chart that the opt_constraints are specified in.
Choices are 'x','xak', and 'tk'.</p>
              </div>
            </td>
            <td>
                  <code>&#39;x&#39;</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>margin</code>
            </td>
            <td>
                  <code><span title="float">float</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The vertex's feasibility conditions are inequalities, 
of the form c_mat*x + c0_vec &gt;= margin (e.g., in 'x' chart),
where margin is the margin used here. Defaults to 0.
This can be adjusted to be stronger/weaker requirements on dominance.</p>
              </div>
            </td>
            <td>
                  <code>0</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>logmin</code>
            </td>
            <td>
                  <code>float or ndarray vector</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>logmin, logmax could be scalars, then it's the same value applied to 
every variable. 
They could also be vectors of length dim_n.</p>
              </div>
            </td>
            <td>
                  <code>-6</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>logmax</code>
            </td>
            <td>
                  <code>float or ndarray vector</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>logmin, logmax could be scalars, then it's the same value applied to 
every variable. 
They could also is vectors of length dim_n.</p>
              </div>
            </td>
            <td>
                  <code>6</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>c_mat_extra</code>
            </td>
            <td>
                  <code>ndarray, shape (n_constraints, n_var</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Extra optimization constraints to be added to feasibility conditions,
in the form of c_mat_extra @ var + c0_vec_extra &gt;= 0.</p>
              </div>
            </td>
            <td>
                  <code>[]</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>c0_vec_extra</code>
            </td>
            <td>
                  <code>numpy vector, shape (n_constraints,</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Extra optimization constraints to be added to feasibility conditions,
in the form of c_mat_extra @ var + c0_vec_extra &gt;=0.</p>
              </div>
            </td>
            <td>
                  <code>[]</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>sample</code></td>            <td>
                  <code>ndarray of shape nsample-by-dim_n</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>dim_n is number of species in the binding network.
Sampled points satisfying the feasibility conditions of this vertex.
Each row (sample[i,:]) is a sampled point.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/bcn/binding_network.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">922</span>
<span class="normal">923</span>
<span class="normal">924</span>
<span class="normal">925</span>
<span class="normal">926</span>
<span class="normal">927</span>
<span class="normal">928</span>
<span class="normal">929</span>
<span class="normal">930</span>
<span class="normal">931</span>
<span class="normal">932</span>
<span class="normal">933</span>
<span class="normal">934</span>
<span class="normal">935</span>
<span class="normal">936</span>
<span class="normal">937</span>
<span class="normal">938</span>
<span class="normal">939</span>
<span class="normal">940</span>
<span class="normal">941</span>
<span class="normal">942</span>
<span class="normal">943</span>
<span class="normal">944</span>
<span class="normal">945</span>
<span class="normal">946</span>
<span class="normal">947</span>
<span class="normal">948</span>
<span class="normal">949</span>
<span class="normal">950</span>
<span class="normal">951</span>
<span class="normal">952</span>
<span class="normal">953</span>
<span class="normal">954</span>
<span class="normal">955</span>
<span class="normal">956</span>
<span class="normal">957</span>
<span class="normal">958</span>
<span class="normal">959</span>
<span class="normal">960</span>
<span class="normal">961</span>
<span class="normal">962</span>
<span class="normal">963</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">vertex_hull_sampling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">nsample</span><span class="p">,</span><span class="n">chart</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">logmin</span><span class="o">=-</span><span class="mi">6</span><span class="p">,</span><span class="n">logmax</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span><span class="n">c_mat_extra</span><span class="o">=</span><span class="p">[],</span><span class="n">c0_vec_extra</span><span class="o">=</span><span class="p">[]):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Sample points in the vertex&#39;s region of validity based on its hull of feasible regions.</span>
<span class="sd">  Extra conditions (linear) can be added as c_mat_extra @ var + c0_vec_extra &gt;= 0.</span>

<span class="sd">  Args:</span>
<span class="sd">      nsample (int): Number of points to be sampled.</span>
<span class="sd">      chart (str, optional): A string indicating the chart that the opt_constraints are specified in.</span>
<span class="sd">          Choices are &#39;x&#39;,&#39;xak&#39;, and &#39;tk&#39;.</span>
<span class="sd">      margin (float, optional): The vertex&#39;s feasibility conditions are inequalities, </span>
<span class="sd">          of the form c_mat*x + c0_vec &gt;= margin (e.g., in &#39;x&#39; chart),</span>
<span class="sd">          where margin is the margin used here. Defaults to 0.</span>
<span class="sd">          This can be adjusted to be stronger/weaker requirements on dominance.</span>
<span class="sd">      logmin (float or ndarray vector): logmin, logmax could be scalars, then it&#39;s the same value applied to </span>
<span class="sd">          every variable. </span>
<span class="sd">          They could also be vectors of length dim_n.</span>
<span class="sd">      logmax (float or ndarray vector): logmin, logmax could be scalars, then it&#39;s the same value applied to </span>
<span class="sd">          every variable. </span>
<span class="sd">          They could also is vectors of length dim_n.</span>
<span class="sd">      c_mat_extra (ndarray, shape (n_constraints, n_var)): Extra optimization constraints to be added to feasibility conditions,</span>
<span class="sd">          in the form of c_mat_extra @ var + c0_vec_extra &gt;= 0.</span>
<span class="sd">      c0_vec_extra (numpy vector, shape (n_constraints,)): Extra optimization constraints to be added to feasibility conditions,</span>
<span class="sd">          in the form of c_mat_extra @ var + c0_vec_extra &gt;=0.</span>

<span class="sd">  Returns:</span>
<span class="sd">      sample (ndarray of shape nsample-by-dim_n): dim_n is number of species in the binding network.</span>
<span class="sd">          Sampled points satisfying the feasibility conditions of this vertex.</span>
<span class="sd">          Each row (sample[i,:]) is a sampled point.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="c1"># first compute the convex hull for this vertex&#39;s validity and get the vertex points.</span>
  <span class="n">points</span><span class="p">,</span><span class="n">hull</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">_</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vertex_hull_of_validity</span><span class="p">(</span><span class="n">chart</span><span class="o">=</span><span class="n">chart</span><span class="p">,</span><span class="n">margin</span><span class="o">=</span><span class="n">margin</span><span class="p">,</span><span class="n">logmin</span><span class="o">=</span><span class="n">logmin</span><span class="p">,</span><span class="n">logmax</span><span class="o">=</span><span class="n">logmax</span><span class="p">,</span><span class="n">c_mat_extra</span><span class="o">=</span><span class="n">c_mat_extra</span><span class="p">,</span><span class="n">c0_vec_extra</span><span class="o">=</span><span class="n">c0_vec_extra</span><span class="p">)</span>
  <span class="n">sample</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__dist_in_hull</span><span class="p">(</span><span class="n">points</span><span class="p">,</span><span class="n">nsample</span><span class="p">,</span><span class="n">points_are_vertices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
  <span class="c1"># To sample a simplex in n-dim uniformly, take n uniform(0,1) random </span>
  <span class="c1">#   variables and take difference after padding 0 at the beginning and</span>
  <span class="c1">#   1 at the end. This gives a vector of n-dim in the simplex, with</span>
  <span class="c1">#   a probability density that is uniform in the simplex.</span>
  <span class="c1">#   See https://cs.stackexchange.com/questions/3227/uniform-sampling-from-a-simplex</span>
  <span class="c1"># ncoeffs=points.shape[0]</span>
  <span class="c1"># temp=np.sort(np.random.rand(nsample,ncoeffs-1),axis=1)</span>
  <span class="c1"># coeffs=np.diff(temp,prepend=0,append=1,axis=1)</span>
  <span class="c1"># sample=coeffs@points # this has shape nsample-by-dim_n</span>
  <span class="k">return</span> <span class="n">sample</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="bcn.binding_network.rop_vertex.vertex_print_validity_condition" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">vertex_print_validity_condition</span><span class="p">(</span><span class="n">is_asymptotic</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Print the expression for t=x, x(t,k) and inequalities for the region of validity 
given a regime, using the labels of x, t, k.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>is_asymptotic</code>
            </td>
            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If False, the inequalities are shown with intercept.
If True, the inequalities are shown without intercept.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>None</code></td>            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Prints a lot of text.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/bcn/binding_network.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 991</span>
<span class="normal"> 992</span>
<span class="normal"> 993</span>
<span class="normal"> 994</span>
<span class="normal"> 995</span>
<span class="normal"> 996</span>
<span class="normal"> 997</span>
<span class="normal"> 998</span>
<span class="normal"> 999</span>
<span class="normal">1000</span>
<span class="normal">1001</span>
<span class="normal">1002</span>
<span class="normal">1003</span>
<span class="normal">1004</span>
<span class="normal">1005</span>
<span class="normal">1006</span>
<span class="normal">1007</span>
<span class="normal">1008</span>
<span class="normal">1009</span>
<span class="normal">1010</span>
<span class="normal">1011</span>
<span class="normal">1012</span>
<span class="normal">1013</span>
<span class="normal">1014</span>
<span class="normal">1015</span>
<span class="normal">1016</span>
<span class="normal">1017</span>
<span class="normal">1018</span>
<span class="normal">1019</span>
<span class="normal">1020</span>
<span class="normal">1021</span>
<span class="normal">1022</span>
<span class="normal">1023</span>
<span class="normal">1024</span>
<span class="normal">1025</span>
<span class="normal">1026</span>
<span class="normal">1027</span>
<span class="normal">1028</span>
<span class="normal">1029</span>
<span class="normal">1030</span>
<span class="normal">1031</span>
<span class="normal">1032</span>
<span class="normal">1033</span>
<span class="normal">1034</span>
<span class="normal">1035</span>
<span class="normal">1036</span>
<span class="normal">1037</span>
<span class="normal">1038</span>
<span class="normal">1039</span>
<span class="normal">1040</span>
<span class="normal">1041</span>
<span class="normal">1042</span>
<span class="normal">1043</span>
<span class="normal">1044</span>
<span class="normal">1045</span>
<span class="normal">1046</span>
<span class="normal">1047</span>
<span class="normal">1048</span>
<span class="normal">1049</span>
<span class="normal">1050</span>
<span class="normal">1051</span>
<span class="normal">1052</span>
<span class="normal">1053</span>
<span class="normal">1054</span>
<span class="normal">1055</span>
<span class="normal">1056</span>
<span class="normal">1057</span>
<span class="normal">1058</span>
<span class="normal">1059</span>
<span class="normal">1060</span>
<span class="normal">1061</span>
<span class="normal">1062</span>
<span class="normal">1063</span>
<span class="normal">1064</span>
<span class="normal">1065</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">vertex_print_validity_condition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">is_asymptotic</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Print the expression for t=x, x(t,k) and inequalities for the region of validity </span>
<span class="sd">  given a regime, using the labels of x, t, k.</span>

<span class="sd">  Args:</span>
<span class="sd">      is_asymptotic (bool, optional): If False, the inequalities are shown with intercept.</span>
<span class="sd">          If True, the inequalities are shown without intercept.</span>

<span class="sd">  Returns:</span>
<span class="sd">      None: Prints a lot of text.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="n">c_mat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c_mat_tk</span>
    <span class="n">c0_vec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c0_vec_tk</span>
  <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span> <span class="c1"># if c_mat_xak is not yet calculated</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">vertex_c_mat_tk_calc</span><span class="p">()</span>
    <span class="n">c_mat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c_mat_tk</span>
    <span class="n">c0_vec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c0_vec_tk</span>
  <span class="n">h_mat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">h_mat</span>
  <span class="n">h0_vec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">h0_vec</span>
  <span class="n">p0_vec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">p0_vec</span>
  <span class="n">perm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">perm</span>
  <span class="n">x_sym</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">.</span><span class="n">x_sym</span>
  <span class="n">tk_sym</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">.</span><span class="n">tk_sym</span>

  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;======This is vertex perm &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;======</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
  <span class="n">t2x_list</span><span class="o">=</span><span class="p">[]</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">.</span><span class="n">dim_d</span><span class="p">):</span>
    <span class="n">p0</span><span class="o">=</span><span class="n">p0_vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">p0</span><span class="o">==</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">is_asymptotic</span><span class="p">:</span>
      <span class="n">t2x_list</span><span class="o">+=</span><span class="p">[</span><span class="n">tk_sym</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;=&#39;</span> <span class="o">+</span> <span class="n">x_sym</span><span class="p">[</span><span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">t2x_list</span><span class="o">+=</span><span class="p">[</span><span class="n">tk_sym</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;=&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">p0</span><span class="p">)</span> <span class="o">+</span> <span class="n">x_sym</span><span class="p">[</span><span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;(1) t in x: t is dominated by... </span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">t2x_list</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

  <span class="c1"># BELOW we obtain x&#39;s expression in terms of t,k by</span>
  <span class="c1"># log(x) = h_mat * log(t,k) + h0_vec</span>

  <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">orientation</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;(2) x in tk: Vertex is singular, cannot express (x) in (t,k).&#39;</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">x2tk_list</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">.</span><span class="n">dim_n</span><span class="p">):</span>
      <span class="n">h_row</span><span class="o">=</span><span class="n">h_mat</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span>
      <span class="n">pos_idx</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">h_row</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
      <span class="n">neg_idx</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">h_row</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
      <span class="n">expr_pos</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">tk_sym</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;^&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">h_row</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="k">if</span> <span class="n">h_row</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">!=</span><span class="mf">1.0</span> <span class="k">else</span> <span class="n">tk_sym</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">pos_idx</span><span class="p">])</span>
      <span class="n">expr_neg</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">tk_sym</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;^&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="o">-</span><span class="n">h_row</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="k">if</span> <span class="o">-</span><span class="n">h_row</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">!=</span><span class="mf">1.0</span> <span class="k">else</span> <span class="n">tk_sym</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">neg_idx</span><span class="p">])</span>
      <span class="k">if</span> <span class="n">neg_idx</span><span class="o">.</span><span class="n">size</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">expr</span><span class="o">=</span><span class="n">expr_pos</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">expr</span><span class="o">=</span><span class="n">expr_pos</span> <span class="o">+</span> <span class="s1">&#39; / &#39;</span> <span class="o">+</span> <span class="n">expr_neg</span>
      <span class="n">h0</span><span class="o">=</span><span class="n">h0_vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
      <span class="k">if</span> <span class="n">h0</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">x2tk_list</span><span class="o">+=</span><span class="p">[</span><span class="n">x_sym</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39; = &#39;</span><span class="o">+</span> <span class="n">expr</span><span class="p">]</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">x2tk_list</span><span class="o">+=</span><span class="p">[</span><span class="n">x_sym</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39; = &#39;</span> <span class="o">+</span> <span class="n">expr</span> <span class="o">+</span> <span class="s1">&#39; / &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="n">h0</span><span class="p">)]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;(2) x in tk: </span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="s1">&#39;,</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">x2tk_list</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>


  <span class="n">ineq_list</span><span class="o">=</span><span class="p">[]</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">c_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
    <span class="n">c_row</span><span class="o">=</span><span class="n">c_mat</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span>
    <span class="n">pos_idx</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">c_row</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">neg_idx</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">c_row</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">expr_pos</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">tk_sym</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;^&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">c_row</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="k">if</span> <span class="n">c_row</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">!=</span><span class="mf">1.0</span> <span class="k">else</span> <span class="n">tk_sym</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">pos_idx</span><span class="p">])</span>
    <span class="n">expr_neg</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">tk_sym</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;^&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="o">-</span><span class="n">c_row</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="k">if</span> <span class="o">-</span><span class="n">c_row</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">!=</span><span class="mf">1.0</span> <span class="k">else</span> <span class="n">tk_sym</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">neg_idx</span><span class="p">])</span>
    <span class="n">c0</span><span class="o">=</span><span class="n">c0_vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">c0</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
      <span class="n">ineq_list</span><span class="o">+=</span><span class="p">[</span><span class="n">expr_pos</span> <span class="o">+</span> <span class="s1">&#39; &gt; &#39;</span> <span class="o">+</span> <span class="n">expr_neg</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">ineq_list</span><span class="o">+=</span><span class="p">[</span><span class="n">expr_pos</span> <span class="o">+</span> <span class="s1">&#39; &gt; &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">c0</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">expr_neg</span><span class="p">]</span>

  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;(3) BELOW is constraints for regions of validity </span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="s1">&#39;,</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ineq_list</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>




  </div>

    </div>

</div>

<div class="doc doc-object doc-module">



<a id="bcn.catalysis_network"></a>
    <div class="doc doc-contents first">








  <div class="doc doc-children">








<div class="doc doc-object doc-class">



<h2 id="bcn.catalysis_network.binding_and_catalysis" class="doc doc-heading">
            <code>binding_and_catalysis</code>


</h2>


    <div class="doc doc-contents ">







              <details class="quote">
                <summary>Source code in <code>src/bcn/catalysis_network.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 24</span>
<span class="normal"> 25</span>
<span class="normal"> 26</span>
<span class="normal"> 27</span>
<span class="normal"> 28</span>
<span class="normal"> 29</span>
<span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">binding_and_catalysis</span><span class="p">:</span>
  <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">bn</span><span class="p">,</span><span class="n">cn</span><span class="p">,</span><span class="n">kbind</span><span class="p">,</span><span class="n">kcat</span><span class="p">,</span><span class="n">total_const</span><span class="p">,</span><span class="n">total_const_idx</span><span class="p">,</span><span class="n">xcat_in_total_idx</span><span class="p">,</span><span class="n">cat_active_in_xbind_idx</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initiate a binding_and_catalysis object, which contains a binding network and a catalysis network, together with links between them.</span>
<span class="sd">    On the catalysis time scale, the binding constants kbind don&#39;t change.</span>

<span class="sd">    Args:</span>
<span class="sd">        bn (binding_network object): The binding network that specifies how the catalysis fluxes are regulated.</span>
<span class="sd">            It defines the map from xcat (catalysis variables) to concentrations of catalytic active species responsible for the catalysis fluxes.</span>
<span class="sd">            Flux v = kcat * cat_active.</span>
<span class="sd">            It has to contain all the catalytic active species of the catalysis reactions, even if there are reactions that have constant rates. (That corresponds to a binding reaction that is just one atomic entry with constant total.)</span>
<span class="sd">        cn (catalysis_network object): The catalysis network that specifies how the fluxes change molecular concentrations.</span>
<span class="sd">        xcat_in_total_idx (tuple of integers): Indices for xcat as totals in the binding network bn. Length is &lt;= self.dim_ncat.</span>
<span class="sd">            Length could be less than self.dim_ncat, since not necessarily all xcat are contained in totals.</span>
<span class="sd">            The xcat contained in totals NEED TO COME FIRST in the ordering of xcat.</span>
<span class="sd">            xcat = np.concatenate((total[xcat_in_total_idx], xcat[...])).</span>
<span class="sd">        cat_active_in_xbind_idx (tuple of integers): Indices that the active species for the catalysis reactions correspond to in the xbind species in the binding network bn. Length is self.dim_mcat.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">=</span><span class="n">bn</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">kbind</span><span class="o">=</span><span class="n">kbind</span> <span class="c1"># binding network&#39;s binding constants are fixed at the catalysis timescale</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">kcat</span><span class="o">=</span><span class="n">kcat</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">logkbind</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">kbind</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">total_const</span><span class="o">=</span><span class="n">total_const</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">logtotal_const</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">total_const</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">total_const_idx</span><span class="o">=</span><span class="n">total_const_idx</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">cn</span><span class="o">=</span><span class="n">cn</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">xcat_in_total_idx</span><span class="o">=</span><span class="n">xcat_in_total_idx</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">cat_active_in_xbind_idx</span><span class="o">=</span><span class="n">cat_active_in_xbind_idx</span>

    <span class="c1"># # Extend cn.s_mat to shape bn.dim_d by cn.dim_mcat so that the dynamics for</span>
    <span class="c1"># #   every total in the binding networks is contained.</span>
    <span class="c1"># # These extra totals don&#39;t change, so their rows of s_mat are simply zeros.</span>
    <span class="c1"># self.s_mat_total=np.zeros((bn.dim_d,cn.dim_mcat))</span>
    <span class="c1"># self.s_mat_total[cn.xcat_in_total_idx,:]=cn.s_mat</span>
    <span class="c1"># MAYBE, no need to extend. Since all totals that are changed in the catalysis</span>
    <span class="c1">#   time scale are already contained in xcat. If they are not contained, then</span>
    <span class="c1">#   they don&#39;t change, so they can be plugged in as just a parameter.</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">dlogxcatdt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">logxcat</span><span class="p">,</span><span class="n">a_mat</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate dlogxcat/dt for at a given logxcat point.</span>

<span class="sd">    Args:</span>
<span class="sd">        logxcat (numpy array): The vector of xcat in log10 indicating the current state of catalysis dynamics. Length is dim_ncat.</span>
<span class="sd">            Entries of xcat corresponding to totals in the binding network need to come first.</span>
<span class="sd">        a_mat (numpy array): Matrix defining totals in terms of xbind in the binding network. Shape is (bn.dim_d, bn.dim_n).</span>
<span class="sd">            Correspond to conserved quantities at the binding timescale.</span>
<span class="sd">            The default choice should be bn.l_mat.</span>
<span class="sd">            Can be modified from bn.l_mat to describe restrictions or asymptotic limits of the system.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cn</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cn</span>
    <span class="n">bn</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bn</span>
    <span class="n">logtk</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">bn</span><span class="o">.</span><span class="n">dim_n</span><span class="p">)</span>
    <span class="n">n_contained</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xcat_in_total_idx</span><span class="p">)</span>
    <span class="n">logtk</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xcat_in_total_idx</span><span class="p">]</span><span class="o">=</span><span class="n">logxcat</span><span class="p">[:</span><span class="n">n_contained</span><span class="p">]</span> <span class="c1"># totals come first in logtk</span>
    <span class="c1">#   and only n_contained number of xcat are contained in totals.</span>
    <span class="c1"># Then the last r are kbin.</span>
    <span class="n">logtk</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">total_const_idx</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logtotal_const</span>
    <span class="c1"># IS IT TRUE that all totals are contained in xcat? No. Some are constant...</span>
    <span class="n">logtk</span><span class="p">[</span><span class="n">bn</span><span class="o">.</span><span class="n">dim_d</span><span class="p">:]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logkbind</span>
    <span class="n">logxbind</span><span class="o">=</span><span class="n">bn</span><span class="o">.</span><span class="n">tk2x_num</span><span class="p">(</span><span class="n">logtk</span><span class="p">,</span> <span class="n">a_mat</span><span class="o">=</span><span class="n">a_mat</span><span class="p">)</span>
    <span class="c1"># print(&#39;logxbind&#39;, logxbind)</span>
    <span class="n">vcat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">kcat</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="mi">10</span><span class="o">**</span><span class="n">logxbind</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cat_active_in_xbind_idx</span><span class="p">]</span>  <span class="c1"># 2024/08/08 added transposition of kcat</span>
    <span class="n">vcat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">vcat</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># 2024/08/08 added</span>
    <span class="n">new_logxcat</span> <span class="o">=</span> <span class="p">(</span><span class="n">cn</span><span class="o">.</span><span class="n">s_mat</span><span class="nd">@vcat</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10</span><span class="o">**</span><span class="n">logxcat</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="c1"># divide by xcat so that this kinetics of logxcat.</span>
    <span class="k">return</span> <span class="n">new_logxcat</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">get_traj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">logxcat_init</span><span class="p">,</span><span class="n">t_init</span><span class="p">,</span><span class="n">t_end</span><span class="p">,</span><span class="n">npts</span><span class="p">,</span><span class="n">a_mat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span><span class="n">get_logder_xbind</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">a_mat</span><span class="p">):</span> <span class="c1">#if a_mat is not specified, use l_mat by default.</span>
      <span class="n">a_mat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">.</span><span class="n">l_mat</span>
    <span class="n">func_int</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">,</span><span class="n">y</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">dlogxcatdt</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">a_mat</span><span class="p">)</span>
    <span class="n">y0</span><span class="o">=</span><span class="n">logxcat_init</span>
    <span class="n">t_span</span><span class="o">=</span><span class="p">(</span><span class="n">t_init</span><span class="p">,</span><span class="n">t_end</span><span class="p">)</span>
    <span class="n">t_eval</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">t_init</span><span class="p">,</span><span class="n">t_end</span><span class="p">,</span><span class="n">npts</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">events</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">10</span>  <span class="c1"># S in solution less than 1e-8 is not considable.</span>

    <span class="n">events</span><span class="o">.</span><span class="n">terminal</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">sol</span><span class="o">=</span><span class="n">solve_ivp</span><span class="p">(</span><span class="n">func_int</span><span class="p">,</span><span class="n">t_span</span><span class="p">,</span><span class="n">y0</span><span class="p">,</span><span class="n">t_eval</span><span class="o">=</span><span class="n">t_eval</span><span class="p">,</span> <span class="n">events</span><span class="o">=</span><span class="n">events</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;BDF&#39;</span><span class="p">)</span>  <span class="c1"># BDF more suitalbe for stiff ODE</span>
    <span class="n">logxcat_traj</span><span class="o">=</span><span class="n">sol</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">T</span> <span class="c1"># transpose so time points come in the first dim.</span>

    <span class="k">if</span> <span class="n">get_logder_xbind</span><span class="p">:</span>
      <span class="n">logder_traj</span><span class="p">,</span><span class="n">logxbind_traj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_logder_xbind_from_traj</span><span class="p">(</span><span class="n">logxcat_traj</span><span class="p">,</span><span class="n">a_mat</span><span class="o">=</span><span class="n">a_mat</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">sol</span><span class="o">.</span><span class="n">t</span><span class="p">,</span><span class="n">logxcat_traj</span><span class="p">,</span><span class="n">logxbind_traj</span><span class="p">,</span><span class="n">logder_traj</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">sol</span><span class="o">.</span><span class="n">t</span><span class="p">,</span><span class="n">logxcat_traj</span>

  <span class="k">def</span><span class="w"> </span><span class="nf">get_logder_xbind_from_traj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">logxcat_traj</span><span class="p">,</span><span class="n">a_mat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">a_mat</span><span class="p">):</span> <span class="c1">#if a_mat is not specified, use l_mat by default.</span>
      <span class="n">a_mat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">.</span><span class="n">l_mat</span>
    <span class="n">cn</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cn</span>
    <span class="n">bn</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bn</span>
    <span class="n">npts</span><span class="o">=</span><span class="n">logxcat_traj</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">logtk_traj</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npts</span><span class="p">,</span><span class="n">bn</span><span class="o">.</span><span class="n">dim_n</span><span class="p">))</span>
    <span class="n">n_contained</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xcat_in_total_idx</span><span class="p">)</span>
    <span class="n">logtk_traj</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">xcat_in_total_idx</span><span class="p">]</span><span class="o">=</span><span class="n">logxcat_traj</span><span class="p">[:,:</span><span class="n">n_contained</span><span class="p">]</span> <span class="c1"># totals come first in logtk</span>
    <span class="n">logtk_traj</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">total_const_idx</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logtotal_const</span>
    <span class="n">logtk_traj</span><span class="p">[:,</span><span class="n">bn</span><span class="o">.</span><span class="n">dim_d</span><span class="p">:]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logkbind</span>
    <span class="n">logder_traj</span><span class="p">,</span><span class="n">logxbind_traj</span><span class="o">=</span><span class="n">bn</span><span class="o">.</span><span class="n">logder_num</span><span class="p">(</span><span class="n">logtk_traj</span><span class="p">,</span><span class="n">chart</span><span class="o">=</span><span class="s1">&#39;tk&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">logder_traj</span><span class="p">,</span><span class="n">logxbind_traj</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h3 id="bcn.catalysis_network.binding_and_catalysis.__init__" class="doc doc-heading">
            <code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="n">bn</span><span class="p">,</span> <span class="n">cn</span><span class="p">,</span> <span class="n">kbind</span><span class="p">,</span> <span class="n">kcat</span><span class="p">,</span> <span class="n">total_const</span><span class="p">,</span> <span class="n">total_const_idx</span><span class="p">,</span> <span class="n">xcat_in_total_idx</span><span class="p">,</span> <span class="n">cat_active_in_xbind_idx</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Initiate a binding_and_catalysis object, which contains a binding network and a catalysis network, together with links between them.
On the catalysis time scale, the binding constants kbind don't change.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>bn</code>
            </td>
            <td>
                  <code>binding_network object</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The binding network that specifies how the catalysis fluxes are regulated.
It defines the map from xcat (catalysis variables) to concentrations of catalytic active species responsible for the catalysis fluxes.
Flux v = kcat * cat_active.
It has to contain all the catalytic active species of the catalysis reactions, even if there are reactions that have constant rates. (That corresponds to a binding reaction that is just one atomic entry with constant total.)</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>cn</code>
            </td>
            <td>
                  <code>catalysis_network object</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The catalysis network that specifies how the fluxes change molecular concentrations.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>xcat_in_total_idx</code>
            </td>
            <td>
                  <code>tuple of integers</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Indices for xcat as totals in the binding network bn. Length is &lt;= self.dim_ncat.
Length could be less than self.dim_ncat, since not necessarily all xcat are contained in totals.
The xcat contained in totals NEED TO COME FIRST in the ordering of xcat.
xcat = np.concatenate((total[xcat_in_total_idx], xcat[...])).</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>cat_active_in_xbind_idx</code>
            </td>
            <td>
                  <code>tuple of integers</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Indices that the active species for the catalysis reactions correspond to in the xbind species in the binding network bn. Length is self.dim_mcat.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/bcn/catalysis_network.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">bn</span><span class="p">,</span><span class="n">cn</span><span class="p">,</span><span class="n">kbind</span><span class="p">,</span><span class="n">kcat</span><span class="p">,</span><span class="n">total_const</span><span class="p">,</span><span class="n">total_const_idx</span><span class="p">,</span><span class="n">xcat_in_total_idx</span><span class="p">,</span><span class="n">cat_active_in_xbind_idx</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Initiate a binding_and_catalysis object, which contains a binding network and a catalysis network, together with links between them.</span>
<span class="sd">  On the catalysis time scale, the binding constants kbind don&#39;t change.</span>

<span class="sd">  Args:</span>
<span class="sd">      bn (binding_network object): The binding network that specifies how the catalysis fluxes are regulated.</span>
<span class="sd">          It defines the map from xcat (catalysis variables) to concentrations of catalytic active species responsible for the catalysis fluxes.</span>
<span class="sd">          Flux v = kcat * cat_active.</span>
<span class="sd">          It has to contain all the catalytic active species of the catalysis reactions, even if there are reactions that have constant rates. (That corresponds to a binding reaction that is just one atomic entry with constant total.)</span>
<span class="sd">      cn (catalysis_network object): The catalysis network that specifies how the fluxes change molecular concentrations.</span>
<span class="sd">      xcat_in_total_idx (tuple of integers): Indices for xcat as totals in the binding network bn. Length is &lt;= self.dim_ncat.</span>
<span class="sd">          Length could be less than self.dim_ncat, since not necessarily all xcat are contained in totals.</span>
<span class="sd">          The xcat contained in totals NEED TO COME FIRST in the ordering of xcat.</span>
<span class="sd">          xcat = np.concatenate((total[xcat_in_total_idx], xcat[...])).</span>
<span class="sd">      cat_active_in_xbind_idx (tuple of integers): Indices that the active species for the catalysis reactions correspond to in the xbind species in the binding network bn. Length is self.dim_mcat.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="o">=</span><span class="n">bn</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">kbind</span><span class="o">=</span><span class="n">kbind</span> <span class="c1"># binding network&#39;s binding constants are fixed at the catalysis timescale</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">kcat</span><span class="o">=</span><span class="n">kcat</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">logkbind</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">kbind</span><span class="p">)</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">total_const</span><span class="o">=</span><span class="n">total_const</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">logtotal_const</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">total_const</span><span class="p">)</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">total_const_idx</span><span class="o">=</span><span class="n">total_const_idx</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">cn</span><span class="o">=</span><span class="n">cn</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">xcat_in_total_idx</span><span class="o">=</span><span class="n">xcat_in_total_idx</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">cat_active_in_xbind_idx</span><span class="o">=</span><span class="n">cat_active_in_xbind_idx</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="bcn.catalysis_network.binding_and_catalysis.dlogxcatdt" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">dlogxcatdt</span><span class="p">(</span><span class="n">logxcat</span><span class="p">,</span> <span class="n">a_mat</span><span class="p">)</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Calculate dlogxcat/dt for at a given logxcat point.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>logxcat</code>
            </td>
            <td>
                  <code>numpy array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The vector of xcat in log10 indicating the current state of catalysis dynamics. Length is dim_ncat.
Entries of xcat corresponding to totals in the binding network need to come first.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>a_mat</code>
            </td>
            <td>
                  <code>numpy array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Matrix defining totals in terms of xbind in the binding network. Shape is (bn.dim_d, bn.dim_n).
Correspond to conserved quantities at the binding timescale.
The default choice should be bn.l_mat.
Can be modified from bn.l_mat to describe restrictions or asymptotic limits of the system.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/bcn/catalysis_network.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span>
<span class="normal">77</span>
<span class="normal">78</span>
<span class="normal">79</span>
<span class="normal">80</span>
<span class="normal">81</span>
<span class="normal">82</span>
<span class="normal">83</span>
<span class="normal">84</span>
<span class="normal">85</span>
<span class="normal">86</span>
<span class="normal">87</span>
<span class="normal">88</span>
<span class="normal">89</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">dlogxcatdt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">logxcat</span><span class="p">,</span><span class="n">a_mat</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Calculate dlogxcat/dt for at a given logxcat point.</span>

<span class="sd">  Args:</span>
<span class="sd">      logxcat (numpy array): The vector of xcat in log10 indicating the current state of catalysis dynamics. Length is dim_ncat.</span>
<span class="sd">          Entries of xcat corresponding to totals in the binding network need to come first.</span>
<span class="sd">      a_mat (numpy array): Matrix defining totals in terms of xbind in the binding network. Shape is (bn.dim_d, bn.dim_n).</span>
<span class="sd">          Correspond to conserved quantities at the binding timescale.</span>
<span class="sd">          The default choice should be bn.l_mat.</span>
<span class="sd">          Can be modified from bn.l_mat to describe restrictions or asymptotic limits of the system.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">cn</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cn</span>
  <span class="n">bn</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bn</span>
  <span class="n">logtk</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">bn</span><span class="o">.</span><span class="n">dim_n</span><span class="p">)</span>
  <span class="n">n_contained</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xcat_in_total_idx</span><span class="p">)</span>
  <span class="n">logtk</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xcat_in_total_idx</span><span class="p">]</span><span class="o">=</span><span class="n">logxcat</span><span class="p">[:</span><span class="n">n_contained</span><span class="p">]</span> <span class="c1"># totals come first in logtk</span>
  <span class="c1">#   and only n_contained number of xcat are contained in totals.</span>
  <span class="c1"># Then the last r are kbin.</span>
  <span class="n">logtk</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">total_const_idx</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logtotal_const</span>
  <span class="c1"># IS IT TRUE that all totals are contained in xcat? No. Some are constant...</span>
  <span class="n">logtk</span><span class="p">[</span><span class="n">bn</span><span class="o">.</span><span class="n">dim_d</span><span class="p">:]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logkbind</span>
  <span class="n">logxbind</span><span class="o">=</span><span class="n">bn</span><span class="o">.</span><span class="n">tk2x_num</span><span class="p">(</span><span class="n">logtk</span><span class="p">,</span> <span class="n">a_mat</span><span class="o">=</span><span class="n">a_mat</span><span class="p">)</span>
  <span class="c1"># print(&#39;logxbind&#39;, logxbind)</span>
  <span class="n">vcat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">kcat</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="mi">10</span><span class="o">**</span><span class="n">logxbind</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cat_active_in_xbind_idx</span><span class="p">]</span>  <span class="c1"># 2024/08/08 added transposition of kcat</span>
  <span class="n">vcat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">vcat</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># 2024/08/08 added</span>
  <span class="n">new_logxcat</span> <span class="o">=</span> <span class="p">(</span><span class="n">cn</span><span class="o">.</span><span class="n">s_mat</span><span class="nd">@vcat</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10</span><span class="o">**</span><span class="n">logxcat</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="c1"># divide by xcat so that this kinetics of logxcat.</span>
  <span class="k">return</span> <span class="n">new_logxcat</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="bcn.catalysis_network.catalysis_network" class="doc doc-heading">
            <code>catalysis_network</code>


</h2>


    <div class="doc doc-contents ">







              <details class="quote">
                <summary>Source code in <code>src/bcn/catalysis_network.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">catalysis_network</span><span class="p">:</span>
  <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">s_mat</span><span class="p">,</span>
            <span class="n">xcat_sym</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span>
            <span class="n">vcat_sym</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initiate a catalysis_network object.</span>

<span class="sd">    Args:</span>
<span class="sd">        s_mat (numpy array): The stoichiometry matrix defining the catalysis network. Shape is (n_cat, m_cat).</span>
<span class="sd">            Not necessarily full rank.</span>
<span class="sd">            n_cat is the number of rows, i.e. the number of variables for catalysis dynamics, same as length of xcat.</span>
<span class="sd">            m_cat is the number of columns, i.e. the number of catalysis reactions, same as length of kcat.</span>
<span class="sd">        xcat_sym (numpy array of sympy symbols, optional): Symbols for xcat variables. Length n_cat.</span>
<span class="sd">        vcat_sym (numpy array of sympy symbols, optional): Symbols for vcat variables, fluxes of catalysis reactions. Length m_cat.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">s_mat</span><span class="o">=</span><span class="n">s_mat</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dim_ncat</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_mcat</span><span class="o">=</span><span class="n">s_mat</span><span class="o">.</span><span class="n">shape</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h3 id="bcn.catalysis_network.catalysis_network.__init__" class="doc doc-heading">
            <code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="n">s_mat</span><span class="p">,</span> <span class="n">xcat_sym</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span> <span class="n">vcat_sym</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span></code>

</h3>


    <div class="doc doc-contents ">

        <p>Initiate a catalysis_network object.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>s_mat</code>
            </td>
            <td>
                  <code>numpy array</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The stoichiometry matrix defining the catalysis network. Shape is (n_cat, m_cat).
Not necessarily full rank.
n_cat is the number of rows, i.e. the number of variables for catalysis dynamics, same as length of xcat.
m_cat is the number of columns, i.e. the number of catalysis reactions, same as length of kcat.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>xcat_sym</code>
            </td>
            <td>
                  <code>numpy array of sympy symbols</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Symbols for xcat variables. Length n_cat.</p>
              </div>
            </td>
            <td>
                  <code><span title="numpy.array">array</span>([])</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>vcat_sym</code>
            </td>
            <td>
                  <code>numpy array of sympy symbols</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Symbols for vcat variables, fluxes of catalysis reactions. Length m_cat.</p>
              </div>
            </td>
            <td>
                  <code><span title="numpy.array">array</span>([])</code>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>src/bcn/catalysis_network.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
          <span class="n">s_mat</span><span class="p">,</span>
          <span class="n">xcat_sym</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span>
          <span class="n">vcat_sym</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Initiate a catalysis_network object.</span>

<span class="sd">  Args:</span>
<span class="sd">      s_mat (numpy array): The stoichiometry matrix defining the catalysis network. Shape is (n_cat, m_cat).</span>
<span class="sd">          Not necessarily full rank.</span>
<span class="sd">          n_cat is the number of rows, i.e. the number of variables for catalysis dynamics, same as length of xcat.</span>
<span class="sd">          m_cat is the number of columns, i.e. the number of catalysis reactions, same as length of kcat.</span>
<span class="sd">      xcat_sym (numpy array of sympy symbols, optional): Symbols for xcat variables. Length n_cat.</span>
<span class="sd">      vcat_sym (numpy array of sympy symbols, optional): Symbols for vcat variables, fluxes of catalysis reactions. Length m_cat.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">s_mat</span><span class="o">=</span><span class="n">s_mat</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">dim_ncat</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">dim_mcat</span><span class="o">=</span><span class="n">s_mat</span><span class="o">.</span><span class="n">shape</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>




  </div>

    </div>

</div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": ".", "features": ["navigation.tabs"], "search": "assets/javascripts/workers/search.f8cc74c7.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="assets/javascripts/bundle.c8b220af.min.js"></script>
      
    
  </body>
</html>